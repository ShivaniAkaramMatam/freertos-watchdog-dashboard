# 0 "/home/shivani/bl602_iot_sdk/customer_app/suas_app_freertos_watchdog/suas_app_freertos_tasks/main.cpp"
# 1 "/home/shivani/bl602_iot_sdk/customer_app/suas_app_freertos_watchdog/build_out/suas_app_freertos_tasks//"
# 0 "<built-in>"
#define __STDC__ 1
# 0 "<built-in>"
#define __cplusplus 202302L
# 0 "<built-in>"
#define __STDC_UTF_16__ 1
# 0 "<built-in>"
#define __STDC_UTF_32__ 1
# 0 "<built-in>"
#define __STDC_HOSTED__ 0
# 0 "<built-in>"
#define __STDC_EMBED_NOT_FOUND__ 0
# 0 "<built-in>"
#define __STDC_EMBED_FOUND__ 1
# 0 "<built-in>"
#define __STDC_EMBED_EMPTY__ 2
# 0 "<built-in>"
#define __GNUC__ 15
# 0 "<built-in>"
#define __GNUC_MINOR__ 1
# 0 "<built-in>"
#define __GNUC_PATCHLEVEL__ 0
# 0 "<built-in>"
#define __VERSION__ "15.1.0"
# 0 "<built-in>"
#define __ATOMIC_RELAXED 0
# 0 "<built-in>"
#define __ATOMIC_SEQ_CST 5
# 0 "<built-in>"
#define __ATOMIC_ACQUIRE 2
# 0 "<built-in>"
#define __ATOMIC_RELEASE 3
# 0 "<built-in>"
#define __ATOMIC_ACQ_REL 4
# 0 "<built-in>"
#define __ATOMIC_CONSUME 1
# 0 "<built-in>"
#define __OPTIMIZE_SIZE__ 1
# 0 "<built-in>"
#define __OPTIMIZE__ 1
# 0 "<built-in>"
#define __FINITE_MATH_ONLY__ 0
# 0 "<built-in>"
#define __SIZEOF_INT__ 4
# 0 "<built-in>"
#define __SIZEOF_LONG__ 4
# 0 "<built-in>"
#define __SIZEOF_LONG_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_SHORT__ 2
# 0 "<built-in>"
#define __SIZEOF_FLOAT__ 4
# 0 "<built-in>"
#define __SIZEOF_DOUBLE__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_DOUBLE__ 16
# 0 "<built-in>"
#define __SIZEOF_SIZE_T__ 4
# 0 "<built-in>"
#define __CHAR_BIT__ 8
# 0 "<built-in>"
#define __BIGGEST_ALIGNMENT__ 16
# 0 "<built-in>"
#define __ORDER_LITTLE_ENDIAN__ 1234
# 0 "<built-in>"
#define __ORDER_BIG_ENDIAN__ 4321
# 0 "<built-in>"
#define __ORDER_PDP_ENDIAN__ 3412
# 0 "<built-in>"
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __SIZEOF_POINTER__ 4
# 0 "<built-in>"
#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
# 0 "<built-in>"
#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
# 0 "<built-in>"
#define __GNUG__ 15
# 0 "<built-in>"
#define __SIZE_TYPE__ unsigned int
# 0 "<built-in>"
#define __PTRDIFF_TYPE__ int
# 0 "<built-in>"
#define __WCHAR_TYPE__ int
# 0 "<built-in>"
#define __WINT_TYPE__ unsigned int
# 0 "<built-in>"
#define __INTMAX_TYPE__ long long int
# 0 "<built-in>"
#define __UINTMAX_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __CHAR8_TYPE__ unsigned char
# 0 "<built-in>"
#define __CHAR16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __CHAR32_TYPE__ long unsigned int
# 0 "<built-in>"
#define __SIG_ATOMIC_TYPE__ int
# 0 "<built-in>"
#define __INT8_TYPE__ signed char
# 0 "<built-in>"
#define __INT16_TYPE__ short int
# 0 "<built-in>"
#define __INT32_TYPE__ long int
# 0 "<built-in>"
#define __INT64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT32_TYPE__ long unsigned int
# 0 "<built-in>"
#define __UINT64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_LEAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_LEAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_LEAST32_TYPE__ long int
# 0 "<built-in>"
#define __INT_LEAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_LEAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_LEAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_LEAST32_TYPE__ long unsigned int
# 0 "<built-in>"
#define __UINT_LEAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_FAST8_TYPE__ int
# 0 "<built-in>"
#define __INT_FAST16_TYPE__ int
# 0 "<built-in>"
#define __INT_FAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_FAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_FAST8_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_FAST16_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_FAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_FAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INTPTR_TYPE__ int
# 0 "<built-in>"
#define __UINTPTR_TYPE__ unsigned int
# 0 "<built-in>"
#define __GXX_WEAK__ 1
# 0 "<built-in>"
#define __DEPRECATED 1
# 0 "<built-in>"
#define __GXX_EXPERIMENTAL_CXX0X__ 1
# 0 "<built-in>"
#define __GXX_CONSTEXPR_ASM__ 1
# 0 "<built-in>"
#define __cpp_binary_literals 201304L
# 0 "<built-in>"
#define __cpp_hex_float 201603L
# 0 "<built-in>"
#define __cpp_runtime_arrays 198712L
# 0 "<built-in>"
#define __cpp_raw_strings 200710L
# 0 "<built-in>"
#define __cpp_unicode_literals 200710L
# 0 "<built-in>"
#define __cpp_user_defined_literals 200809L
# 0 "<built-in>"
#define __cpp_lambdas 200907L
# 0 "<built-in>"
#define __cpp_decltype 200707L
# 0 "<built-in>"
#define __cpp_attributes 200809L
# 0 "<built-in>"
#define __cpp_rvalue_reference 200610L
# 0 "<built-in>"
#define __cpp_rvalue_references 200610L
# 0 "<built-in>"
#define __cpp_variadic_templates 200704L
# 0 "<built-in>"
#define __cpp_initializer_lists 200806L
# 0 "<built-in>"
#define __cpp_delegating_constructors 200604L
# 0 "<built-in>"
#define __cpp_nsdmi 200809L
# 0 "<built-in>"
#define __cpp_inheriting_constructors 201511L
# 0 "<built-in>"
#define __cpp_ref_qualifiers 200710L
# 0 "<built-in>"
#define __cpp_alias_templates 200704L
# 0 "<built-in>"
#define __cpp_return_type_deduction 201304L
# 0 "<built-in>"
#define __cpp_decltype_auto 201304L
# 0 "<built-in>"
#define __cpp_aggregate_nsdmi 201304L
# 0 "<built-in>"
#define __cpp_variable_templates 201304L
# 0 "<built-in>"
#define __cpp_digit_separators 201309L
# 0 "<built-in>"
#define __cpp_unicode_characters 201411L
# 0 "<built-in>"
#define __cpp_static_assert 201411L
# 0 "<built-in>"
#define __cpp_namespace_attributes 201411L
# 0 "<built-in>"
#define __cpp_enumerator_attributes 201411L
# 0 "<built-in>"
#define __cpp_nested_namespace_definitions 201411L
# 0 "<built-in>"
#define __cpp_fold_expressions 201603L
# 0 "<built-in>"
#define __cpp_range_based_for 202211L
# 0 "<built-in>"
#define __cpp_if_constexpr 201606L
# 0 "<built-in>"
#define __cpp_capture_star_this 201603L
# 0 "<built-in>"
#define __cpp_inline_variables 201606L
# 0 "<built-in>"
#define __cpp_aggregate_bases 201603L
# 0 "<built-in>"
#define __cpp_noexcept_function_type 201510L
# 0 "<built-in>"
#define __cpp_template_auto 201606L
# 0 "<built-in>"
#define __cpp_structured_bindings 201606L
# 0 "<built-in>"
#define __cpp_variadic_using 201611L
# 0 "<built-in>"
#define __cpp_guaranteed_copy_elision 201606L
# 0 "<built-in>"
#define __cpp_nontype_template_parameter_auto 201606L
# 0 "<built-in>"
#define __cpp_init_captures 201803L
# 0 "<built-in>"
#define __cpp_generic_lambdas 201707L
# 0 "<built-in>"
#define __cpp_designated_initializers 201707L
# 0 "<built-in>"
#define __cpp_constexpr_in_decltype 201711L
# 0 "<built-in>"
#define __cpp_conditional_explicit 201806L
# 0 "<built-in>"
#define __cpp_consteval 202211L
# 0 "<built-in>"
#define __cpp_constinit 201907L
# 0 "<built-in>"
#define __cpp_deduction_guides 201907L
# 0 "<built-in>"
#define __cpp_nontype_template_args 201911L
# 0 "<built-in>"
#define __cpp_nontype_template_parameter_class 201806L
# 0 "<built-in>"
#define __cpp_impl_destroying_delete 201806L
# 0 "<built-in>"
#define __cpp_constexpr_dynamic_alloc 201907L
# 0 "<built-in>"
#define __cpp_impl_three_way_comparison 201907L
# 0 "<built-in>"
#define __cpp_aggregate_paren_init 201902L
# 0 "<built-in>"
#define __cpp_using_enum 201907L
# 0 "<built-in>"
#define __cpp_size_t_suffix 202011L
# 0 "<built-in>"
#define __cpp_if_consteval 202106L
# 0 "<built-in>"
#define __cpp_auto_cast 202110L
# 0 "<built-in>"
#define __cpp_constexpr 202211L
# 0 "<built-in>"
#define __cpp_multidimensional_subscript 202211L
# 0 "<built-in>"
#define __cpp_named_character_escapes 202207L
# 0 "<built-in>"
#define __cpp_static_call_operator 202207L
# 0 "<built-in>"
#define __cpp_implicit_move 202207L
# 0 "<built-in>"
#define __cpp_explicit_this_parameter 202110L
# 0 "<built-in>"
#define __cpp_concepts 202002L
# 0 "<built-in>"
#define __cpp_impl_coroutine 201902L
# 0 "<built-in>"
#define __cpp_sized_deallocation 201309L
# 0 "<built-in>"
#define __cpp_aligned_new 201606L
# 0 "<built-in>"
#define __STDCPP_DEFAULT_NEW_ALIGNMENT__ 16
# 0 "<built-in>"
#define __cpp_template_template_args 201611L
# 0 "<built-in>"
#define __cpp_threadsafe_static_init 200806L
# 0 "<built-in>"
#define __cpp_char8_t 202207L
# 0 "<built-in>"
#define __GXX_ABI_VERSION 1020
# 0 "<built-in>"
#define __SCHAR_MAX__ 0x7f
# 0 "<built-in>"
#define __SHRT_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __LONG_MAX__ 0x7fffffffL
# 0 "<built-in>"
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __WCHAR_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
# 0 "<built-in>"
#define __WINT_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __WINT_MIN__ 0U
# 0 "<built-in>"
#define __PTRDIFF_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __SIZE_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __SCHAR_WIDTH__ 8
# 0 "<built-in>"
#define __SHRT_WIDTH__ 16
# 0 "<built-in>"
#define __INT_WIDTH__ 32
# 0 "<built-in>"
#define __LONG_WIDTH__ 32
# 0 "<built-in>"
#define __LONG_LONG_WIDTH__ 64
# 0 "<built-in>"
#define __WCHAR_WIDTH__ 32
# 0 "<built-in>"
#define __WINT_WIDTH__ 32
# 0 "<built-in>"
#define __PTRDIFF_WIDTH__ 32
# 0 "<built-in>"
#define __SIZE_WIDTH__ 32
# 0 "<built-in>"
#define __INTMAX_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INTMAX_C(c) c ## LL
# 0 "<built-in>"
#define __UINTMAX_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __UINTMAX_C(c) c ## ULL
# 0 "<built-in>"
#define __INTMAX_WIDTH__ 64
# 0 "<built-in>"
#define __SIG_ATOMIC_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
# 0 "<built-in>"
#define __SIG_ATOMIC_WIDTH__ 32
# 0 "<built-in>"
#define __INT8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT32_MAX__ 0x7fffffffL
# 0 "<built-in>"
#define __INT64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __UINT8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT32_MAX__ 0xffffffffUL
# 0 "<built-in>"
#define __UINT64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INT_LEAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT8_C(c) c
# 0 "<built-in>"
#define __INT_LEAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_LEAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT16_C(c) c
# 0 "<built-in>"
#define __INT_LEAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_LEAST32_MAX__ 0x7fffffffL
# 0 "<built-in>"
#define __INT32_C(c) c ## L
# 0 "<built-in>"
#define __INT_LEAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT64_C(c) c ## LL
# 0 "<built-in>"
#define __INT_LEAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_LEAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT8_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT16_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST32_MAX__ 0xffffffffUL
# 0 "<built-in>"
#define __UINT32_C(c) c ## UL
# 0 "<built-in>"
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __UINT64_C(c) c ## ULL
# 0 "<built-in>"
#define __INT_FAST8_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT_FAST8_WIDTH__ 32
# 0 "<built-in>"
#define __INT_FAST16_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT_FAST16_WIDTH__ 32
# 0 "<built-in>"
#define __INT_FAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT_FAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT_FAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_FAST8_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT_FAST16_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT_FAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INTPTR_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INTPTR_WIDTH__ 32
# 0 "<built-in>"
#define __UINTPTR_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __GCC_IEC_559 0
# 0 "<built-in>"
#define __GCC_IEC_559_COMPLEX 0
# 0 "<built-in>"
#define __FLT_EVAL_METHOD__ 0
# 0 "<built-in>"
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
# 0 "<built-in>"
#define __DEC_EVAL_METHOD__ 2
# 0 "<built-in>"
#define __FLT_RADIX__ 2
# 0 "<built-in>"
#define __FLT_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT_DIG__ 6
# 0 "<built-in>"
#define __FLT_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
# 0 "<built-in>"
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
# 0 "<built-in>"
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
# 0 "<built-in>"
#define __FLT_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FP_FAST_FMAF 1
# 0 "<built-in>"
#define __FLT_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __DBL_MANT_DIG__ 53
# 0 "<built-in>"
#define __DBL_DIG__ 15
# 0 "<built-in>"
#define __DBL_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __DBL_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __DBL_MAX_EXP__ 1024
# 0 "<built-in>"
#define __DBL_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __DBL_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __DBL_MAX__ double(1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_NORM_MAX__ double(1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_MIN__ double(2.22507385850720138309023271733240406e-308L)
# 0 "<built-in>"
#define __DBL_EPSILON__ double(2.22044604925031308084726333618164062e-16L)
# 0 "<built-in>"
#define __DBL_DENORM_MIN__ double(4.94065645841246544176568792868221372e-324L)
# 0 "<built-in>"
#define __DBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __DBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __DBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __DBL_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __LDBL_MANT_DIG__ 113
# 0 "<built-in>"
#define __LDBL_DIG__ 33
# 0 "<built-in>"
#define __LDBL_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __LDBL_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __LDBL_MAX_EXP__ 16384
# 0 "<built-in>"
#define __LDBL_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __LDBL_DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __LDBL_MAX__ 1.18973149535723176508575932662800702e+4932L
# 0 "<built-in>"
#define __LDBL_NORM_MAX__ 1.18973149535723176508575932662800702e+4932L
# 0 "<built-in>"
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
# 0 "<built-in>"
#define __LDBL_EPSILON__ 1.92592994438723585305597794258492732e-34L
# 0 "<built-in>"
#define __LDBL_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966L
# 0 "<built-in>"
#define __LDBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __LDBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __LDBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __LDBL_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __STDCPP_FLOAT16_T__ 1
# 0 "<built-in>"
#define __FLT16_MANT_DIG__ 11
# 0 "<built-in>"
#define __FLT16_DIG__ 3
# 0 "<built-in>"
#define __FLT16_MIN_EXP__ (-13)
# 0 "<built-in>"
#define __FLT16_MIN_10_EXP__ (-4)
# 0 "<built-in>"
#define __FLT16_MAX_EXP__ 16
# 0 "<built-in>"
#define __FLT16_MAX_10_EXP__ 4
# 0 "<built-in>"
#define __FLT16_DECIMAL_DIG__ 5
# 0 "<built-in>"
#define __FLT16_MAX__ 6.55040000000000000000000000000000000e+4F16
# 0 "<built-in>"
#define __FLT16_NORM_MAX__ 6.55040000000000000000000000000000000e+4F16
# 0 "<built-in>"
#define __FLT16_MIN__ 6.10351562500000000000000000000000000e-5F16
# 0 "<built-in>"
#define __FLT16_EPSILON__ 9.76562500000000000000000000000000000e-4F16
# 0 "<built-in>"
#define __FLT16_DENORM_MIN__ 5.96046447753906250000000000000000000e-8F16
# 0 "<built-in>"
#define __FLT16_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT16_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT16_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT16_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __STDCPP_FLOAT32_T__ 1
# 0 "<built-in>"
#define __FLT32_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT32_DIG__ 6
# 0 "<built-in>"
#define __FLT32_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT32_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT32_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT32_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT32_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
# 0 "<built-in>"
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
# 0 "<built-in>"
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
# 0 "<built-in>"
#define __FLT32_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FP_FAST_FMAF32 1
# 0 "<built-in>"
#define __FLT32_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __STDCPP_FLOAT64_T__ 1
# 0 "<built-in>"
#define __FLT64_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT64_DIG__ 15
# 0 "<built-in>"
#define __FLT64_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT64_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT64_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT64_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT64_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
# 0 "<built-in>"
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
# 0 "<built-in>"
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
# 0 "<built-in>"
#define __FLT64_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __STDCPP_FLOAT128_T__ 1
# 0 "<built-in>"
#define __FLT128_MANT_DIG__ 113
# 0 "<built-in>"
#define __FLT128_DIG__ 33
# 0 "<built-in>"
#define __FLT128_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT128_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT128_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT128_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT128_DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
# 0 "<built-in>"
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
# 0 "<built-in>"
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
# 0 "<built-in>"
#define __FLT128_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT128_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT128_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT128_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __FLT32X_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT32X_DIG__ 15
# 0 "<built-in>"
#define __FLT32X_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT32X_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT32X_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT32X_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT32X_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
# 0 "<built-in>"
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
# 0 "<built-in>"
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
# 0 "<built-in>"
#define __FLT32X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT32X_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __FLT64X_MANT_DIG__ 113
# 0 "<built-in>"
#define __FLT64X_DIG__ 33
# 0 "<built-in>"
#define __FLT64X_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT64X_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT64X_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT64X_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT64X_DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __FLT64X_MAX__ 1.18973149535723176508575932662800702e+4932F64x
# 0 "<built-in>"
#define __FLT64X_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F64x
# 0 "<built-in>"
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
# 0 "<built-in>"
#define __FLT64X_EPSILON__ 1.92592994438723585305597794258492732e-34F64x
# 0 "<built-in>"
#define __FLT64X_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F64x
# 0 "<built-in>"
#define __FLT64X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64X_IS_IEC_60559__ 1
# 0 "<built-in>"
#define __STDCPP_BFLOAT16_T__ 1
# 0 "<built-in>"
#define __BFLT16_MANT_DIG__ 8
# 0 "<built-in>"
#define __BFLT16_DIG__ 2
# 0 "<built-in>"
#define __BFLT16_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __BFLT16_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __BFLT16_MAX_EXP__ 128
# 0 "<built-in>"
#define __BFLT16_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __BFLT16_DECIMAL_DIG__ 4
# 0 "<built-in>"
#define __BFLT16_MAX__ 3.38953138925153547590470800371487867e+38BF16
# 0 "<built-in>"
#define __BFLT16_NORM_MAX__ 3.38953138925153547590470800371487867e+38BF16
# 0 "<built-in>"
#define __BFLT16_MIN__ 1.17549435082228750796873653722224568e-38BF16
# 0 "<built-in>"
#define __BFLT16_EPSILON__ 7.81250000000000000000000000000000000e-3BF16
# 0 "<built-in>"
#define __BFLT16_DENORM_MIN__ 9.18354961579912115600575419704879436e-41BF16
# 0 "<built-in>"
#define __BFLT16_HAS_DENORM__ 1
# 0 "<built-in>"
#define __BFLT16_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __BFLT16_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __BFLT16_IS_IEC_60559__ 0
# 0 "<built-in>"
#define __REGISTER_PREFIX__ 
# 0 "<built-in>"
#define __USER_LABEL_PREFIX__ 
# 0 "<built-in>"
#define __GNUC_STDC_INLINE__ 1
# 0 "<built-in>"
#define __STRICT_ANSI__ 1
# 0 "<built-in>"
#define __CHAR_UNSIGNED__ 1
# 0 "<built-in>"
#define __GCC_ATOMIC_BOOL_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR8_T_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_SHORT_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_INT_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_LONG_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_LLONG_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
# 0 "<built-in>"
#define __GCC_DESTRUCTIVE_SIZE 32
# 0 "<built-in>"
#define __GCC_CONSTRUCTIVE_SIZE 32
# 0 "<built-in>"
#define __GCC_ATOMIC_POINTER_LOCK_FREE 1
# 0 "<built-in>"
#define __GCC_HAVE_DWARF2_CFI_ASM 1
# 0 "<built-in>"
#define __PRAGMA_REDEFINE_EXTNAME 1
# 0 "<built-in>"
#define __SIZEOF_WCHAR_T__ 4
# 0 "<built-in>"
#define __SIZEOF_WINT_T__ 4
# 0 "<built-in>"
#define __SIZEOF_PTRDIFF_T__ 4
# 0 "<built-in>"
#define __riscv 1
# 0 "<built-in>"
#define __riscv_compressed 1
# 0 "<built-in>"
#define __riscv_mul 1
# 0 "<built-in>"
#define __riscv_div 1
# 0 "<built-in>"
#define __riscv_muldiv 1
# 0 "<built-in>"
#define __riscv_xlen 32
# 0 "<built-in>"
#define __riscv_flen 32
# 0 "<built-in>"
#define __riscv_fdiv 1
# 0 "<built-in>"
#define __riscv_fsqrt 1
# 0 "<built-in>"
#define __riscv_float_abi_single 1
# 0 "<built-in>"
#define __riscv_cmodel_medlow 1
# 0 "<built-in>"
#define __riscv_misaligned_slow 1
# 0 "<built-in>"
#define __riscv_arch_test 1
# 0 "<built-in>"
#define __riscv_i 2001000
# 0 "<built-in>"
#define __riscv_m 2000000
# 0 "<built-in>"
#define __riscv_f 2002000
# 0 "<built-in>"
#define __riscv_c 2000000
# 0 "<built-in>"
#define __riscv_zicsr 2000000
# 0 "<built-in>"
#define __riscv_zmmul 1000000
# 0 "<built-in>"
#define __riscv_zca 1000000
# 0 "<built-in>"
#define __riscv_zcf 1000000
# 0 "<built-in>"
#define __ELF__ 1
# 0 "<command-line>"
#define CONF_USER_ENABLE_PSRAM 1
# 0 "<command-line>"
#define ETL_NO_STL 1
# 0 "<command-line>"
#define BL_SDK_VER "release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty"
# 0 "<command-line>"
#define BL_SDK_PHY_VER "a0_final-44-geb7fadd"
# 0 "<command-line>"
#define BL_SDK_RF_VER "f76e39a"
# 0 "<command-line>"
#define BL_CHIP_NAME "BL602"
# 0 "<command-line>"
#define BL_SDK_VER "release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty"
# 0 "<command-line>"
#define BL_SDK_PHY_VER "a0_final-44-geb7fadd"
# 0 "<command-line>"
#define BL_SDK_RF_VER "f76e39a"
# 0 "<command-line>"
#define ARCH_RISCV 1
# 0 "<command-line>"
#define CONFIG_PSM_EASYFLASH_SIZE 16384
# 0 "<command-line>"
#define configUSE_TICKLESS_IDLE 0
# 0 "<command-line>"
#define FEATURE_WIFI_DISABLE 1
# 0 "<command-line>"
#define CFG_COMPONENT_BLOG_ENABLE 0
# 0 "<command-line>"
#define __FILENAME__ "main.cpp"
# 0 "<command-line>"
#define __FILENAME_WO_SUFFIX__ "mainpp"
# 0 "<command-line>"
#define __FILENAME_WO_SUFFIX_DEQUOTED__ mainpp
# 0 "<command-line>"
#define __COMPONENT_NAME__ "suas_app_freertos_tasks"
# 0 "<command-line>"
#define __COMPONENT_NAME_DEQUOTED__ suas_app_freertos_tasks
# 0 "<command-line>"
#define __COMPONENT_FILE_NAME__ "suas_app_freertos_tasksmainpp"
# 0 "<command-line>"
#define __COMPONENT_FILE_NAMED__ suas_app_freertos_tasks.mainpp
# 0 "<command-line>"
#define __COMPONENT_FILE_NAME_DEQUOTED__ suas_app_freertos_tasksmainpp
# 0 "<command-line>"
#define BL_SDK_VER "release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty"
# 0 "<command-line>"
#define BL_SDK_PHY_VER "a0_final-44-geb7fadd"
# 0 "<command-line>"
#define BL_SDK_RF_VER "f76e39a"
# 0 "<command-line>"
#define BL_CHIP_NAME "BL602"
# 0 "<command-line>"
#define BL_SDK_VER "release_bl_iot_sdk_1.6.11-1-g66bb28da-dirty"
# 0 "<command-line>"
#define BL_SDK_PHY_VER "a0_final-44-geb7fadd"
# 0 "<command-line>"
#define BL_SDK_RF_VER "f76e39a"
# 0 "<command-line>"
#define ARCH_RISCV 1
# 0 "<command-line>"
#define CONFIG_PSM_EASYFLASH_SIZE 16384
# 0 "<command-line>"
#define configUSE_TICKLESS_IDLE 0
# 0 "<command-line>"
#define FEATURE_WIFI_DISABLE 1
# 0 "<command-line>"
#define CFG_COMPONENT_BLOG_ENABLE 0
# 1 "/home/shivani/bl602_iot_sdk/customer_app/suas_app_freertos_watchdog/suas_app_freertos_tasks/main.cpp"
extern "C" {

# 1 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h" 1
# 29 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define INC_FREERTOS_H 




# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 39 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#define _STDDEF_H 
#define _STDDEF_H_ 

#define _ANSI_STDDEF_H 
# 147 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#define _PTRDIFF_T 
#define _T_PTRDIFF_ 
#define _T_PTRDIFF 
#define __PTRDIFF_T 
#define _PTRDIFF_T_ 
#define _BSD_PTRDIFF_T_ 
#define ___int_ptrdiff_t_h 
#define _GCC_PTRDIFF_T 
#define _PTRDIFF_T_DECLARED 
#define __DEFINED_ptrdiff_t 




# 160 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
typedef int ptrdiff_t;
# 173 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 200 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#define __size_t__ 
#define __SIZE_T__ 
#define _SIZE_T 
#define _SYS_SIZE_T_H 
#define _T_SIZE_ 
#define _T_SIZE 
#define __SIZE_T 
#define _SIZE_T_ 
#define _BSD_SIZE_T_ 
#define _SIZE_T_DEFINED_ 
#define _SIZE_T_DEFINED 
#define _BSD_SIZE_T_DEFINED_ 
#define _SIZE_T_DECLARED 
#define __DEFINED_size_t 
#define ___int_size_t_h 
#define _GCC_SIZE_T 
#define _SIZET_ 






#define __size_t 





typedef unsigned int size_t;
# 252 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_size_t
# 282 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#define __wchar_t__ 
#define __WCHAR_T__ 
#define _WCHAR_T 
#define _T_WCHAR_ 
#define _T_WCHAR 
#define __WCHAR_T 
#define _WCHAR_T_ 
#define _BSD_WCHAR_T_ 
#define _WCHAR_T_DEFINED_ 
#define _WCHAR_T_DEFINED 
#define _WCHAR_T_H 
#define ___int_wchar_t_h 
#define __INT_WCHAR_T_H 
#define _GCC_WCHAR_T 
#define _WCHAR_T_DECLARED 
#define __DEFINED_wchar_t 
# 310 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef _BSD_WCHAR_T_
# 364 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_wchar_t
# 414 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef NULL

#define NULL __null
# 425 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_NULL




#undef offsetof
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)




#define _GCC_MAX_ALIGN_T 



typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 451 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
} max_align_t;





#define _GXX_NULLPTR_T 
  typedef decltype(nullptr) nullptr_t;
# 35 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h" 2
# 49 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stdint.h" 1 3 4
# 14 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stdint.h" 3 4
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stdint-gcc.h" 1 3 4
# 29 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stdint-gcc.h" 3 4
#define _GCC_STDINT_H 




typedef signed char int8_t;


typedef short int int16_t;


typedef long int int32_t;


typedef long long int int64_t;


typedef unsigned char uint8_t;


typedef short unsigned int uint16_t;


typedef long unsigned int uint32_t;


typedef long long unsigned int uint64_t;




typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef long int int_least32_t;
typedef long long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef short unsigned int uint_least16_t;
typedef long unsigned int uint_least32_t;
typedef long long unsigned int uint_least64_t;



typedef int int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int int_fast64_t;
typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef long long unsigned int uint_fast64_t;




typedef int intptr_t;


typedef unsigned int uintptr_t;




typedef long long int intmax_t;
typedef long long unsigned int uintmax_t;







#undef INT8_MAX
#define INT8_MAX __INT8_MAX__
#undef INT8_MIN
#define INT8_MIN (-INT8_MAX - 1)


#undef UINT8_MAX
#define UINT8_MAX __UINT8_MAX__


#undef INT16_MAX
#define INT16_MAX __INT16_MAX__
#undef INT16_MIN
#define INT16_MIN (-INT16_MAX - 1)


#undef UINT16_MAX
#define UINT16_MAX __UINT16_MAX__


#undef INT32_MAX
#define INT32_MAX __INT32_MAX__
#undef INT32_MIN
#define INT32_MIN (-INT32_MAX - 1)


#undef UINT32_MAX
#define UINT32_MAX __UINT32_MAX__


#undef INT64_MAX
#define INT64_MAX __INT64_MAX__
#undef INT64_MIN
#define INT64_MIN (-INT64_MAX - 1)


#undef UINT64_MAX
#define UINT64_MAX __UINT64_MAX__


#undef INT_LEAST8_MAX
#define INT_LEAST8_MAX __INT_LEAST8_MAX__
#undef INT_LEAST8_MIN
#define INT_LEAST8_MIN (-INT_LEAST8_MAX - 1)
#undef UINT_LEAST8_MAX
#define UINT_LEAST8_MAX __UINT_LEAST8_MAX__
#undef INT_LEAST16_MAX
#define INT_LEAST16_MAX __INT_LEAST16_MAX__
#undef INT_LEAST16_MIN
#define INT_LEAST16_MIN (-INT_LEAST16_MAX - 1)
#undef UINT_LEAST16_MAX
#define UINT_LEAST16_MAX __UINT_LEAST16_MAX__
#undef INT_LEAST32_MAX
#define INT_LEAST32_MAX __INT_LEAST32_MAX__
#undef INT_LEAST32_MIN
#define INT_LEAST32_MIN (-INT_LEAST32_MAX - 1)
#undef UINT_LEAST32_MAX
#define UINT_LEAST32_MAX __UINT_LEAST32_MAX__
#undef INT_LEAST64_MAX
#define INT_LEAST64_MAX __INT_LEAST64_MAX__
#undef INT_LEAST64_MIN
#define INT_LEAST64_MIN (-INT_LEAST64_MAX - 1)
#undef UINT_LEAST64_MAX
#define UINT_LEAST64_MAX __UINT_LEAST64_MAX__

#undef INT_FAST8_MAX
#define INT_FAST8_MAX __INT_FAST8_MAX__
#undef INT_FAST8_MIN
#define INT_FAST8_MIN (-INT_FAST8_MAX - 1)
#undef UINT_FAST8_MAX
#define UINT_FAST8_MAX __UINT_FAST8_MAX__
#undef INT_FAST16_MAX
#define INT_FAST16_MAX __INT_FAST16_MAX__
#undef INT_FAST16_MIN
#define INT_FAST16_MIN (-INT_FAST16_MAX - 1)
#undef UINT_FAST16_MAX
#define UINT_FAST16_MAX __UINT_FAST16_MAX__
#undef INT_FAST32_MAX
#define INT_FAST32_MAX __INT_FAST32_MAX__
#undef INT_FAST32_MIN
#define INT_FAST32_MIN (-INT_FAST32_MAX - 1)
#undef UINT_FAST32_MAX
#define UINT_FAST32_MAX __UINT_FAST32_MAX__
#undef INT_FAST64_MAX
#define INT_FAST64_MAX __INT_FAST64_MAX__
#undef INT_FAST64_MIN
#define INT_FAST64_MIN (-INT_FAST64_MAX - 1)
#undef UINT_FAST64_MAX
#define UINT_FAST64_MAX __UINT_FAST64_MAX__


#undef INTPTR_MAX
#define INTPTR_MAX __INTPTR_MAX__
#undef INTPTR_MIN
#define INTPTR_MIN (-INTPTR_MAX - 1)


#undef UINTPTR_MAX
#define UINTPTR_MAX __UINTPTR_MAX__


#undef INTMAX_MAX
#define INTMAX_MAX __INTMAX_MAX__
#undef INTMAX_MIN
#define INTMAX_MIN (-INTMAX_MAX - 1)
#undef UINTMAX_MAX
#define UINTMAX_MAX __UINTMAX_MAX__



#undef PTRDIFF_MAX
#define PTRDIFF_MAX __PTRDIFF_MAX__
#undef PTRDIFF_MIN
#define PTRDIFF_MIN (-PTRDIFF_MAX - 1)

#undef SIG_ATOMIC_MAX
#define SIG_ATOMIC_MAX __SIG_ATOMIC_MAX__
#undef SIG_ATOMIC_MIN
#define SIG_ATOMIC_MIN __SIG_ATOMIC_MIN__

#undef SIZE_MAX
#define SIZE_MAX __SIZE_MAX__

#undef WCHAR_MAX
#define WCHAR_MAX __WCHAR_MAX__
#undef WCHAR_MIN
#define WCHAR_MIN __WCHAR_MIN__

#undef WINT_MAX
#define WINT_MAX __WINT_MAX__
#undef WINT_MIN
#define WINT_MIN __WINT_MIN__







#undef INT8_C
#define INT8_C(c) __INT8_C(c)
#undef INT16_C
#define INT16_C(c) __INT16_C(c)
#undef INT32_C
#define INT32_C(c) __INT32_C(c)
#undef INT64_C
#define INT64_C(c) __INT64_C(c)
#undef UINT8_C
#define UINT8_C(c) __UINT8_C(c)
#undef UINT16_C
#define UINT16_C(c) __UINT16_C(c)
#undef UINT32_C
#define UINT32_C(c) __UINT32_C(c)
#undef UINT64_C
#define UINT64_C(c) __UINT64_C(c)
#undef INTMAX_C
#define INTMAX_C(c) __INTMAX_C(c)
#undef UINTMAX_C
#define UINTMAX_C(c) __UINTMAX_C(c)
# 15 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stdint.h" 2 3 4

#define _GCC_WRAP_STDINT_H 
# 50 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h" 2



# 52 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
extern "C" {



# 1 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOSConfig.h" 1
# 72 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOSConfig.h"
#define FREERTOS_CONFIG_H 

# 1 "/home/shivani/bl602_iot_sdk/components/freertos/include/platform.h" 1



#define _SIFIVE_PLATFORM_H 


#define MCAUSE_INT 0x80000000
#define MCAUSE_CAUSE 0x7FFFFFFF





#define _AC(X,Y) (X ##Y)
#define _AT(T,X) ((T)(X))


#define _BITUL(x) (_AC(1,UL) << (x))
#define _BITULL(x) (_AC(1,ULL) << (x))






#define MASKROM_MEM_ADDR _AC(0x00001000,UL)
#define TRAPVEC_TABLE_CTRL_ADDR _AC(0x00001010,UL)
#define OTP_MEM_ADDR _AC(0x00020000,UL)
#define CLINT_CTRL_ADDR _AC(0x02000000,UL)
#define PLIC_CTRL_ADDR _AC(0x0C000000,UL)
#define AON_CTRL_ADDR _AC(0x10000000,UL)
#define PRCI_CTRL_ADDR _AC(0x10008000,UL)
#define OTP_CTRL_ADDR _AC(0x10010000,UL)
#define GPIO_CTRL_ADDR _AC(0x10012000,UL)
#define UART0_CTRL_ADDR _AC(0x10013000,UL)
#define SPI0_CTRL_ADDR _AC(0x10014000,UL)
#define PWM0_CTRL_ADDR _AC(0x10015000,UL)
#define UART1_CTRL_ADDR _AC(0x10023000,UL)
#define SPI1_CTRL_ADDR _AC(0x10024000,UL)
#define PWM1_CTRL_ADDR _AC(0x10025000,UL)
#define SPI2_CTRL_ADDR _AC(0x10034000,UL)
#define PWM2_CTRL_ADDR _AC(0x10035000,UL)
#define SPI0_MEM_ADDR _AC(0x20000000,UL)
#define MEM_CTRL_ADDR _AC(0x80000000,UL)


#define IOF0_SPI1_MASK _AC(0x000007FC,UL)
#define SPI11_NUM_SS (4)
#define IOF_SPI1_SS0 (2u)
#define IOF_SPI1_SS1 (8u)
#define IOF_SPI1_SS2 (9u)
#define IOF_SPI1_SS3 (10u)
#define IOF_SPI1_MOSI (3u)
#define IOF_SPI1_MISO (4u)
#define IOF_SPI1_SCK (5u)
#define IOF_SPI1_DQ0 (3u)
#define IOF_SPI1_DQ1 (4u)
#define IOF_SPI1_DQ2 (6u)
#define IOF_SPI1_DQ3 (7u)

#define IOF0_SPI2_MASK _AC(0xFC000000,UL)
#define SPI2_NUM_SS (1)
#define IOF_SPI2_SS0 (26u)
#define IOF_SPI2_MOSI (27u)
#define IOF_SPI2_MISO (28u)
#define IOF_SPI2_SCK (29u)
#define IOF_SPI2_DQ0 (27u)
#define IOF_SPI2_DQ1 (28u)
#define IOF_SPI2_DQ2 (30u)
#define IOF_SPI2_DQ3 (31u)



#define IOF0_UART0_MASK _AC(0x00030000, UL)
#define IOF_UART0_RX (16u)
#define IOF_UART0_TX (17u)

#define IOF0_UART1_MASK _AC(0x03000000, UL)
#define IOF_UART1_RX (24u)
#define IOF_UART1_TX (25u)

#define IOF1_PWM0_MASK _AC(0x0000000F, UL)
#define IOF1_PWM1_MASK _AC(0x00780000, UL)
#define IOF1_PWM2_MASK _AC(0x00003C00, UL)


#define INT_RESERVED 0
#define INT_WDOGCMP 1
#define INT_RTCCMP 2
#define INT_UART0_BASE 3
#define INT_UART1_BASE 4
#define INT_SPI0_BASE 5
#define INT_SPI1_BASE 6
#define INT_SPI2_BASE 7
#define INT_GPIO_BASE 8
#define INT_PWM0_BASE 40
#define INT_PWM1_BASE 44
#define INT_PWM2_BASE 48


#define _REG32(p,i) (*(volatile uint32_t *) ((p) + (i)))
#define _REG32P(p,i) ((volatile uint32_t *) ((p) + (i)))
#define AON_REG(offset) _REG32(AON_CTRL_ADDR, offset)
#define CLINT_REG(offset) _REG32(CLINT_CTRL_ADDR, offset)
#define GPIO_REG(offset) _REG32(GPIO_CTRL_ADDR, offset)
#define OTP_REG(offset) _REG32(OTP_CTRL_ADDR, offset)
#define PLIC_REG(offset) _REG32(PLIC_CTRL_ADDR, offset)
#define PRCI_REG(offset) _REG32(PRCI_CTRL_ADDR, offset)
#define PWM0_REG(offset) _REG32(PWM0_CTRL_ADDR, offset)
#define PWM1_REG(offset) _REG32(PWM1_CTRL_ADDR, offset)
#define PWM2_REG(offset) _REG32(PWM2_CTRL_ADDR, offset)
#define SPI0_REG(offset) _REG32(SPI0_CTRL_ADDR, offset)
#define SPI1_REG(offset) _REG32(SPI1_CTRL_ADDR, offset)
#define SPI2_REG(offset) _REG32(SPI2_CTRL_ADDR, offset)
#define UART0_REG(offset) _REG32(UART0_CTRL_ADDR, offset)
#define UART1_REG(offset) _REG32(UART1_CTRL_ADDR, offset)





#define NUM_GPIO 32

#define PLIC_NUM_INTERRUPTS 52
#define PLIC_NUM_PRIORITIES 7

unsigned long get_cpu_freq(void);
unsigned long get_timer_freq(void);
uint64_t get_timer_value(void);
# 75 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOSConfig.h" 2
# 88 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOSConfig.h"
#define configSUPPORT_STATIC_ALLOCATION 1

#define configMTIME_BASE_ADDRESS ( ( CLINT_CTRL_ADDR ) + 0xBFF8UL )
#define configMTIMECMP_BASE_ADDRESS ( ( CLINT_CTRL_ADDR ) + 0x4000UL )
#define configCLIC_TIMER_ENABLE_ADDRESS (0x02800407)
#define configUSE_PREEMPTION 1
#define configUSE_IDLE_HOOK 1
#define configUSE_TICK_HOOK 0




#define configCPU_CLOCK_HZ ( 10 * 1000 * 1000 )
#define configTICK_RATE_HZ ( ( TickType_t ) 1000 )
#define configMAX_PRIORITIES ( 32 )
#define configMINIMAL_STACK_SIZE ( ( unsigned short ) 96 )
#define configTOTAL_HEAP_SIZE ( ( size_t ) 14100 )
#define configMAX_TASK_NAME_LEN ( 16 )
#define configUSE_TRACE_FACILITY 1
#define configUSE_STATS_FORMATTING_FUNCTIONS 1
#define configUSE_16_BIT_TICKS 0
#define configIDLE_SHOULD_YIELD 1
#define configUSE_MUTEXES 1
#define configQUEUE_REGISTRY_SIZE 8
#define configCHECK_FOR_STACK_OVERFLOW 2
#define configUSE_RECURSIVE_MUTEXES 1
#define configUSE_MALLOC_FAILED_HOOK 1
#define configUSE_APPLICATION_TASK_TAG 0
#define configUSE_COUNTING_SEMAPHORES 1
#define configGENERATE_RUN_TIME_STATS 0
#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1
#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 1


#define configUSE_CO_ROUTINES 0
#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )


#define configUSE_TIMERS 1
#define configTIMER_TASK_PRIORITY ( configMAX_PRIORITIES - 1 )
#define configTIMER_QUEUE_LENGTH 4
#define configTIMER_TASK_STACK_DEPTH ( 400 )



#define uartPRIMARY_PRIORITY ( configMAX_PRIORITIES - 3 )




#define INCLUDE_vTaskPrioritySet 1
#define INCLUDE_uxTaskPriorityGet 1
#define INCLUDE_vTaskDelete 1
#define INCLUDE_vTaskCleanUpResources 1
#define INCLUDE_vTaskSuspend 1
#define INCLUDE_vTaskDelayUntil 1
#define INCLUDE_vTaskDelay 1
#define INCLUDE_eTaskGetState 1
#define INCLUDE_xTimerPendFunctionCall 1
#define INCLUDE_uxTaskGetStackHighWaterMark 1



void vAssertCalled( void );
#define configASSERT(x) if( ( x ) == 0 ) vAssertCalled()



#define bktBLOCK_TIME_TASK_STACK_SIZE 100
#define notifyNOTIFIED_TASK_STACK_SIZE 120
#define priSUSPENDED_RX_TASK_STACK_SIZE 90
#define tmrTIMER_TEST_TASK_STACK_SIZE 100
#define ebRENDESVOUS_TEST_TASK_STACK_SIZE 100
#define ebEVENT_GROUP_SET_BITS_TEST_TASK_STACK_SIZE 115
#define genqMUTEX_TEST_TASK_STACK_SIZE 90
#define genqGENERIC_QUEUE_TEST_TASK_STACK_SIZE 100
#define recmuRECURSIVE_MUTEX_TEST_TASK_STACK_SIZE 90
# 57 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h" 2


# 1 "/home/shivani/bl602_iot_sdk/components/freertos/include/projdefs.h" 1
# 29 "/home/shivani/bl602_iot_sdk/components/freertos/include/projdefs.h"
#define PROJDEFS_H 





typedef void (*TaskFunction_t)( void * );





#define pdMS_TO_TICKS(xTimeInMs) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )


#define pdFALSE ( ( BaseType_t ) 0 )
#define pdTRUE ( ( BaseType_t ) 1 )

#define pdPASS ( pdTRUE )
#define pdFAIL ( pdFALSE )
#define errQUEUE_EMPTY ( ( BaseType_t ) 0 )
#define errQUEUE_FULL ( ( BaseType_t ) 0 )


#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY ( -1 )
#define errQUEUE_BLOCKED ( -4 )
#define errQUEUE_YIELD ( -5 )



#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0





#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL




#define pdFREERTOS_ERRNO_NONE 0
#define pdFREERTOS_ERRNO_ENOENT 2
#define pdFREERTOS_ERRNO_EINTR 4
#define pdFREERTOS_ERRNO_EIO 5
#define pdFREERTOS_ERRNO_ENXIO 6
#define pdFREERTOS_ERRNO_EBADF 9
#define pdFREERTOS_ERRNO_EAGAIN 11
#define pdFREERTOS_ERRNO_EWOULDBLOCK 11
#define pdFREERTOS_ERRNO_ENOMEM 12
#define pdFREERTOS_ERRNO_EACCES 13
#define pdFREERTOS_ERRNO_EFAULT 14
#define pdFREERTOS_ERRNO_EBUSY 16
#define pdFREERTOS_ERRNO_EEXIST 17
#define pdFREERTOS_ERRNO_EXDEV 18
#define pdFREERTOS_ERRNO_ENODEV 19
#define pdFREERTOS_ERRNO_ENOTDIR 20
#define pdFREERTOS_ERRNO_EISDIR 21
#define pdFREERTOS_ERRNO_EINVAL 22
#define pdFREERTOS_ERRNO_ENOSPC 28
#define pdFREERTOS_ERRNO_ESPIPE 29
#define pdFREERTOS_ERRNO_EROFS 30
#define pdFREERTOS_ERRNO_EUNATCH 42
#define pdFREERTOS_ERRNO_EBADE 50
#define pdFREERTOS_ERRNO_EFTYPE 79
#define pdFREERTOS_ERRNO_ENMFILE 89
#define pdFREERTOS_ERRNO_ENOTEMPTY 90
#define pdFREERTOS_ERRNO_ENAMETOOLONG 91
#define pdFREERTOS_ERRNO_EOPNOTSUPP 95
#define pdFREERTOS_ERRNO_ENOBUFS 105
#define pdFREERTOS_ERRNO_ENOPROTOOPT 109
#define pdFREERTOS_ERRNO_EADDRINUSE 112
#define pdFREERTOS_ERRNO_ETIMEDOUT 116
#define pdFREERTOS_ERRNO_EINPROGRESS 119
#define pdFREERTOS_ERRNO_EALREADY 120
#define pdFREERTOS_ERRNO_EADDRNOTAVAIL 125
#define pdFREERTOS_ERRNO_EISCONN 127
#define pdFREERTOS_ERRNO_ENOTCONN 128
#define pdFREERTOS_ERRNO_ENOMEDIUM 135
#define pdFREERTOS_ERRNO_EILSEQ 138
#define pdFREERTOS_ERRNO_ECANCELED 140



#define pdFREERTOS_LITTLE_ENDIAN 0
#define pdFREERTOS_BIG_ENDIAN 1


#define pdLITTLE_ENDIAN pdFREERTOS_LITTLE_ENDIAN
#define pdBIG_ENDIAN pdFREERTOS_BIG_ENDIAN
# 60 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h" 2


# 1 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h" 1
# 33 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h"
#define PORTABLE_H 
# 45 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h"
# 1 "/home/shivani/bl602_iot_sdk/components/freertos/include/deprecated_definitions.h" 1
# 29 "/home/shivani/bl602_iot_sdk/components/freertos/include/deprecated_definitions.h"
#define DEPRECATED_DEFINITIONS_H 
# 46 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h" 2






# 1 "/home/shivani/bl602_iot_sdk/components/freertos/portable/GCC/RISC-V/portmacro.h" 1
# 30 "/home/shivani/bl602_iot_sdk/components/freertos/portable/GCC/RISC-V/portmacro.h"
#define PORTMACRO_H 


extern "C" {
# 53 "/home/shivani/bl602_iot_sdk/components/freertos/portable/GCC/RISC-V/portmacro.h"
#define portSTACK_TYPE uint32_t
#define portBASE_TYPE int32_t
#define portUBASE_TYPE uint32_t
#define portMAX_DELAY ( TickType_t ) 0xffffffffUL





typedef uint32_t StackType_t;
typedef int32_t BaseType_t;
typedef uint32_t UBaseType_t;
typedef uint32_t TickType_t;


#define portCHAR char
#define portFLOAT float
#define portDOUBLE double
#define portLONG long
#define portSHORT short



#define portTICK_TYPE_IS_ATOMIC 1



#define portSTACK_GROWTH ( -1 )
#define portTICK_PERIOD_MS ( ( TickType_t ) 1000 / configTICK_RATE_HZ )




#define portBYTE_ALIGNMENT 16





extern BaseType_t TrapNetCounter;
extern void vTaskSwitchContext( void );
#define portYIELD() __asm volatile( "ecall" );
#define portEND_SWITCHING_ISR(xSwitchRequired) if( xSwitchRequired ) vTaskSwitchContext()
#define portYIELD_FROM_ISR(x) portEND_SWITCHING_ISR( x )




#define portCRITICAL_NESTING_IN_TCB 1
extern void vTaskEnterCritical( void );
extern void vTaskExitCritical( void );

#define portSET_INTERRUPT_MASK_FROM_ISR() 0
#define portCLEAR_INTERRUPT_MASK_FROM_ISR(uxSavedStatusValue) ( void ) uxSavedStatusValue
#define portDISABLE_INTERRUPTS() __asm volatile( "csrc mstatus, 8" )
#define portENABLE_INTERRUPTS() __asm volatile( "csrs mstatus, 8" )
#define portENTER_CRITICAL() vTaskEnterCritical()
#define portEXIT_CRITICAL() vTaskExitCritical()
# 127 "/home/shivani/bl602_iot_sdk/components/freertos/portable/GCC/RISC-V/portmacro.h"
#define portRECORD_READY_PRIORITY(uxPriority,uxReadyPriorities) ( uxReadyPriorities ) |= ( 1UL << ( uxPriority ) )
#define portRESET_READY_PRIORITY(uxPriority,uxReadyPriorities) ( uxReadyPriorities ) &= ~( 1UL << ( uxPriority ) )



#define portGET_HIGHEST_PRIORITY(uxTopPriority,uxReadyPriorities) uxTopPriority = ( 31UL - __builtin_clz( uxReadyPriorities ) )
# 142 "/home/shivani/bl602_iot_sdk/components/freertos/portable/GCC/RISC-V/portmacro.h"
#define portTASK_FUNCTION_PROTO(vFunction,pvParameters) void vFunction( void *pvParameters )
#define portTASK_FUNCTION(vFunction,pvParameters) void vFunction( void *pvParameters )



#define portNOP() __asm volatile ( " nop " )

#define portINLINE __inline


#define portFORCE_INLINE inline __attribute__(( always_inline))


#define portMEMORY_BARRIER() __asm volatile( "" ::: "memory" )
# 179 "/home/shivani/bl602_iot_sdk/components/freertos/portable/GCC/RISC-V/portmacro.h"
inline __attribute__(( always_inline)) static BaseType_t xPortIsInsideInterrupt( void )
{
    return TrapNetCounter ? 1 : 0;
}


}
# 53 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h" 2







#define portBYTE_ALIGNMENT_MASK ( 0x000f )
# 84 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h"
#define portNUM_CONFIGURABLE_REGIONS 1



#define portHAS_STACK_OVERFLOW_CHECKING 0



#define portARCH_NAME NULL



extern "C" {


# 1 "/home/shivani/bl602_iot_sdk/components/freertos/include/mpu_wrappers.h" 1
# 29 "/home/shivani/bl602_iot_sdk/components/freertos/include/mpu_wrappers.h"
#define MPU_WRAPPERS_H 
# 175 "/home/shivani/bl602_iot_sdk/components/freertos/include/mpu_wrappers.h"
#define PRIVILEGED_FUNCTION 
#define PRIVILEGED_DATA 
#define FREERTOS_SYSTEM_CALL 
#define portUSING_MPU_WRAPPERS 0
# 100 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h" 2
# 117 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h"
  StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;





typedef struct HeapRegion
{
 uint8_t *pucStartAddress;
 size_t xSizeInBytes;
} HeapRegion_t;


typedef struct xHeapStats
{
 size_t xAvailableHeapSpaceInBytes;
 size_t xSizeOfLargestFreeBlockInBytes;
 size_t xSizeOfSmallestFreeBlockInBytes;
 size_t xNumberOfFreeBlocks;
 size_t xMinimumEverFreeBytesRemaining;
 size_t xNumberOfSuccessfulAllocations;
 size_t xNumberOfSuccessfulFrees;
} HeapStats_t;
# 152 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h"
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;





void vPortGetHeapStats( HeapStats_t *pxHeapStats );




void *pvPortMalloc( size_t xSize ) ;
void vPortFree( void *pv ) ;
void *pvPortRealloc (void *ptr, size_t size ) ;
void vPortInitialiseBlocks( void ) ;
size_t xPortGetFreeHeapSize( void ) ;
size_t xPortGetMinimumEverFreeHeapSize( void ) ;





BaseType_t xPortStartScheduler( void ) ;






void vPortEndScheduler( void ) ;
# 196 "/home/shivani/bl602_iot_sdk/components/freertos/include/portable.h"
}
# 63 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h" 2



#define configUSE_NEWLIB_REENTRANT 0
# 136 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define INCLUDE_xTaskGetIdleTaskHandle 0



#define INCLUDE_xTaskAbortDelay 0



#define INCLUDE_xQueueGetMutexHolder 0



#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder



#define INCLUDE_xTaskGetHandle 0







#define INCLUDE_uxTaskGetStackHighWaterMark2 0







#define INCLUDE_xTaskResumeFromISR 1







#define INCLUDE_xTaskGetSchedulerState 0



#define INCLUDE_xTaskGetCurrentTaskHandle 0
# 190 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
# 218 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define configUSE_ALTERNATIVE_API 0
# 241 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define configASSERT_DEFINED 1
# 250 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define configPRECONDITION(X) configASSERT(X)
#define configPRECONDITION_DEFINED 0
# 261 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define portSOFTWARE_BARRIER() 
# 290 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define portCLEAN_UP_TCB(pxTCB) ( void ) pxTCB



#define portPRE_TASK_DELETE_HOOK(pvTaskToDelete,pxYieldPending) 



#define portSETUP_TCB(pxTCB) ( void ) pxTCB
# 312 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define portPOINTER_SIZE_TYPE uint32_t






#define traceSTART() 





#define traceEND() 





#define traceTASK_SWITCHED_IN() 





#define traceINCREASE_TICK_COUNT(x) 




#define traceLOW_POWER_IDLE_BEGIN() 




#define traceLOW_POWER_IDLE_END() 





#define traceTASK_SWITCHED_OUT() 
# 362 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define traceTASK_PRIORITY_INHERIT(pxTCBOfMutexHolder,uxInheritedPriority) 







#define traceTASK_PRIORITY_DISINHERIT(pxTCBOfMutexHolder,uxOriginalPriority) 







#define traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue) 







#define traceBLOCKING_ON_QUEUE_PEEK(pxQueue) 







#define traceBLOCKING_ON_QUEUE_SEND(pxQueue) 







#define configRECORD_STACK_HIGH_ADDRESS 0



#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0





#define traceMOVED_TASK_TO_READY_STATE(pxTCB) 



#define tracePOST_MOVED_TASK_TO_READY_STATE(pxTCB) 



#define traceQUEUE_CREATE(pxNewQueue) 



#define traceQUEUE_CREATE_FAILED(ucQueueType) 



#define traceCREATE_MUTEX(pxNewQueue) 



#define traceCREATE_MUTEX_FAILED() 



#define traceGIVE_MUTEX_RECURSIVE(pxMutex) 



#define traceGIVE_MUTEX_RECURSIVE_FAILED(pxMutex) 



#define traceTAKE_MUTEX_RECURSIVE(pxMutex) 



#define traceTAKE_MUTEX_RECURSIVE_FAILED(pxMutex) 



#define traceCREATE_COUNTING_SEMAPHORE() 



#define traceCREATE_COUNTING_SEMAPHORE_FAILED() 



#define traceQUEUE_SEND(pxQueue) 



#define traceQUEUE_SEND_FAILED(pxQueue) 



#define traceQUEUE_RECEIVE(pxQueue) 



#define traceQUEUE_PEEK(pxQueue) 



#define traceQUEUE_PEEK_FAILED(pxQueue) 



#define traceQUEUE_PEEK_FROM_ISR(pxQueue) 



#define traceQUEUE_RECEIVE_FAILED(pxQueue) 



#define traceQUEUE_SEND_FROM_ISR(pxQueue) 



#define traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue) 



#define traceQUEUE_RECEIVE_FROM_ISR(pxQueue) 



#define traceQUEUE_RECEIVE_FROM_ISR_FAILED(pxQueue) 



#define traceQUEUE_PEEK_FROM_ISR_FAILED(pxQueue) 



#define traceQUEUE_DELETE(pxQueue) 



#define traceTASK_CREATE(pxNewTCB) 



#define traceTASK_CREATE_FAILED() 



#define traceTASK_DELETE(pxTaskToDelete) 



#define traceTASK_DELAY_UNTIL(x) 



#define traceTASK_DELAY() 



#define traceTASK_PRIORITY_SET(pxTask,uxNewPriority) 



#define traceTASK_SUSPEND(pxTaskToSuspend) 



#define traceTASK_RESUME(pxTaskToResume) 



#define traceTASK_RESUME_FROM_ISR(pxTaskToResume) 



#define traceTASK_INCREMENT_TICK(xTickCount) 



#define traceTIMER_CREATE(pxNewTimer) 



#define traceTIMER_CREATE_FAILED() 



#define traceTIMER_COMMAND_SEND(xTimer,xMessageID,xMessageValueValue,xReturn) 



#define traceTIMER_EXPIRED(pxTimer) 



#define traceTIMER_COMMAND_RECEIVED(pxTimer,xMessageID,xMessageValue) 



#define traceMALLOC(pvAddress,uiSize) 



#define traceFREE(pvAddress,uiSize) 



#define traceEVENT_GROUP_CREATE(xEventGroup) 



#define traceEVENT_GROUP_CREATE_FAILED() 



#define traceEVENT_GROUP_SYNC_BLOCK(xEventGroup,uxBitsToSet,uxBitsToWaitFor) 



#define traceEVENT_GROUP_SYNC_END(xEventGroup,uxBitsToSet,uxBitsToWaitFor,xTimeoutOccurred) ( void ) xTimeoutOccurred



#define traceEVENT_GROUP_WAIT_BITS_BLOCK(xEventGroup,uxBitsToWaitFor) 



#define traceEVENT_GROUP_WAIT_BITS_END(xEventGroup,uxBitsToWaitFor,xTimeoutOccurred) ( void ) xTimeoutOccurred



#define traceEVENT_GROUP_CLEAR_BITS(xEventGroup,uxBitsToClear) 



#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR(xEventGroup,uxBitsToClear) 



#define traceEVENT_GROUP_SET_BITS(xEventGroup,uxBitsToSet) 



#define traceEVENT_GROUP_SET_BITS_FROM_ISR(xEventGroup,uxBitsToSet) 



#define traceEVENT_GROUP_DELETE(xEventGroup) 



#define tracePEND_FUNC_CALL(xFunctionToPend,pvParameter1,ulParameter2,ret) 



#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend,pvParameter1,ulParameter2,ret) 



#define traceQUEUE_REGISTRY_ADD(xQueue,pcQueueName) 



#define traceTASK_NOTIFY_TAKE_BLOCK() 



#define traceTASK_NOTIFY_TAKE() 



#define traceTASK_NOTIFY_WAIT_BLOCK() 



#define traceTASK_NOTIFY_WAIT() 



#define traceTASK_NOTIFY() 



#define traceTASK_NOTIFY_FROM_ISR() 



#define traceTASK_NOTIFY_GIVE_FROM_ISR() 



#define traceSTREAM_BUFFER_CREATE_FAILED(xIsMessageBuffer) 



#define traceSTREAM_BUFFER_CREATE_STATIC_FAILED(xReturn,xIsMessageBuffer) 



#define traceSTREAM_BUFFER_CREATE(pxStreamBuffer,xIsMessageBuffer) 



#define traceSTREAM_BUFFER_DELETE(xStreamBuffer) 



#define traceSTREAM_BUFFER_RESET(xStreamBuffer) 



#define traceBLOCKING_ON_STREAM_BUFFER_SEND(xStreamBuffer) 



#define traceSTREAM_BUFFER_SEND(xStreamBuffer,xBytesSent) 



#define traceSTREAM_BUFFER_SEND_FAILED(xStreamBuffer) 



#define traceSTREAM_BUFFER_SEND_FROM_ISR(xStreamBuffer,xBytesSent) 



#define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE(xStreamBuffer) 



#define traceSTREAM_BUFFER_RECEIVE(xStreamBuffer,xReceivedLength) 



#define traceSTREAM_BUFFER_RECEIVE_FAILED(xStreamBuffer) 



#define traceSTREAM_BUFFER_RECEIVE_FROM_ISR(xStreamBuffer,xReceivedLength) 
# 734 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() 







#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )



#define portYIELD_WITHIN_API portYIELD



#define portSUPPRESS_TICKS_AND_SLEEP(xExpectedIdleTime) 



#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
# 766 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING(x) 



#define configPRE_SLEEP_PROCESSING(x) 



#define configPOST_SLEEP_PROCESSING(x) 



#define configUSE_QUEUE_SETS 0



#define portTASK_USES_FLOATING_POINT() 



#define portALLOCATE_SECURE_CONTEXT(ulSecureStackSize) 



#define portDONT_DISCARD 



#define configUSE_TIME_SLICING 1



#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0







#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID() 







#define mtCOVERAGE_TEST_MARKER() 



#define mtCOVERAGE_TEST_DELAY() 



#define portASSERT_IF_IN_ISR() 







#define configAPPLICATION_ALLOCATED_HEAP 0



#define configUSE_TASK_NOTIFICATIONS 1



#define configUSE_POSIX_ERRNO 0
# 852 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define configSUPPORT_DYNAMIC_ALLOCATION 1





#define configSTACK_DEPTH_TYPE uint16_t






#define configMESSAGE_BUFFER_LENGTH_TYPE size_t
# 884 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define configINITIAL_TICK_COUNT 0
# 898 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define portTICK_TYPE_ENTER_CRITICAL() 
#define portTICK_TYPE_EXIT_CRITICAL() 
#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR(x) ( void ) x





#define configENABLE_BACKWARD_COMPATIBILITY 1
# 921 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define configPRINTF(X) 





#define configMAX(a,b) ( ( ( a ) > ( b ) ) ? ( a ) : ( b ) )





#define configMIN(a,b) ( ( ( a ) < ( b ) ) ? ( a ) : ( b ) )



#define eTaskStateGet eTaskGetState
#define portTickType TickType_t
#define xTaskHandle TaskHandle_t
#define xQueueHandle QueueHandle_t
#define xSemaphoreHandle SemaphoreHandle_t
#define xQueueSetHandle QueueSetHandle_t
#define xQueueSetMemberHandle QueueSetMemberHandle_t
#define xTimeOutType TimeOut_t
#define xMemoryRegion MemoryRegion_t
#define xTaskParameters TaskParameters_t
#define xTaskStatusType TaskStatus_t
#define xTimerHandle TimerHandle_t
#define xCoRoutineHandle CoRoutineHandle_t
#define pdTASK_HOOK_CODE TaskHookFunction_t
#define portTICK_RATE_MS portTICK_PERIOD_MS
#define pcTaskGetTaskName pcTaskGetName
#define pcTimerGetTimerName pcTimerGetName
#define pcQueueGetQueueName pcQueueGetName
#define vTaskGetTaskInfo vTaskGetInfo
#define xTaskGetIdleRunTimeCounter ulTaskGetIdleRunTimeCounter



#define tmrTIMER_CALLBACK TimerCallbackFunction_t
#define pdTASK_CODE TaskFunction_t
#define xListItem ListItem_t
#define xList List_t



#define pxContainer pvContainer
# 979 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define configUSE_TASK_FPU_SUPPORT 1





#define configENABLE_MPU 0





#define configENABLE_FPU 1





#define configENABLE_TRUSTZONE 1





#define configRUN_FREERTOS_SECURE_ONLY 0
# 1048 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
#define tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ( ( ( portUSING_MPU_WRAPPERS == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) || ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) )
# 1061 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
struct xSTATIC_LIST_ITEM
{



 TickType_t xDummy2;
 void *pvDummy3[ 4 ];



};
typedef struct xSTATIC_LIST_ITEM StaticListItem_t;


struct xSTATIC_MINI_LIST_ITEM
{



 TickType_t xDummy2;
 void *pvDummy3[ 2 ];
};
typedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;


typedef struct xSTATIC_LIST
{



 UBaseType_t uxDummy2;
 void *pvDummy3;
 StaticMiniListItem_t xDummy4;



} StaticList_t;
# 1112 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
typedef struct xSTATIC_TCB
{
 void *pxDummy1;



 StaticListItem_t xDummy3[ 2 ];
 UBaseType_t uxDummy5;
 void *pxDummy6;
 uint8_t ucDummy7[ ( 16 ) ];




  UBaseType_t uxDummy9;


  UBaseType_t uxDummy10[ 2 ];


  UBaseType_t uxDummy12[ 2 ];





  void *pvDummy15[ 1 ];
# 1147 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
  uint32_t ulDummy18;
  uint8_t ucDummy19;


  uint8_t uxDummy20;
# 1160 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
} StaticTask_t;
# 1176 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
typedef struct xSTATIC_QUEUE
{
 void *pvDummy1[ 3 ];

 union
 {
  void *pvDummy2;
  UBaseType_t uxDummy2;
 } u;

 StaticList_t xDummy3[ 2 ];
 UBaseType_t uxDummy4[ 3 ];
 uint8_t ucDummy5[ 2 ];


  uint8_t ucDummy6;







  UBaseType_t uxDummy8;
  uint8_t ucDummy9;


} StaticQueue_t;
typedef StaticQueue_t StaticSemaphore_t;
# 1220 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
typedef struct xSTATIC_EVENT_GROUP
{
 TickType_t xDummy1;
 StaticList_t xDummy2;


  UBaseType_t uxDummy3;



   uint8_t ucDummy4;


} StaticEventGroup_t;
# 1249 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
typedef struct xSTATIC_TIMER
{
 void *pvDummy1;
 StaticListItem_t xDummy2;
 TickType_t xDummy3;
 void *pvDummy5;
 TaskFunction_t pvDummy6;

  UBaseType_t uxDummy7;

 uint8_t ucDummy8;

} StaticTimer_t;
# 1277 "/home/shivani/bl602_iot_sdk/components/freertos/include/FreeRTOS.h"
typedef struct xSTATIC_STREAM_BUFFER
{
 size_t uxDummy1[ 4 ];
 void * pvDummy2[ 3 ];
 uint8_t ucDummy3;

  UBaseType_t uxDummy4;

} StaticStreamBuffer_t;


typedef StaticStreamBuffer_t StaticMessageBuffer_t;

void vInitializeBL602(void);


}
# 4 "/home/shivani/bl602_iot_sdk/customer_app/suas_app_freertos_watchdog/suas_app_freertos_tasks/main.cpp" 2
# 1 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h" 1
# 30 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
#define INC_TASK_H 





# 1 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h" 1
# 61 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define LIST_H 
# 92 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define configLIST_VOLATILE 



extern "C" {
# 106 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE 
#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE 
#define listFIRST_LIST_INTEGRITY_CHECK_VALUE 
#define listSECOND_LIST_INTEGRITY_CHECK_VALUE 
#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem) 
#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem) 
#define listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList) 
#define listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList) 
#define listTEST_LIST_ITEM_INTEGRITY(pxItem) 
#define listTEST_LIST_INTEGRITY(pxList) 
# 139 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
struct xLIST;
struct xLIST_ITEM
{

 TickType_t xItemValue;
 struct xLIST_ITEM * pxNext;
 struct xLIST_ITEM * pxPrevious;
 void * pvOwner;
 struct xLIST * pvContainer;

};
typedef struct xLIST_ITEM ListItem_t;

struct xMINI_LIST_ITEM
{

 TickType_t xItemValue;
 struct xLIST_ITEM * pxNext;
 struct xLIST_ITEM * pxPrevious;
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;




typedef struct xLIST
{

 volatile UBaseType_t uxNumberOfItems;
 ListItem_t * pxIndex;
 MiniListItem_t xListEnd;

} List_t;
# 180 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listSET_LIST_ITEM_OWNER(pxListItem,pxOwner) ( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
# 189 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listGET_LIST_ITEM_OWNER(pxListItem) ( ( pxListItem )->pvOwner )
# 198 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listSET_LIST_ITEM_VALUE(pxListItem,xValue) ( ( pxListItem )->xItemValue = ( xValue ) )
# 208 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listGET_LIST_ITEM_VALUE(pxListItem) ( ( pxListItem )->xItemValue )
# 217 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxList) ( ( ( pxList )->xListEnd ).pxNext->xItemValue )







#define listGET_HEAD_ENTRY(pxList) ( ( ( pxList )->xListEnd ).pxNext )







#define listGET_NEXT(pxListItem) ( ( pxListItem )->pxNext )







#define listGET_END_MARKER(pxList) ( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
# 250 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listLIST_IS_EMPTY(pxList) ( ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) ? pdTRUE : pdFALSE )




#define listCURRENT_LIST_LENGTH(pxList) ( ( pxList )->uxNumberOfItems )
# 277 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listGET_OWNER_OF_NEXT_ENTRY(pxTCB,pxList) { List_t * const pxConstList = ( pxList ); ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext; if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) ) { ( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext; } ( pxTCB ) = ( pxConstList )->pxIndex->pvOwner; }
# 307 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listGET_OWNER_OF_HEAD_ENTRY(pxList) ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
# 318 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
#define listIS_CONTAINED_WITHIN(pxList,pxListItem) ( ( ( pxListItem )->pxContainer == ( pxList ) ) ? ( pdTRUE ) : ( pdFALSE ) )







#define listLIST_ITEM_CONTAINER(pxListItem) ( ( pxListItem )->pxContainer )






#define listLIST_IS_INITIALISED(pxList) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
# 345 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
void vListInitialise( List_t * const pxList ) ;
# 356 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
void vListInitialiseItem( ListItem_t * const pxItem ) ;
# 369 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
# 390 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
# 405 "/home/shivani/bl602_iot_sdk/components/freertos/include/list.h"
UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;


}
# 37 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h" 2


extern "C" {






#define tskKERNEL_VERSION_NUMBER "V10.3.0"
#define tskKERNEL_VERSION_MAJOR 10
#define tskKERNEL_VERSION_MINOR 3
#define tskKERNEL_VERSION_BUILD 0



#define tskMPU_REGION_READ_ONLY ( 1UL << 0UL )
#define tskMPU_REGION_READ_WRITE ( 1UL << 1UL )
#define tskMPU_REGION_EXECUTE_NEVER ( 1UL << 2UL )
#define tskMPU_REGION_NORMAL_MEMORY ( 1UL << 3UL )
#define tskMPU_REGION_DEVICE_MEMORY ( 1UL << 4UL )
# 69 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
struct tskTaskControlBlock;
typedef struct tskTaskControlBlock* TaskHandle_t;





typedef BaseType_t (*TaskHookFunction_t)( void * );


typedef enum
{
 eRunning = 0,
 eReady,
 eBlocked,
 eSuspended,
 eDeleted,
 eInvalid
} eTaskState;


typedef enum
{
 eNoAction = 0,
 eSetBits,
 eIncrement,
 eSetValueWithOverwrite,
 eSetValueWithoutOverwrite
} eNotifyAction;




typedef struct xTIME_OUT
{
 BaseType_t xOverflowCount;
 TickType_t xTimeOnEntering;
} TimeOut_t;




typedef struct xMEMORY_REGION
{
 void *pvBaseAddress;
 uint32_t ulLengthInBytes;
 uint32_t ulParameters;
} MemoryRegion_t;




typedef struct xTASK_PARAMETERS
{
 TaskFunction_t pvTaskCode;
 const char * const pcName;
 uint16_t usStackDepth;
 void *pvParameters;
 UBaseType_t uxPriority;
 StackType_t *puxStackBuffer;
 MemoryRegion_t xRegions[ 1 ];



} TaskParameters_t;



typedef struct xTASK_STATUS
{
 TaskHandle_t xHandle;
 const char *pcTaskName;
 UBaseType_t xTaskNumber;
 eTaskState eCurrentState;
 UBaseType_t uxCurrentPriority;
 UBaseType_t uxBasePriority;
 uint32_t ulRunTimeCounter;
 StackType_t *pxStackBase;
 uint16_t usStackHighWaterMark;
} TaskStatus_t;


typedef enum
{
 eAbortSleep = 0,
 eStandardSleep,
 eNoTasksWaitingTimeout
} eSleepModeStatus;






#define tskIDLE_PRIORITY ( ( UBaseType_t ) 0U )
# 173 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
#define taskYIELD() portYIELD()
# 187 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
#define taskENTER_CRITICAL() portENTER_CRITICAL()
#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
# 202 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
#define taskEXIT_CRITICAL() portEXIT_CRITICAL()
#define taskEXIT_CRITICAL_FROM_ISR(x) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
# 212 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
#define taskDISABLE_INTERRUPTS() portDISABLE_INTERRUPTS()
# 222 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
#define taskENABLE_INTERRUPTS() portENABLE_INTERRUPTS()




#define taskSCHEDULER_SUSPENDED ( ( BaseType_t ) 0 )
#define taskSCHEDULER_NOT_STARTED ( ( BaseType_t ) 1 )
#define taskSCHEDULER_RUNNING ( ( BaseType_t ) 2 )
# 330 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
 BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
       const char * const pcName,
       const uint16_t usStackDepth,
       void * const pvParameters,
       UBaseType_t uxPriority,
       TaskHandle_t * const pxCreatedTask ) ;
# 446 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
 TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
         const char * const pcName,
         const uint32_t ulStackDepth,
         void * const pvParameters,
         UBaseType_t uxPriority,
         StackType_t * const puxStackBuffer,
         StaticTask_t * const pxTaskBuffer ) ;
# 665 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
# 706 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskDelete( TaskHandle_t xTaskToDelete ) ;
# 758 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskDelay( const TickType_t xTicksToDelay ) ;
# 817 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
# 847 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;
# 894 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask ) ;







UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask ) ;
# 920 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
eTaskState eTaskGetState( TaskHandle_t xTask ) ;
# 976 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) ;
# 1018 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
# 1069 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
# 1118 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskResume( TaskHandle_t xTaskToResume ) ;
# 1147 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
# 1180 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskStartScheduler( void ) ;
# 1236 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskEndScheduler( void ) ;
# 1287 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskSuspendAll( void ) ;
# 1341 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskResumeAll( void ) ;
# 1356 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
TickType_t xTaskGetTickCount( void ) ;
BaseType_t xTaskGetTickCount2( TickType_t *ticks, BaseType_t *overflow ) ;
# 1373 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
TickType_t xTaskGetTickCountFromISR( void ) ;
# 1387 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
UBaseType_t uxTaskGetNumberOfTasks( void ) ;
# 1400 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
char *pcTaskGetName( TaskHandle_t xTaskToQuery ) ;
# 1416 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
TaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) ;
# 1443 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
# 1470 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
uint16_t uxTaskGetStackHighWaterMark2( TaskHandle_t xTask ) ;
# 1518 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
 void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) ;
 void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) ;
# 1534 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
# 1543 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
TaskHandle_t xTaskGetIdleTaskHandle( void ) ;
# 1642 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
# 1689 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskList( char * pcWriteBuffer ) ;
# 1743 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskGetRunTimeStats( char *pcWriteBuffer ) ;
# 1773 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
uint32_t ulTaskGetIdleRunTimeCounter( void ) ;
# 1854 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
#define xTaskNotify(xTaskToNotify,ulValue,eAction) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
#define xTaskNotifyAndQuery(xTaskToNotify,ulValue,eAction,pulPreviousNotifyValue) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
# 1945 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
#define xTaskNotifyFromISR(xTaskToNotify,ulValue,eAction,pxHigherPriorityTaskWoken) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
#define xTaskNotifyAndQueryFromISR(xTaskToNotify,ulValue,eAction,pulPreviousNotificationValue,pxHigherPriorityTaskWoken) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
# 2022 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
# 2068 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
#define xTaskNotifyGive(xTaskToNotify) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
# 2123 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
# 2192 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
# 2208 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
# 2226 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear ) ;
# 2240 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
# 2323 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
# 2344 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskIncrementTick( void ) ;
# 2377 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
# 2391 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
# 2417 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
# 2428 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
 void vTaskSwitchContext( void ) ;





TickType_t uxTaskResetEventItemValue( void ) ;




TaskHandle_t xTaskGetCurrentTaskHandle( void ) ;





void vTaskMissedYield( void ) ;





BaseType_t xTaskGetSchedulerState( void ) ;





BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;





BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
# 2473 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) ;




UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;





void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
# 2494 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
void vTaskStepTick( const TickType_t xTicksToJump ) ;
void vTaskStepTickSafe( const TickType_t xTicksToJump ) ;
# 2508 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp ) ;
# 2524 "/home/shivani/bl602_iot_sdk/components/freertos/include/task.h"
eSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;





TaskHandle_t pvTaskIncrementMutexHeldCount( void ) ;





void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) ;



}
# 5 "/home/shivani/bl602_iot_sdk/customer_app/suas_app_freertos_watchdog/suas_app_freertos_tasks/main.cpp" 2


# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 1 3
# 27 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
#define _STDIO_H_ 

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/_ansi.h" 1 3







#define _ANSIDECL_H_ 

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/newlib.h" 1 3






#define __NEWLIB_H__ 1


# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/_newlib_version.h" 1 3



#define _NEWLIB_VERSION_H__ 1

#define _NEWLIB_VERSION "4.4.0"
#define __NEWLIB__ 4
#define __NEWLIB_MINOR__ 4
#define __NEWLIB_PATCHLEVEL__ 0
# 11 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/newlib.h" 2 3
# 33 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/newlib.h" 3
#define _FSEEK_OPTIMIZATION 1


#define _FVWRITE_IN_STREAMIO 1


#define _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL 1



#define _HAVE_INITFINI_ARRAY 1


#define _HAVE_LONG_DOUBLE 1
# 364 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/newlib.h" 3
#define _MB_LEN_MAX 1
# 375 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/newlib.h" 3
#define _REENT_CHECK_VERIFY 1





#define _UNBUF_STREAM_OPT 1



#define _WANT_IO_C99_FORMATS 1



#define _WANT_IO_LONG_DOUBLE 1



#define _WANT_IO_LONG_LONG 1
# 410 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/newlib.h" 3
#define _WANT_REGISTER_FINI 1


#define _WANT_USE_GDTOA 1





#define _WIDE_ORIENT 1
# 11 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/_ansi.h" 2 3
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/config.h" 1 3

#define __SYS_CONFIG_H__ 

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/ieeefp.h" 1 3
# 219 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/ieeefp.h" 3
#define __IEEE_LITTLE_ENDIAN 


#define _SUPPORTS_ERREXCEPT 




#define __OBSOLETE_MATH_DEFAULT 1
# 522 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/ieeefp.h" 3
#define __OBSOLETE_MATH __OBSOLETE_MATH_DEFAULT
# 5 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/config.h" 2 3
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/features.h" 1 3
# 22 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/features.h" 3
#define _SYS_FEATURES_H 



# 25 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/features.h" 3
extern "C" {







#define __GNUC_PREREQ(maj,min) ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))






#define __GNUC_PREREQ__(ma,mi) __GNUC_PREREQ(ma, mi)
# 259 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/features.h" 3
#define __ATFILE_VISIBLE 0





#define __BSD_VISIBLE 0





#define __GNU_VISIBLE 0




#define __ISO_C_VISIBLE 2020
# 290 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/features.h" 3
#define __LARGEFILE_VISIBLE 0





#define __MISC_VISIBLE 0
# 312 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/features.h" 3
#define __POSIX_VISIBLE 0





#define __SVID_VISIBLE 0
# 332 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/features.h" 3
#define __XSI_VISIBLE 0
# 344 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/features.h" 3
#define __SSP_FORTIFY_LEVEL 0
# 549 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/features.h" 3
}
# 6 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/config.h" 2 3
# 83 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/config.h" 3
#define _READ_WRITE_RETURN_TYPE _ssize_t
# 224 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/config.h" 3
#define _POINTER_INT long





#undef __RAND_MAX



#define __RAND_MAX 0x7fffffff
# 248 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/config.h" 3
#define __EXPORT 



#define __IMPORT 
# 265 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/config.h" 3
#define _READ_WRITE_BUFSIZE_TYPE int
# 290 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/config.h" 3
#define _USE_GDTOA 
# 12 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/_ansi.h" 2 3
# 21 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/_ansi.h" 3
#define _BEGIN_STD_C extern "C" {
#define _END_STD_C }


#define _NOTHROW __attribute__ ((__nothrow__))
# 37 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/_ansi.h" 3
#define _LONG_DOUBLE long double





#define _ATTRIBUTE(attrs) __attribute__ (attrs)
# 69 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/_ansi.h" 3
#define _ELIDABLE_INLINE static __inline__



#define _NOINLINE __attribute__ ((__noinline__))
#define _NOINLINE_STATIC _NOINLINE static
# 30 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 2 3

#define _FSTDIO 

#define __need_size_t 
#define __need_NULL 
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 1 3
# 43 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define _SYS_CDEFS_H_ 

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 1 3





#define _MACHINE__DEFAULT_TYPES_H 
# 15 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 3
#define __EXP(x) __ ##x ##__
# 26 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 3
#define __have_longlong64 1






#define __have_long32 1



extern "C" {



typedef signed char __int8_t;

typedef unsigned char __uint8_t;



#define ___int8_t_defined 1







typedef short int __int16_t;

typedef short unsigned int __uint16_t;



#define ___int16_t_defined 1
# 77 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 3
typedef long int __int32_t;

typedef long unsigned int __uint32_t;



#define ___int32_t_defined 1
# 103 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 3
typedef long long int __int64_t;

typedef long long unsigned int __uint64_t;



#define ___int64_t_defined 1
# 134 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 3
typedef signed char __int_least8_t;

typedef unsigned char __uint_least8_t;



#define ___int_least8_t_defined 1
# 160 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 3
typedef short int __int_least16_t;

typedef short unsigned int __uint_least16_t;



#define ___int_least16_t_defined 1
# 182 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 3
typedef long int __int_least32_t;

typedef long unsigned int __uint_least32_t;



#define ___int_least32_t_defined 1
# 200 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 3
typedef long long int __int_least64_t;

typedef long long unsigned int __uint_least64_t;



#define ___int_least64_t_defined 1







typedef long long int __intmax_t;







typedef long long unsigned int __uintmax_t;







typedef int __intptr_t;

typedef unsigned int __uintptr_t;
# 244 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_default_types.h" 3
#undef __EXP


}
# 46 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 2 3

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 173 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 252 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_size_t
# 364 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_wchar_t
# 414 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef NULL

#define NULL __null
# 425 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_NULL




#undef offsetof
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 48 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 2 3

#define __PMT(args) args
#define __DOTS , ...
#define __THROW 


#define __ASMNAME(cname) __XSTRING (__USER_LABEL_PREFIX__) cname


#define __ptr_t void *
#define __long_double_t long double

#define __attribute_malloc__ 
#define __attribute_pure__ 
#define __attribute_format_strfmon__(a,b) 
#define __flexarr [0]


#define __bounded 
#define __unbounded 
#define __ptrvalue 
# 91 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __BEGIN_DECLS extern "C" {
#define __END_DECLS }
# 107 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __GNUCLIKE_ASM 3
#define __GNUCLIKE_MATH_BUILTIN_CONSTANTS 



#define __GNUCLIKE___TYPEOF 1
#define __GNUCLIKE___SECTION 1

#define __GNUCLIKE_CTOR_SECTION_HANDLING 1

#define __GNUCLIKE_BUILTIN_CONSTANT_P 1


#define __GNUCLIKE_BUILTIN_VARARGS 1
#define __GNUCLIKE_BUILTIN_STDARG 1
#define __GNUCLIKE_BUILTIN_VAALIST 1


#define __GNUC_VA_LIST_COMPATIBILITY 1




#define __compiler_membar() __asm __volatile(" " : : : "memory")

#define __GNUCLIKE_BUILTIN_NEXT_ARG 1
#define __GNUCLIKE_MATH_BUILTIN_RELOPS 

#define __GNUCLIKE_BUILTIN_MEMCPY 1


#define __CC_SUPPORTS_INLINE 1
#define __CC_SUPPORTS___INLINE 1
#define __CC_SUPPORTS___INLINE__ 1

#define __CC_SUPPORTS___FUNC__ 1
#define __CC_SUPPORTS_WARNING 1

#define __CC_SUPPORTS_VARADIC_XXX 1

#define __CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1
# 164 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __P(protos) protos
#define __CONCAT1(x,y) x ## y
#define __CONCAT(x,y) __CONCAT1(x,y)
#define __STRING(x) #x
#define __XSTRING(x) __STRING(x)

#define __const const
#define __signed signed
#define __volatile volatile

#define __inline inline
# 217 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __weak_symbol __attribute__((__weak__))
# 230 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __dead2 __attribute__((__noreturn__))
#define __pure2 __attribute__((__const__))
#define __unused __attribute__((__unused__))
#define __used __attribute__((__used__))
#define __packed __attribute__((__packed__))
#define __aligned(x) __attribute__((__aligned__(x)))
#define __section(x) __attribute__((__section__(x)))


#define __alloc_size(x) __attribute__((__alloc_size__(x)))
#define __alloc_size2(n,x) __attribute__((__alloc_size__(n, x)))





#define __alloc_align(x) __attribute__((__alloc_align__(x)))
# 264 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define _Alignas(x) alignas(x)







#define _Alignof(x) alignof(x)
# 287 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define _Noreturn [[noreturn]]







#define _Static_assert(x,y) static_assert(x, y)
# 316 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define _Thread_local thread_local
# 358 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __min_size(x) (x)



#define __malloc_like __attribute__((__malloc__))
#define __pure __attribute__((__pure__))






#define __always_inline __inline__ __attribute__((__always_inline__))





#define __noinline __attribute__ ((__noinline__))





#define __nonnull(x) __attribute__((__nonnull__ x))
#define __nonnull_all __attribute__((__nonnull__))






#define __fastcall __attribute__((__fastcall__))
#define __result_use_check __attribute__((__warn_unused_result__))






#define __returns_twice __attribute__((__returns_twice__))





#define __unreachable() __builtin_unreachable()
# 432 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __restrict_arr 
# 468 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __predict_true(exp) __builtin_expect((exp), 1)
#define __predict_false(exp) __builtin_expect((exp), 0)






#define __null_sentinel __attribute__((__sentinel__))
#define __exported __attribute__((__visibility__("default")))


#define __hidden __attribute__((__visibility__("hidden")))
# 490 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __offsetof(type,field) offsetof(type, field)
#define __rangeof(type,start,end) (__offsetof(type, end) - __offsetof(type, start))
# 501 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __containerof(x,s,m) ({ const volatile __typeof(((s *)0)->m) *__x = (x); __DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));})
# 523 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __printflike(fmtarg,firstvararg) __attribute__((__format__ (__printf__, fmtarg, firstvararg)))

#define __scanflike(fmtarg,firstvararg) __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))

#define __format_arg(fmtarg) __attribute__((__format_arg__ (fmtarg)))
#define __strfmonlike(fmtarg,firstvararg) __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))

#define __strftimelike(fmtarg,firstvararg) __attribute__((__format__ (__strftime__, fmtarg, firstvararg)))
# 540 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __printf0like(fmtarg,firstvararg) 



#define __strong_reference(sym,aliassym) extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))



#define __weak_reference(sym,alias) __asm__(".weak " #alias); __asm__(".equ " #alias ", " #sym)


#define __warn_references(sym,msg) __asm__(".section .gnu.warning." #sym); __asm__(".asciz \"" msg "\""); __asm__(".previous")



#define __sym_compat(sym,impl,verid) __asm__(".symver " #impl ", " #sym "@" #verid)

#define __sym_default(sym,impl,verid) __asm__(".symver " #impl ", " #sym "@@" #verid)
# 592 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __FBSDID(s) struct __hack



#define __RCSID(s) struct __hack



#define __RCSID_SOURCE(s) struct __hack



#define __SCCSID(s) struct __hack



#define __COPYRIGHT(s) struct __hack



#define __DECONST(type,var) ((type)(__uintptr_t)(const void *)(var))



#define __DEVOLATILE(type,var) ((type)(__uintptr_t)(volatile void *)(var))



#define __DEQUALIFY(type,var) ((type)(__uintptr_t)(const volatile void *)(var))






#define _Nonnull 
#define _Nullable 
#define _Null_unspecified 
#define __NULLABILITY_PRAGMA_PUSH 
#define __NULLABILITY_PRAGMA_POP 
# 652 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __arg_type_tag(arg_kind,arg_idx,type_tag_idx) 
#define __datatype_type_tag(kind,type) 
# 671 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __lock_annotate(x) 





#define __lockable __lock_annotate(lockable)


#define __locks_exclusive(...) __lock_annotate(exclusive_lock_function(__VA_ARGS__))

#define __locks_shared(...) __lock_annotate(shared_lock_function(__VA_ARGS__))



#define __trylocks_exclusive(...) __lock_annotate(exclusive_trylock_function(__VA_ARGS__))

#define __trylocks_shared(...) __lock_annotate(shared_trylock_function(__VA_ARGS__))



#define __unlocks(...) __lock_annotate(unlock_function(__VA_ARGS__))


#define __asserts_exclusive(...) __lock_annotate(assert_exclusive_lock(__VA_ARGS__))

#define __asserts_shared(...) __lock_annotate(assert_shared_lock(__VA_ARGS__))



#define __requires_exclusive(...) __lock_annotate(exclusive_locks_required(__VA_ARGS__))

#define __requires_shared(...) __lock_annotate(shared_locks_required(__VA_ARGS__))

#define __requires_unlocked(...) __lock_annotate(locks_excluded(__VA_ARGS__))



#define __no_lock_analysis __lock_annotate(no_thread_safety_analysis)
# 726 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/cdefs.h" 3
#define __nosanitizeaddress 
#define __nosanitizememory 
#define __nosanitizethread 



#define __guarded_by(x) __lock_annotate(guarded_by(x))
#define __pt_guarded_by(x) __lock_annotate(pt_guarded_by(x))




#define __builtin_is_aligned(x,align) (((__uintptr_t)x & ((align) - 1)) == 0)



#define __builtin_align_up(x,align) ((__typeof__(x))(((__uintptr_t)(x)+((align)-1))&(~((align)-1))))



#define __builtin_align_down(x,align) ((__typeof__(x))((x)&(~((align)-1))))



#define __align_up(x,y) __builtin_align_up(x, y)
#define __align_down(x,y) __builtin_align_down(x, y)
#define __is_aligned(x,y) __builtin_is_aligned(x, y)
# 36 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 2 3
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 37 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 2 3


#define __need___va_list 
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stdarg.h" 1 3 4
# 34 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stdarg.h" 3 4
#undef __need___va_list




#define __GNUC_VA_LIST 
typedef __builtin_va_list __gnuc_va_list;
# 41 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 2 3
# 60 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 1 3
# 9 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
extern "C" {

#define _SYS_REENT_H_ 

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/_ansi.h" 1 3
# 14 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 2 3
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 15 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 2 3

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/_types.h" 1 3
# 20 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/_types.h" 3
#define _SYS__TYPES_H 

#define __need_size_t 
#define __need_wint_t 
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 173 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 252 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_size_t
# 364 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_wchar_t




#define _WINT_T 




typedef unsigned int wint_t;

#undef __need_wint_t
# 414 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef NULL

#define NULL __null
# 425 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_NULL




#undef offsetof
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 25 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/_types.h" 2 3


# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/_types.h" 1 3





#define _MACHINE__TYPES_H 
# 28 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/_types.h" 2 3


typedef long __blkcnt_t;



typedef long __blksize_t;



typedef __uint64_t __fsblkcnt_t;



typedef __uint32_t __fsfilcnt_t;



typedef long _off_t;





typedef int __pid_t;



typedef short __dev_t;



typedef unsigned short __uid_t;


typedef unsigned short __gid_t;



typedef __uint32_t __id_t;







typedef unsigned short __ino_t;
# 90 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/_types.h" 3
typedef __uint32_t __mode_t;





__extension__ typedef long long _off64_t;





typedef _off_t __off_t;


typedef _off64_t __loff_t;


typedef long __key_t;







typedef long _fpos_t;
# 127 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/_types.h" 3
#undef __size_t



typedef unsigned int __size_t;
# 146 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/_types.h" 3
#define unsigned signed
typedef signed int _ssize_t;
#undef unsigned
# 158 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/_types.h" 3
typedef _ssize_t __ssize_t;



typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    unsigned char __wchb[4];
  } __value;
} _mbstate_t;




typedef void *_iconv_t;



#define _CLOCK_T_ unsigned long


typedef unsigned long __clock_t;




#define _TIME_T_ __int_least64_t

typedef __int_least64_t __time_t;


#define _CLOCKID_T_ unsigned long


typedef unsigned long __clockid_t;


typedef long __daddr_t;


#define _TIMER_T_ unsigned long
typedef unsigned long __timer_t;


typedef __uint8_t __sa_family_t;



typedef __uint32_t __socklen_t;


typedef int __nl_item;
typedef unsigned short __nlink_t;
typedef long __suseconds_t;
typedef unsigned long __useconds_t;







typedef __builtin_va_list __va_list;
# 17 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 2 3

#define _NULL 0



#define __Long long
typedef unsigned long __ULong;
# 35 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/lock.h" 1 3

#define __SYS_LOCK_H__ 
# 11 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/lock.h" 3
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;

#define __LOCK_INIT(class,lock) static int lock = 0;
#define __LOCK_INIT_RECURSIVE(class,lock) static int lock = 0;
#define __lock_init(lock) ((void) 0)
#define __lock_init_recursive(lock) ((void) 0)
#define __lock_close(lock) ((void) 0)
#define __lock_close_recursive(lock) ((void) 0)
#define __lock_acquire(lock) ((void) 0)
#define __lock_acquire_recursive(lock) ((void) 0)
#define __lock_try_acquire(lock) ((void) 0)
#define __lock_try_acquire_recursive(lock) ((void) 0)
#define __lock_release(lock) ((void) 0)
#define __lock_release_recursive(lock) ((void) 0)
# 36 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 2 3
typedef _LOCK_RECURSIVE_T _flock_t;







struct _reent;

struct __locale_t;






struct _Bigint
{
  struct _Bigint *_next;
  int _k, _maxwds, _sign, _wds;
  __ULong _x[1];
};


struct __tm
{
  int __tm_sec;
  int __tm_min;
  int __tm_hour;
  int __tm_mday;
  int __tm_mon;
  int __tm_year;
  int __tm_wday;
  int __tm_yday;
  int __tm_isdst;
};





#define _ATEXIT_SIZE 32

struct _on_exit_args {
 void * _fnargs[32];
 void * _dso_handle[32];

 __ULong _fntypes;


 __ULong _is_cxa;
};
# 99 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
struct _atexit {
 struct _atexit *_next;
 int _ind;

 void (*_fns[32])(void);
        struct _on_exit_args _on_exit_args;
};
#define _ATEXIT_INIT {_NULL, 0, {_NULL}, {{_NULL}, {_NULL}, 0, 0}}
# 116 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 146 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
#define _REENT_SMALL_CHECK_INIT(ptr) 






struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;






  void * _cookie;

  _ssize_t (*_read) (struct _reent *, void *,
        char *, int);
  _ssize_t (*_write) (struct _reent *, void *,
         const char *,
         int);
  _fpos_t (*_seek) (struct _reent *, void *, _fpos_t, int);
  int (*_close) (struct _reent *, void *);


  struct __sbuf _ub;
  unsigned char *_up;
  int _ur;


  unsigned char _ubuf[3];
  unsigned char _nbuf[1];


  struct __sbuf _lb;


  int _blksize;
  _off_t _offset;


  struct _reent *_data;



  _flock_t _lock;

  _mbstate_t _mbstate;
  int _flags2;
};
# 270 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
typedef struct __sFILE __FILE;



extern __FILE __sf[3];

struct _glue
{
  struct _glue *_next;
  int _niobs;
  __FILE *_iobs;
};

extern struct _glue __sglue;
# 299 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
#define _RAND48_SEED_0 (0x330e)
#define _RAND48_SEED_1 (0xabcd)
#define _RAND48_SEED_2 (0x1234)
#define _RAND48_MULT_0 (0xe66d)
#define _RAND48_MULT_1 (0xdeec)
#define _RAND48_MULT_2 (0x0005)
#define _RAND48_ADD (0x000b)
struct _rand48 {
  unsigned short _seed[3];
  unsigned short _mult[3];
  unsigned short _add;




};


#define _REENT_EMERGENCY_SIZE 25
#define _REENT_ASCTIME_SIZE 26
#define _REENT_SIGNAL_SIZE 24
# 330 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
#define _REENT_INIT_RESERVED_0 
#define _REENT_INIT_RESERVED_1 
#define _REENT_INIT_RESERVED_2 
#define _REENT_INIT_RESERVED_6_7 
#define _REENT_INIT_RESERVED_8 
# 568 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
struct _reent
{
  int _errno;




  __FILE *_stdin, *_stdout, *_stderr;

  int _inc;
  char _emergency[25];




  struct __locale_t *_locale;





  void (*__cleanup) (struct _reent *);


  struct _Bigint *_result;
  int _result_k;
  struct _Bigint *_p5s;
  struct _Bigint **_freelist;


  int _cvtlen;
  char *_cvtbuf;

  union
    {
      struct
        {



          char * _strtok_last;
          char _asctime_buf[26];
          struct __tm _localtime_buf;
          int _gamma_signgam;
          __extension__ unsigned long long _rand_next;
          struct _rand48 _r48;
          _mbstate_t _mblen_state;
          _mbstate_t _mbtowc_state;
          _mbstate_t _wctomb_state;
          char _l64a_buf[8];
          char _signal_buf[24];
          int _getdate_err;
          _mbstate_t _mbrlen_state;
          _mbstate_t _mbrtowc_state;
          _mbstate_t _mbsrtowcs_state;
          _mbstate_t _wcrtomb_state;
          _mbstate_t _wcsrtombs_state;
   int _h_errno;
# 634 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
        } _reent;







    } _new;







  void (**_sig_func)(int);
};

#define _REENT_INIT(var) { 0, &__sf[0], &__sf[1], &__sf[2], 0, "", _REENT_INIT_RESERVED_1 _NULL, _REENT_INIT_RESERVED_0 _NULL, _NULL, 0, _NULL, _NULL, 0, _NULL, { { _REENT_INIT_RESERVED_2 _NULL, "", {0, 0, 0, 0, 0, 0, 0, 0, 0}, 0, 1, { {_RAND48_SEED_0, _RAND48_SEED_1, _RAND48_SEED_2}, {_RAND48_MULT_0, _RAND48_MULT_1, _RAND48_MULT_2}, _RAND48_ADD }, {0, {0}}, {0, {0}}, {0, {0}}, "", "", 0, {0, {0}}, {0, {0}}, {0, {0}}, {0, {0}}, {0, {0}} } }, _REENT_INIT_RESERVED_6_7 _NULL }
# 700 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
#define _REENT_INIT_PTR_ZEROED(var) { (var)->_stdin = &__sf[0]; (var)->_stdout = &__sf[1]; (var)->_stderr = &__sf[2]; (var)->_new._reent._rand_next = 1; (var)->_new._reent._r48._seed[0] = _RAND48_SEED_0; (var)->_new._reent._r48._seed[1] = _RAND48_SEED_1; (var)->_new._reent._r48._seed[2] = _RAND48_SEED_2; (var)->_new._reent._r48._mult[0] = _RAND48_MULT_0; (var)->_new._reent._r48._mult[1] = _RAND48_MULT_1; (var)->_new._reent._r48._mult[2] = _RAND48_MULT_2; (var)->_new._reent._r48._add = _RAND48_ADD; }
# 714 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
#define _REENT_CHECK_RAND48(ptr) 
#define _REENT_CHECK_MP(ptr) 
#define _REENT_CHECK_TM(ptr) 
#define _REENT_CHECK_ASCTIME_BUF(ptr) 
#define _REENT_CHECK_EMERGENCY(ptr) 
#define _REENT_CHECK_MISC(ptr) 
#define _REENT_CHECK_SIGNAL_BUF(ptr) 

#define _REENT_SIGNGAM(ptr) ((ptr)->_new._reent._gamma_signgam)
#define _REENT_RAND_NEXT(ptr) ((ptr)->_new._reent._rand_next)
#define _REENT_RAND48_SEED(ptr) ((ptr)->_new._reent._r48._seed)
#define _REENT_RAND48_MULT(ptr) ((ptr)->_new._reent._r48._mult)
#define _REENT_RAND48_ADD(ptr) ((ptr)->_new._reent._r48._add)
#define _REENT_MP_RESULT(ptr) ((ptr)->_result)
#define _REENT_MP_RESULT_K(ptr) ((ptr)->_result_k)
#define _REENT_MP_P5S(ptr) ((ptr)->_p5s)
#define _REENT_MP_FREELIST(ptr) ((ptr)->_freelist)
#define _REENT_ASCTIME_BUF(ptr) ((ptr)->_new._reent._asctime_buf)
#define _REENT_TM(ptr) (&(ptr)->_new._reent._localtime_buf)
#define _REENT_STRTOK_LAST(ptr) ((ptr)->_new._reent._strtok_last)
#define _REENT_MBLEN_STATE(ptr) ((ptr)->_new._reent._mblen_state)
#define _REENT_MBTOWC_STATE(ptr) ((ptr)->_new._reent._mbtowc_state)
#define _REENT_WCTOMB_STATE(ptr) ((ptr)->_new._reent._wctomb_state)
#define _REENT_MBRLEN_STATE(ptr) ((ptr)->_new._reent._mbrlen_state)
#define _REENT_MBRTOWC_STATE(ptr) ((ptr)->_new._reent._mbrtowc_state)
#define _REENT_MBSRTOWCS_STATE(ptr) ((ptr)->_new._reent._mbsrtowcs_state)
#define _REENT_WCRTOMB_STATE(ptr) ((ptr)->_new._reent._wcrtomb_state)
#define _REENT_WCSRTOMBS_STATE(ptr) ((ptr)->_new._reent._wcsrtombs_state)
# 750 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
#define _REENT_L64A_BUF(ptr) ((ptr)->_new._reent._l64a_buf)
#define _REENT_SIGNAL_BUF(ptr) ((ptr)->_new._reent._signal_buf)
#define _REENT_GETDATE_ERR_P(ptr) (&((ptr)->_new._reent._getdate_err))



#define _REENT_CLEANUP(_ptr) ((_ptr)->__cleanup)
#define _REENT_CVTBUF(_ptr) ((_ptr)->_cvtbuf)
#define _REENT_CVTLEN(_ptr) ((_ptr)->_cvtlen)
#define _REENT_EMERGENCY(_ptr) ((_ptr)->_emergency)
#define _REENT_ERRNO(_ptr) ((_ptr)->_errno)
#define _REENT_INC(_ptr) ((_ptr)->_inc)
#define _REENT_LOCALE(_ptr) ((_ptr)->_locale)
#define _REENT_SIG_FUNC(_ptr) ((_ptr)->_sig_func)
#define _REENT_STDIN(_ptr) ((_ptr)->_stdin)
#define _REENT_STDOUT(_ptr) ((_ptr)->_stdout)
#define _REENT_STDERR(_ptr) ((_ptr)->_stderr)

#define _REENT_INIT_PTR(var) { memset((var), 0, sizeof(*(var))); _REENT_INIT_PTR_ZEROED(var); }
# 779 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
#define __ATTRIBUTE_IMPURE_PTR__ 


extern struct _reent *_impure_ptr ;


#define __ATTRIBUTE_IMPURE_DATA__ 


extern struct _reent _impure_data ;
# 798 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
#define _REENT _impure_ptr


#define _REENT_IS_NULL(_ptr) ((_ptr) == NULL)

#define _GLOBAL_REENT (&_impure_data)
# 898 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/reent.h" 3
#define _Kmax (sizeof (size_t) << 3)

extern struct _atexit *__atexit;
extern struct _atexit __atexit0;

extern void (*__stdio_exit_handler) (void);

void _reclaim_reent (struct _reent *);

extern int _fwalk_sglue (struct _reent *, int (*)(struct _reent *, __FILE *),
    struct _glue *);


}
# 61 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 2 3


extern "C" {


typedef __FILE FILE;
#define __FILE_defined 


typedef _fpos_t fpos_t;





typedef __off_t off_t;
#define _OFF_T_DECLARED 



typedef _ssize_t ssize_t;
#define _SSIZE_T_DECLARED 


# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/stdio.h" 1 3

#define _NEWLIB_STDIO_H 
# 13 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/stdio.h" 3
#define _flockfile(fp) (((fp)->_flags & __SSTR) ? 0 : __lock_acquire_recursive((fp)->_lock))







#define _funlockfile(fp) (((fp)->_flags & __SSTR) ? 0 : __lock_release_recursive((fp)->_lock))
# 86 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 2 3

#define __SLBF 0x0001
#define __SNBF 0x0002
#define __SRD 0x0004
#define __SWR 0x0008

#define __SRW 0x0010
#define __SEOF 0x0020
#define __SERR 0x0040
#define __SMBF 0x0080
#define __SAPP 0x0100
#define __SSTR 0x0200
#define __SOPT 0x0400
#define __SNPT 0x0800
#define __SOFF 0x1000
#define __SORD 0x2000



#define __SL64 0x8000


#define __SNLK 0x0001
#define __SWID 0x2000
# 120 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
#define _IOFBF 0
#define _IOLBF 1
#define _IONBF 2

#define EOF (-1)




#define BUFSIZ 1024





#define FOPEN_MAX 20





#define FILENAME_MAX 1024





#define L_tmpnam FILENAME_MAX







#define SEEK_SET 0


#define SEEK_CUR 1


#define SEEK_END 2


#define TMP_MAX 26

#define stdin _REENT_STDIN(_REENT)
#define stdout _REENT_STDOUT(_REENT)
#define stderr _REENT_STDERR(_REENT)

#define _stdin_r(x) _REENT_STDIN(x)
#define _stdout_r(x) _REENT_STDOUT(x)
#define _stderr_r(x) _REENT_STDERR(x)







#define __VALIST __gnuc_va_list
# 192 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
FILE * tmpfile (void);
char * tmpnam (char *);



int fclose (FILE *);
int fflush (FILE *);
FILE * freopen (const char *__restrict, const char *__restrict, FILE *__restrict);
void setbuf (FILE *__restrict, char *__restrict);
int setvbuf (FILE *__restrict, char *__restrict, int, size_t);
int fprintf (FILE *__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int fscanf (FILE *__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int printf (const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 1, 2)));
int scanf (const char *__restrict, ...)
               __attribute__ ((__format__ (__scanf__, 1, 2)));
int sscanf (const char *__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int vfprintf (FILE *__restrict, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int vprintf (const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 1, 0)));
int vsprintf (char *__restrict, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int fgetc (FILE *);
char * fgets (char *__restrict, int, FILE *__restrict);
int fputc (int, FILE *);
int fputs (const char *__restrict, FILE *__restrict);
int getc (FILE *);
int getchar (void);
char * gets (char *);
int putc (int, FILE *);
int putchar (int);
int puts (const char *);
int ungetc (int, FILE *);
size_t fread (void *__restrict, size_t _size, size_t _n, FILE *__restrict);
size_t fwrite (const void *__restrict , size_t _size, size_t _n, FILE *);



int fgetpos (FILE *__restrict, fpos_t *__restrict);

int fseek (FILE *, long, int);



int fsetpos (FILE *, const fpos_t *);

long ftell ( FILE *);
void rewind (FILE *);
void clearerr (FILE *);
int feof (FILE *);
int ferror (FILE *);
void perror (const char *);

FILE * fopen (const char *__restrict _name, const char *__restrict _type);
int sprintf (char *__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int remove (const char *);
int rename (const char *, const char *);
# 272 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
int snprintf (char *__restrict, size_t, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int vsnprintf (char *__restrict, size_t, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int vfscanf (FILE *__restrict, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int vscanf (const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 1, 0)));
int vsscanf (const char *__restrict, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
# 402 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
int _asiprintf_r (struct _reent *, char **, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
char * _asniprintf_r (struct _reent *, char *, size_t *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
char * _asnprintf_r (struct _reent *, char *__restrict, size_t *__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
int _asprintf_r (struct _reent *, char **__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _diprintf_r (struct _reent *, int, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _dprintf_r (struct _reent *, int, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _fclose_r (struct _reent *, FILE *);
int _fcloseall_r (struct _reent *);
FILE * _fdopen_r (struct _reent *, int, const char *);
int _fflush_r (struct _reent *, FILE *);
int _fgetc_r (struct _reent *, FILE *);
int _fgetc_unlocked_r (struct _reent *, FILE *);
char * _fgets_r (struct _reent *, char *__restrict, int, FILE *__restrict);
char * _fgets_unlocked_r (struct _reent *, char *__restrict, int, FILE *__restrict);




int _fgetpos_r (struct _reent *, FILE *, fpos_t *);
int _fsetpos_r (struct _reent *, FILE *, const fpos_t *);

int _fiprintf_r (struct _reent *, FILE *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _fiscanf_r (struct _reent *, FILE *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
FILE * _fmemopen_r (struct _reent *, void *__restrict, size_t, const char *__restrict);
FILE * _fopen_r (struct _reent *, const char *__restrict, const char *__restrict);
FILE * _freopen_r (struct _reent *, const char *__restrict, const char *__restrict, FILE *__restrict);
int _fprintf_r (struct _reent *, FILE *__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _fpurge_r (struct _reent *, FILE *);
int _fputc_r (struct _reent *, int, FILE *);
int _fputc_unlocked_r (struct _reent *, int, FILE *);
int _fputs_r (struct _reent *, const char *__restrict, FILE *__restrict);
int _fputs_unlocked_r (struct _reent *, const char *__restrict, FILE *__restrict);
size_t _fread_r (struct _reent *, void *__restrict, size_t _size, size_t _n, FILE *__restrict);
size_t _fread_unlocked_r (struct _reent *, void *__restrict, size_t _size, size_t _n, FILE *__restrict);
int _fscanf_r (struct _reent *, FILE *__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
int _fseek_r (struct _reent *, FILE *, long, int);
int _fseeko_r (struct _reent *, FILE *, _off_t, int);
long _ftell_r (struct _reent *, FILE *);
_off_t _ftello_r (struct _reent *, FILE *);
void _rewind_r (struct _reent *, FILE *);
size_t _fwrite_r (struct _reent *, const void *__restrict, size_t _size, size_t _n, FILE *__restrict);
size_t _fwrite_unlocked_r (struct _reent *, const void *__restrict, size_t _size, size_t _n, FILE *__restrict);
int _getc_r (struct _reent *, FILE *);
int _getc_unlocked_r (struct _reent *, FILE *);
int _getchar_r (struct _reent *);
int _getchar_unlocked_r (struct _reent *);
char * _gets_r (struct _reent *, char *);
int _iprintf_r (struct _reent *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int _iscanf_r (struct _reent *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
FILE * _open_memstream_r (struct _reent *, char **, size_t *);
void _perror_r (struct _reent *, const char *);
int _printf_r (struct _reent *, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 2, 3)));
int _putc_r (struct _reent *, int, FILE *);
int _putc_unlocked_r (struct _reent *, int, FILE *);
int _putchar_unlocked_r (struct _reent *, int);
int _putchar_r (struct _reent *, int);
int _puts_r (struct _reent *, const char *);
int _remove_r (struct _reent *, const char *);
int _rename_r (struct _reent *,
      const char *_old, const char *_new);
int _scanf_r (struct _reent *, const char *__restrict, ...)
               __attribute__ ((__format__ (__scanf__, 2, 3)));
int _siprintf_r (struct _reent *, char *, const char *, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _siscanf_r (struct _reent *, const char *, const char *, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
int _sniprintf_r (struct _reent *, char *, size_t, const char *, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
int _snprintf_r (struct _reent *, char *__restrict, size_t, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 4, 5)));
int _sprintf_r (struct _reent *, char *__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__printf__, 3, 4)));
int _sscanf_r (struct _reent *, const char *__restrict, const char *__restrict, ...)
               __attribute__ ((__format__ (__scanf__, 3, 4)));
char * _tempnam_r (struct _reent *, const char *, const char *);
FILE * _tmpfile_r (struct _reent *);
char * _tmpnam_r (struct _reent *, char *);
int _ungetc_r (struct _reent *, int, FILE *);
int _vasiprintf_r (struct _reent *, char **, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
char * _vasniprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
char * _vasnprintf_r (struct _reent*, char *, size_t *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
int _vasprintf_r (struct _reent *, char **, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vdiprintf_r (struct _reent *, int, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vdprintf_r (struct _reent *, int, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vfiprintf_r (struct _reent *, FILE *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vfiscanf_r (struct _reent *, FILE *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));
int _vfprintf_r (struct _reent *, FILE *__restrict, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vfscanf_r (struct _reent *, FILE *__restrict, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));
int _viprintf_r (struct _reent *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int _viscanf_r (struct _reent *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int _vprintf_r (struct _reent *, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 2, 0)));
int _vscanf_r (struct _reent *, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 2, 0)));
int _vsiprintf_r (struct _reent *, char *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vsiscanf_r (struct _reent *, const char *, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));
int _vsniprintf_r (struct _reent *, char *, size_t, const char *, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
int _vsnprintf_r (struct _reent *, char *__restrict, size_t, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 4, 0)));
int _vsprintf_r (struct _reent *, char *__restrict, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__printf__, 3, 0)));
int _vsscanf_r (struct _reent *, const char *__restrict, const char *__restrict, __gnuc_va_list)
               __attribute__ ((__format__ (__scanf__, 3, 0)));



int fpurge (FILE *);
ssize_t __getdelim (char **, size_t *, int, FILE *);
ssize_t __getline (char **, size_t *, FILE *);
# 583 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
int __srget_r (struct _reent *, FILE *);
int __swbuf_r (struct _reent *, int, FILE *);
# 658 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
#define __sgetc_raw_r(__ptr,__f) (--(__f)->_r < 0 ? __srget_r(__ptr, __f) : (int)(*(__f)->_p++))
# 687 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
#define __sgetc_r(__ptr,__p) __sgetc_raw_r(__ptr, __p)



static __inline__ int __sputc_r(struct _reent *_ptr, int _c, FILE *_p) {




 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf_r(_ptr, _c, _p));
}
# 723 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
#define __sfeof(p) ((int)(((p)->_flags & __SEOF) != 0))
#define __sferror(p) ((int)(((p)->_flags & __SERR) != 0))
#define __sclearerr(p) ((void)((p)->_flags &= ~(__SERR|__SEOF)))
#define __sfileno(p) ((p)->_file)
# 801 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdio.h" 3
}
# 8 "/home/shivani/bl602_iot_sdk/customer_app/suas_app_freertos_watchdog/suas_app_freertos_tasks/main.cpp" 2

# 8 "/home/shivani/bl602_iot_sdk/customer_app/suas_app_freertos_watchdog/suas_app_freertos_tasks/main.cpp"
}

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string.h"
#define ETL_STRING_INCLUDED 

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_PLATFORM_INCLUDED 





#define __STDC_LIMIT_MACROS 






#define __STDC_CONSTANT_MACROS 


# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 49 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h" 2

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 1 3 4
# 30 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 3 4
#define _GCC_LIMITS_H_ 



# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/syslimits.h" 1 3 4





#define _GCC_NEXT_LIMITS_H 
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 1 3 4
# 210 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 3 4
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/limits.h" 1 3 4

#define _LIBC_LIMITS_H_ 1



# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/syslimits.h" 1 3 4
# 34 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/syslimits.h" 3 4
#define _SYS_SYSLIMITS_H_ 

#define ARG_MAX 65536

#define CHILD_MAX 40

#define LINK_MAX 32767
#define MAX_CANON 255
#define MAX_INPUT 255
#define NAME_MAX 255
#define NGROUPS_MAX 16

#define OPEN_MAX 64

#define PATH_MAX 1024
#define PIPE_BUF 512
#define IOV_MAX 1024

#define BC_BASE_MAX 99
#define BC_DIM_MAX 2048
#define BC_SCALE_MAX 99
#define BC_STRING_MAX 1000
#define COLL_WEIGHTS_MAX 0
#define EXPR_NEST_MAX 32
#define LINE_MAX 2048
#define RE_DUP_MAX 255
# 7 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/limits.h" 2 3 4


#define MB_LEN_MAX _MB_LEN_MAX






#define NL_ARGMAX 32
# 138 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/limits.h" 3 4
#define _POSIX2_RE_DUP_MAX 255
# 211 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 2 3 4
# 10 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/syslimits.h" 2 3 4
#pragma GCC diagnostic pop
#undef _GCC_NEXT_LIMITS_H
# 35 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 2 3 4
# 60 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 3 4
#define _LIMITS_H___ 


#undef CHAR_BIT
#define CHAR_BIT __CHAR_BIT__







#undef SCHAR_MIN
#define SCHAR_MIN (-SCHAR_MAX - 1)
#undef SCHAR_MAX
#define SCHAR_MAX __SCHAR_MAX__


#undef UCHAR_MAX



#define UCHAR_MAX (SCHAR_MAX * 2 + 1)




#undef CHAR_MIN



#define CHAR_MIN 0

#undef CHAR_MAX
#define CHAR_MAX UCHAR_MAX
# 103 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 3 4
#undef SHRT_MIN
#define SHRT_MIN (-SHRT_MAX - 1)
#undef SHRT_MAX
#define SHRT_MAX __SHRT_MAX__


#undef USHRT_MAX



#define USHRT_MAX (SHRT_MAX * 2 + 1)



#undef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#undef INT_MAX
#define INT_MAX __INT_MAX__


#undef UINT_MAX
#define UINT_MAX (INT_MAX * 2U + 1U)



#undef LONG_MIN
#define LONG_MIN (-LONG_MAX - 1L)
#undef LONG_MAX
#define LONG_MAX __LONG_MAX__


#undef ULONG_MAX
#define ULONG_MAX (LONG_MAX * 2UL + 1UL)
# 51 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/file_error_numbers.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/file_error_numbers.h"
#define ETL_FILE_ERROR_NUMBERS 

#define ETL_DEQUE_FILE_ID "1"
#define ETL_FLAT_MAP_FILE_ID "2"
#define ETL_FLAT_MULTIMAP_FILE_ID "3"
#define ETL_FLAT_MULTISET_FILE_ID "4"
#define ETL_FLAT_SET_FILE_ID "5"
#define ETL_FORWARD_LIST_FILE_ID "6"
#define ETL_LIST_FILE_ID "7"
#define ETL_MAP_FILE_ID "8"
#define ETL_MULTIMAP_FILE_ID "9"
#define ETL_MULTISET_FILE_ID "10"
#define ETL_POOL_FILE_ID "11"
#define ETL_PRIORITY_QUEUE_FILE_ID "12"
#define ETL_QUEUE_FILE_ID "13"
#define ETL_SET_FILE_ID "14"
#define ETL_STACK_FILE_ID "15"
#define ETL_UNORDERED_MAP_FILE_ID "16"
#define ETL_VECTOR_FILE_ID "17"
#define ETL_OBSERVER_FILE_ID "18"
#define ETL_IHASH_FILE_ID "19"
#define ETL_INTRUSIVE_FORWARD_LIST_FILE_ID "20"
#define ETL_INTRUSIVE_LIST_FILE_ID "21"
#define ETL_INTRUSIVE_LINKS_FILE_ID "22"
#define ETL_UNORDERED_SET_FILE_ID "23"
#define ETL_VARIANT_FILE_ID "24"
#define ETL_UNORDERED_MULTIMAP_FILE_ID "25"
#define ETL_UNORDERED_MULTISET_FILE_ID "26"
#define ETL_BASIC_STRING_FILE_ID "27"
#define ETL_INTRUSIVE_STACK_FILE_ID "28"
#define ETL_INTRUSIVE_QUEUE_FILE_ID "29"
#define ETL_REFERENCE_FLAT_MAP_FILE_ID "30"
#define ETL_REFERENCE_FLAT_MULTIMAP_FILE_ID "31"
#define ETL_REFERENCE_FLAT_SET_FILE_ID "32"
#define ETL_REFERENCE_FLAT_MULTISET_FILE_ID "33"
#define ETL_FSM_FILE_ID "34"
#define ETL_MESSAGE_ROUTER_FILE_ID "35"
#define ETL_SCHEDULER_FILE_ID "36"
#define ETL_TASK_FILE_ID "37"
#define ETL_MESSAGE_FILE_ID "38"
#define ETL_MESSAGE_BUS_FILE_ID "39"
#define ETL_VARIANT_POOL_FILE_ID "40"
#define ETL_ARRAY_VIEW_FILE_ID "41"
#define ETL_STRING_VIEW_FILE_ID "42"
#define ETL_CALLBACK_TIMER_FILE_ID "43"
#define ETL_MESSAGE_TIMER_FILE_ID "44"
#define ETL_TYPE_LOOKUP_FILE_ID "45"
#define ETL_QUEUE_SPSC_ISR_FILE_ID "46"
#define ETL_QUEUE_SPSC_ATOMIC_FILE_ID "47"
#define ETL_QUEUE_MPMC_MUTEX_FILE_ID "48"
#define ETL_TYPE_SELECT_FILE_ID "49"
#define ETL_BINARY_FILE_ID "50"
#define ETL_DELEGATE_FILE_ID "51"
#define ETL_BITSET_FILE_ID "52"
#define ETL_INDIRECT_VECTOR_FILE_ID "53"
#define ETL_QUEUE_SPSC_LOCKED_FILE_ID "54"
#define ETL_MESSAGE_PACKET_FILE_ID "55"
#define ETL_CIRCULAR_BUFFER_FILE_ID "56"
#define ETL_MULTI_LOOP_FILE_ID "57"
#define ETL_REFERENCE_COUNTER_MESSAGE_POOL_FILE_ID "58"
#define ETL_QUEUE_SPSC_LOCKABLE_FILE_ID "59"
#define ETL_MESSAGE_ROUTER_REGISTRY_FILE_ID "60"
#define ETL_ARRAY_WRAPPER_FILE_ID "61"
#define ETL_MEM_CAST_FILE_ID "62"
#define ETL_SINGLETON_FILE_ID "63"
#define ETL_SUCCESSOR_FILE_ID "64"
#define ETL_BIT_STREAM_FILE_ID "65"
#define ETL_BYTE_STREAM_FILE_ID "66"
#define ETL_BIP_BUFFER_SPSC_ATOMIC_FILE_ID "67"
#define ETL_REFERENCE_COUNTED_OBJECT_FILE_ID "68"
#define ETL_TO_ARITHMETIC_FILE_ID "69"
#define ETL_EXPECTED_FILE_ID "70"
#define ETL_ALIGNMENT_FILE_ID "71"
#define ETL_BASE64_FILE_ID "72"
#define ETL_SINGLETON_BASE_FILE_ID "73"
#define ETL_UNALIGNED_TYPE_FILE_ID "74"
#define ETL_SPAN_FILE_ID "75"
#define ETL_ALGORITHM_FILE_ID "76"
#define ETL_NOT_NULL_FILE_ID "77"
#define ETL_SIGNAL_FILE_ID "78"
# 53 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h" 2





#define ETL_NO_PROFILE_HEADER 
# 67 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_DO_NOTHING static_cast<void>(0)


#define ETL_PLATFORM_16BIT (UINT16_MAX == UINTPTR_MAX)
#define ETL_PLATFORM_32BIT (UINT32_MAX == UINTPTR_MAX)
#define ETL_PLATFORM_64BIT (UINT64_MAX == UINTPTR_MAX)
# 83 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_IS_DEBUG_BUILD 0







#define ETL_USING_STL 0
#define ETL_NOT_USING_STL 1
# 104 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_USING_STLPORT 0
#define ETL_NOT_USING_STLPORT 1





#define ETL_USING_8BIT_TYPES 1
#define ETL_NOT_USING_8BIT_TYPES 0





#define ETL_8BIT_SUPPORT (CHAR_BIT == 8)







#define ETL_USING_20BIT_TYPES 0
#define ETL_NOT_USING_20BIT_TYPES 1
# 137 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_USING_64BIT_TYPES 1
#define ETL_NOT_USING_64BIT_TYPES 0
# 147 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_USING_WIDE_CHARACTERS 1
#define ETL_NOT_USING_WIDE_CHARACTERS 0




# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_version.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_version.h"
#define ETL_DETERMINE_COMPILER_VERSION_H_INCLUDED 

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler.h"
#define ETL_DETERMINE_COMPILER_H_INCLUDED 
# 73 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler.h"
#define ETL_COMPILER_GCC 
#define ETL_COMPILER_TYPE_DETECTED 
# 139 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler.h"
#define ETL_USING_GCC_COMPILER 1







#define ETL_USING_MICROSOFT_COMPILER 0





#define ETL_USING_ARM5_COMPILER 0





#define ETL_USING_ARM6_COMPILER 0





#define ETL_USING_ARM7_COMPILER 0





#define ETL_USING_CLANG_COMPILER 0





#define ETL_USING_GREEN_HILLS_COMPILER 0





#define ETL_USING_IAR_COMPILER 0





#define ETL_USING_INTEL_COMPILER 0





#define ETL_USING_TEXAS_INSTRUMENTS_COMPILER 0





#define ETL_USING_TASKING_COMPILER 0





#define ETL_USING_GENERIC_COMPILER 0
# 35 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_version.h" 2



#define ETL_COMPILER_VERSION __GNUC__
#define ETL_COMPILER_FULL_VERSION ((__GNUC__ * 10000) + (__GNUC_MINOR__ * 100) + __GNUC_PATCHLEVEL__)
# 154 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h"
#define ETL_DETERMINE_COMPILER_LANGUAGE_SUPPORT_H_INCLUDED 
# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h"
#define ETL_CPP23_SUPPORTED (__cplusplus >= 202302L)
# 56 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h"
#define ETL_CPP11_SUPPORTED 1
#define ETL_CPP14_SUPPORTED 1
#define ETL_CPP17_SUPPORTED 1
#define ETL_CPP20_SUPPORTED 1
# 88 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h"
#define ETL_CPP11_SUPPORTED 1
#define ETL_CPP14_SUPPORTED 1
#define ETL_CPP17_SUPPORTED 1
# 113 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h"
#define ETL_CPP11_SUPPORTED 1
#define ETL_CPP14_SUPPORTED 1
# 137 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h"
#define ETL_CPP11_SUPPORTED 1
# 160 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h"
#define ETL_CPP11_NOT_SUPPORTED (!ETL_CPP11_SUPPORTED)
#define ETL_CPP14_NOT_SUPPORTED (!ETL_CPP14_SUPPORTED)
#define ETL_CPP17_NOT_SUPPORTED (!ETL_CPP17_SUPPORTED)
#define ETL_CPP20_NOT_SUPPORTED (!ETL_CPP20_SUPPORTED)
#define ETL_CPP23_NOT_SUPPORTED (!ETL_CPP23_SUPPORTED)


#define ETL_USING_CPP11 (ETL_CPP11_SUPPORTED == 1)
#define ETL_USING_CPP14 (ETL_CPP14_SUPPORTED == 1)
#define ETL_USING_CPP17 (ETL_CPP17_SUPPORTED == 1)
#define ETL_USING_CPP20 (ETL_CPP20_SUPPORTED == 1)
#define ETL_USING_CPP23 (ETL_CPP23_SUPPORTED == 1)

#define ETL_NOT_USING_CPP11 (ETL_CPP11_SUPPORTED == 0)
#define ETL_NOT_USING_CPP14 (ETL_CPP14_SUPPORTED == 0)
#define ETL_NOT_USING_CPP17 (ETL_CPP17_SUPPORTED == 0)
#define ETL_NOT_USING_CPP20 (ETL_CPP20_SUPPORTED == 0)
#define ETL_NOT_USING_CPP23 (ETL_CPP23_SUPPORTED == 0)


#define ETL_NO_NULLPTR_SUPPORT ETL_NOT_USING_CPP11




#define ETL_NO_SMALL_CHAR_SUPPORT 0






#define ETL_NO_LARGE_CHAR_SUPPORT ETL_NOT_USING_CPP11



#define ETL_CPP11_TYPE_TRAITS_IS_TRIVIAL_SUPPORTED ETL_USING_CPP11





#define ETL_LANGUAGE_STANDARD 23
# 218 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h"
#define ETL_NO_CPP_NAN_SUPPORT 
# 233 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_compiler_language_support.h"
#define ETL_HAS_STD_BYTESWAP 0
# 155 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h" 2



# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_development_os.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_development_os.h"
#define ETL_DETERMINE_DEVELOPMENT_OS_INCLUDED 
# 77 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_development_os.h"
#define ETL_DEVELOPMENT_OS_GENERIC 
#define ETL_DEVELOPMENT_OS_DETECTED 
# 159 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h" 2







#define ETL_USING_LEGACY_VARIANT 0
#define ETL_NOT_USING_LEGACY_VARIANT 1
# 185 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_EXPLICIT_STRING_FROM_CHAR 







#define ETL_HAS_STRING_TRUNCATION_CHECKS 1







#define ETL_HAS_STRING_CLEAR_AFTER_USE 1







#define ETL_HAS_ERROR_ON_STRING_TRUNCATION 0







#define ETL_HAS_ISTRING_REPAIR 0







#define ETL_HAS_IVECTOR_REPAIR 0







#define ETL_HAS_IDEQUE_REPAIR 0







#define ETL_HAS_ICIRCULAR_BUFFER_REPAIR 0
# 250 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_USING_EXCEPTIONS 0
#define ETL_NOT_USING_EXCEPTIONS 1
# 260 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_DEBUG_USING_EXCEPTIONS 0
#define ETL_DEBUG_NOT_USING_EXCEPTIONS 1







#define ETL_HAS_NULLPTR 1







#define ETL_USING_LEGACY_BITSET 0







#define ETL_HAS_MUTABLE_ARRAY_VIEW 0







#define ETL_HAS_VIRTUAL_MESSAGES 1







#define ETL_USING_VERBOSE_CHRONO_LITERALS 0







#define ETL_HAS_CHRONO_LITERALS_DAY 1







#define ETL_HAS_CHRONO_LITERALS_YEAR 1







#define ETL_HAS_CHRONO_LITERALS_DURATION 1






#define ETL_CONSTEXPR constexpr
#define ETL_CONSTEXPR11 constexpr
#define ETL_CONSTANT constexpr
#define ETL_DELETE = delete
#define ETL_EXPLICIT explicit
#define ETL_OVERRIDE override
#define ETL_FINAL final
#define ETL_NORETURN [[noreturn]]
#define ETL_MOVE(x) etl::move(x)
#define ETL_ENUM_CLASS(name) enum class name
#define ETL_ENUM_CLASS_TYPE(name,type) enum class name : type
#define ETL_LVALUE_REF_QUALIFIER &





#define ETL_NOEXCEPT 
#define ETL_NOEXCEPT_EXPR(...) 
#define ETL_NOEXCEPT_FROM(x) 
# 374 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_CONSTEXPR14 constexpr


#define ETL_DEPRECATED [[deprecated]]
#define ETL_DEPRECATED_REASON(reason) [[deprecated(reason)]]
# 392 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_CONSTEXPR17 constexpr
#define ETL_IF_CONSTEXPR constexpr
#define ETL_NODISCARD [[nodiscard]]
#define ETL_MAYBE_UNUSED [[maybe_unused]]
#define ETL_FALLTHROUGH [[fallthrough]]
#define ETL_INLINE_VAR inline
# 410 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_LIKELY [[likely]]
#define ETL_UNLIKELY [[unlikely]]
#define ETL_CONSTEXPR20 constexpr
#define ETL_CONSTEVAL consteval
#define ETL_CONSTINIT constinit
#define ETL_NO_UNIQUE_ADDRESS [[no_unique_address]]
#define ETL_EXPLICIT_EXPR(...) explicit(__VA_ARGS__)
# 430 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_CONSTEXPR20_STL 





#define ETL_ASSUME(expression) [[assume(expression)]]
# 450 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_HAS_CHAR8_T 1
#define ETL_HAS_NATIVE_CHAR8_T 1
# 462 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_HAS_NATIVE_CHAR16_T 1
#define ETL_HAS_NATIVE_CHAR32_T 1
# 472 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_HAS_STD_ARRAY 0
# 490 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_USING_LIBC_WCHAR_H 1
#define ETL_NOT_USING_LIBC_WCHAR_H 0
# 505 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_USING_STD_OSTREAM 0
#define ETL_NOT_USING_STD_OSTREAM 1
# 526 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_HAS_ATOMIC 1
# 535 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_HAS_ATOMIC_ALWAYS_LOCK_FREE 1
# 556 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_HAS_INITIALIZER_LIST 1
# 568 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
#define ETL_PACKED_CLASS(class_type) class __attribute__((packed)) class_type
#define ETL_PACKED_STRUCT(struct_type) struct __attribute__((packed)) struct_type
#define ETL_END_PACKED 
#define ETL_HAS_PACKED 1
# 587 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_builtin_support.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_builtin_support.h"
#define ETL_DETERMINE_BUILTIN_SUPPORT_H_INCLUDED 
# 86 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_builtin_support.h"
#define ETL_USING_BUILTIN_IS_ASSIGNABLE __has_builtin(__is_assignable)



#define ETL_USING_BUILTIN_IS_CONSTRUCTIBLE __has_builtin(__is_constructible)



#define ETL_USING_BUILTIN_IS_TRIVIALLY_CONSTRUCTIBLE (__has_builtin(__has_trivial_constructor) || __has_builtin(__is_trivially_constructible))



#define ETL_USING_BUILTIN_IS_TRIVIALLY_DESTRUCTIBLE (__has_builtin(__has_trivial_destructor) || __has_builtin(__is_trivially_destructible))



#define ETL_USING_BUILTIN_IS_TRIVIALLY_COPYABLE (__has_builtin(__has_trivial_copy) || __has_builtin(__is_trivially_copyable))



#define ETL_USING_BUILTIN_UNDERLYING_TYPE __has_builtin(__underlying_type)



#define ETL_USING_BUILTIN_IS_CONSTANT_EVALUATED __has_builtin(__builtin_is_constant_evaluated)



#define ETL_USING_BUILTIN_MEMCPY __has_builtin(__builtin_memcpy)



#define ETL_USING_BUILTIN_MEMMOVE __has_builtin(__builtin_memmove)



#define ETL_USING_BUILTIN_MEMSET __has_builtin(__builtin_memset)



#define ETL_USING_BUILTIN_MEMCMP __has_builtin(__builtin_memcmp)



#define ETL_USING_BUILTIN_MEMCHR __has_builtin(__builtin_memchr)
# 183 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_builtin_support.h"

# 183 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/profiles/determine_builtin_support.h"
namespace etl
{
  namespace traits
  {


    static constexpr bool using_builtin_is_assignable = (1 == 1);
    static constexpr bool using_builtin_is_constructible = (1 == 1);
    static constexpr bool using_builtin_is_trivially_constructible = ((1 || 1) == 1);
    static constexpr bool using_builtin_is_trivially_destructible = ((1 || 0) == 1);
    static constexpr bool using_builtin_is_trivially_copyable = ((1 || 1) == 1);
    static constexpr bool using_builtin_underlying_type = (1 == 1);
    static constexpr bool using_builtin_is_constant_evaluated = (1 == 1);
    static constexpr bool using_builtin_memcpy = (1 == 1);
    static constexpr bool using_builtin_memmove = (1 == 1);
    static constexpr bool using_builtin_memset = (1 == 1);
    static constexpr bool using_builtin_memcmp = (1 == 1);
    static constexpr bool using_builtin_memchr = (1 == 1);
  }
}
# 588 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h" 2



# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/choose_namespace.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/choose_namespace.h"
#define ETL_CHOOSE_NAMESPACE_INCLUDED 

#undef ETL_OR_STD
#undef ETL_OR_STD11
#undef ETL_OR_STD14



#define ETL_OR_STD etl
#define ETL_USING_STD_NAMESPACE 0
#define ETL_USING_ETL_NAMESPACE 1
# 52 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/choose_namespace.h"
#define ETL_OR_STD11 etl
#define ETL_USING_STD11_NAMESPACE 0
#define ETL_USING_ETL11_NAMESPACE 1
# 64 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/choose_namespace.h"
#define ETL_OR_STD14 etl
#define ETL_USING_STD14_NAMESPACE 0
#define ETL_USING_ETL14_NAMESPACE 1
# 76 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/choose_namespace.h"
#define ETL_OR_STD17 etl
#define ETL_USING_STD17_NAMESPACE 0
#define ETL_USING_ETL17_NAMESPACE 1
# 592 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/platform.h" 2

namespace etl
{
  namespace traits
  {


    static constexpr long cplusplus = 202302L;
    static constexpr int language_standard = 23;


    static constexpr bool using_stl = (0 == 1);
    static constexpr bool using_stlport = (0 == 1);
    static constexpr bool using_cpp11 = ((1 == 1) == 1);
    static constexpr bool using_cpp14 = ((1 == 1) == 1);
    static constexpr bool using_cpp17 = ((1 == 1) == 1);
    static constexpr bool using_cpp20 = ((1 == 1) == 1);
    static constexpr bool using_cpp23 = (((202302L >= 202302L) == 1) == 1);
    static constexpr bool using_gcc_compiler = (1 == 1);
    static constexpr bool using_microsoft_compiler = (0 == 1);
    static constexpr bool using_arm5_compiler = (0 == 1);
    static constexpr bool using_arm6_compiler = (0 == 1);
    static constexpr bool using_arm7_compiler = (0 == 1);
    static constexpr bool using_clang_compiler = (0 == 1);
    static constexpr bool using_green_hills_compiler = (0 == 1);
    static constexpr bool using_iar_compiler = (0 == 1);
    static constexpr bool using_intel_compiler = (0 == 1);
    static constexpr bool using_texas_instruments_compiler = (0 == 1);
    static constexpr bool using_generic_compiler = (0 == 1);
    static constexpr bool using_legacy_bitset = (0 == 1);
    static constexpr bool using_exceptions = (0 == 1);
    static constexpr bool using_libc_wchar_h = (1 == 1);


    static constexpr bool has_initializer_list = (1 == 1);
    static constexpr bool has_8bit_types = (1 == 1);
    static constexpr bool has_64bit_types = (1 == 1);
    static constexpr bool has_atomic = (1 == 1);
    static constexpr bool has_atomic_always_lock_free = (1 == 1);
    static constexpr bool has_nullptr = (1 == 1);
    static constexpr bool has_char8_t = (1 == 1);
    static constexpr bool has_native_char8_t = (1 == 1);
    static constexpr bool has_native_char16_t = (1 == 1);
    static constexpr bool has_native_char32_t = (1 == 1);
    static constexpr bool has_string_truncation_checks = (1 == 1);
    static constexpr bool has_error_on_string_truncation = (0 == 1);
    static constexpr bool has_string_clear_after_use = (1 == 1);
    static constexpr bool has_istring_repair = (0 == 1);
    static constexpr bool has_ivector_repair = (0 == 1);
    static constexpr bool has_icircular_buffer_repair = (0 == 1);
    static constexpr bool has_mutable_array_view = (0 == 1);
    static constexpr bool has_ideque_repair = (0 == 1);
    static constexpr bool has_virtual_messages = (1 == 1);
    static constexpr bool has_packed = (1 == 1);
    static constexpr bool has_chrono_literals_day = (1 == 1);
    static constexpr bool has_chrono_literals_year = (1 == 1);
    static constexpr bool has_chrono_literals_hours = (1 == 1);
    static constexpr bool has_chrono_literals_minutes = (1 == 1);
    static constexpr bool has_chrono_literals_seconds = (1 == 1);
    static constexpr bool has_chrono_literals_milliseconds = (1 == 1);
    static constexpr bool has_chrono_literals_microseconds = (1 == 1);
    static constexpr bool has_chrono_literals_nanoseconds = (1 == 1);
    static constexpr bool has_std_byteswap = (0 == 1);


    static constexpr bool is_debug_build = (0 == 1);
  }
}
# 35 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
#define ETL_BASIC_STRING_INCLUDED 


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 1
# 34 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
#define ETL_ALGORITHM_INCLUDED 







# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 54 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
#define ETL_TYPE_TRAITS_INCLUDED 


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/nullptr.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/nullptr.h"
#define ETL_NULLPTR_INCLUDED 



# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/nullptr.h" 2

namespace etl
{
# 61 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/nullptr.h"
  typedef decltype(nullptr) nullptr_t;
#define ETL_NULLPTR nullptr

}
# 58 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/static_assert.h" 1
# 30 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/static_assert.h"
#define ETL_ETL_STATIC_ASSERT_INCLUDED 




#define ETL_STATIC_ASSERT(Condition,Message) static_assert(Condition, Message)
# 59 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 2

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 61 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 2
# 72 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
namespace etl
{

  template <typename...>
  using void_t = void;
# 87 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  template <typename T, T VALUE>
  struct integral_constant
  {
    static const T value = VALUE;

    typedef T value_type;
    typedef integral_constant<T, VALUE> type;

    operator value_type() const
    {
      return value;
    }
  };


  typedef integral_constant<bool, false> false_type;
  typedef integral_constant<bool, true> true_type;

  template <typename T, T VALUE>
  const T integral_constant<T, VALUE>::value;


  template <typename T, T VALUE>
  inline constexpr T integral_constant_v = etl::integral_constant<T, VALUE>::value;



  template <bool BValue>
  using bool_constant = integral_constant<bool, BValue>;






  template <bool BValue>
  inline constexpr bool bool_constant_v = bool_constant<BValue>::value;




  template <typename T>
  struct negation : etl::bool_constant<!bool(T::value)>
  {
  };


  template <typename T>
  inline constexpr bool negation_v = negation<T>::value;




  template <typename T> struct remove_reference { typedef T type; };
  template <typename T> struct remove_reference<T&> { typedef T type; };

  template <typename T> struct remove_reference<T&&> { typedef T type; };



  template <typename T>
  using remove_reference_t = typename remove_reference<T>::type;




  template <typename T> struct remove_pointer { typedef T type; };
  template <typename T> struct remove_pointer<T*> { typedef T type; };
  template <typename T> struct remove_pointer<const T*> { typedef const T type; };
  template <typename T> struct remove_pointer<volatile T*> { typedef volatile T type; };
  template <typename T> struct remove_pointer<const volatile T*> { typedef const volatile T type; };
  template <typename T> struct remove_pointer<T* const> { typedef T type; };
  template <typename T> struct remove_pointer<const T* const> { typedef const T type; };
  template <typename T> struct remove_pointer<volatile T* const> { typedef volatile T type; };
  template <typename T> struct remove_pointer<const volatile T* const> { typedef const volatile T type; };


  template <typename T>
  using remove_pointer_t = typename remove_pointer<T>::type;




  template <typename T> struct add_pointer { typedef typename remove_reference<T>::type* type; };


  template <typename T>
  using add_pointer_t = typename add_pointer<T>::type;




  template <typename T> struct is_const : false_type {};
  template <typename T> struct is_const<const T> : true_type {};
  template <typename T> struct is_const<const volatile T> : true_type {};


  template <typename T>
  inline constexpr bool is_const_v = is_const<T>::value;




  template <typename T> struct remove_const { typedef T type; };
  template <typename T> struct remove_const<const T> { typedef T type; };


  template <typename T>
  using remove_const_t = typename remove_const<T>::type;




  template <typename T> struct add_const { typedef const T type; };
  template <typename T> struct add_const<const T> { typedef const T type; };


  template <typename T>
  using add_const_t = typename add_const<T>::type;




  template <typename T> struct is_volatile : false_type {};
  template <typename T> struct is_volatile<volatile T> : true_type {};
  template <typename T> struct is_volatile<const volatile T> : true_type {};


  template <typename T>
  inline constexpr bool is_volatile_v = is_volatile<T>::value;




  template <typename T> struct remove_volatile { typedef T type; };
  template <typename T> struct remove_volatile<volatile T> { typedef T type; };


  template <typename T>
  using remove_volatile_t = typename remove_volatile<T>::type;




  template <typename T> struct add_volatile { typedef volatile T type; };
  template <typename T> struct add_volatile<volatile T> { typedef volatile T type; };


  template <typename T>
  using add_volatile_t = typename add_volatile<T>::type;




  template <typename T> struct remove_cv
  {
    typedef typename remove_volatile<typename remove_const<T>::type>::type type;
  };


  template <typename T>
  using remove_cv_t = typename remove_cv<T>::type;




  template <typename T> struct add_cv
  {
    typedef typename add_volatile<typename add_const<T>::type>::type type;
  };


  template <typename T>
  using add_cv_t = typename add_cv<T>::type;




  template <typename T> struct remove_cvref
  {
    typedef typename remove_cv<typename remove_reference<T>::type>::type type;
  };


  template <typename T>
  using remove_cvref_t = typename remove_cvref<T>::type;




  template <typename T> struct is_integral : false_type {};
  template <> struct is_integral<bool> : true_type {};
  template <> struct is_integral<char> : true_type {};
  template <> struct is_integral<unsigned char> : true_type {};
  template <> struct is_integral<signed char> : true_type {};
  template <> struct is_integral<wchar_t> : true_type {};
  template <> struct is_integral<short> : true_type {};
  template <> struct is_integral<unsigned short> : true_type {};
  template <> struct is_integral<int> : true_type {};
  template <> struct is_integral<unsigned int> : true_type {};
  template <> struct is_integral<long> : true_type {};
  template <> struct is_integral<unsigned long> : true_type {};
  template <> struct is_integral<long long> : true_type {};
  template <> struct is_integral<unsigned long long> : true_type {};

  template <> struct is_integral<char8_t> : true_type {};


  template <> struct is_integral<char16_t> : true_type {};


  template <> struct is_integral<char32_t> : true_type {};

  template <typename T> struct is_integral<const T> : is_integral<T> {};
  template <typename T> struct is_integral<volatile T> : is_integral<T> {};
  template <typename T> struct is_integral<const volatile T> : is_integral<T> {};


  template <typename T>
  inline constexpr bool is_integral_v = is_integral<T>::value;




  template <typename T> struct is_signed : false_type {};
  template <> struct is_signed<char> : etl::bool_constant<(char(255) < 0)> {};
  template <> struct is_signed<wchar_t> : public etl::bool_constant<wchar_t(-1) < wchar_t(0)> {};
  template <> struct is_signed<signed char> : true_type {};
  template <> struct is_signed<short> : true_type {};
  template <> struct is_signed<int> : true_type {};
  template <> struct is_signed<long> : true_type {};
  template <> struct is_signed<long long> : true_type {};
  template <> struct is_signed<float> : true_type {};
  template <> struct is_signed<double> : true_type {};
  template <> struct is_signed<long double> : true_type {};

  template <> struct is_signed<char8_t> : true_type {};


  template <> struct is_signed<char16_t> : true_type {};


  template <> struct is_signed<char32_t> : true_type {};

  template <typename T> struct is_signed<const T> : is_signed<T> {};
  template <typename T> struct is_signed<volatile T> : is_signed<T> {};
  template <typename T> struct is_signed<const volatile T> : is_signed<T> {};


  template <typename T>
  inline constexpr bool is_signed_v = is_signed<T>::value;




  template <typename T> struct is_unsigned : false_type {};
  template <> struct is_unsigned<bool> : true_type {};
  template <> struct is_unsigned<char> : etl::bool_constant<(char(255) > 0)> {};
  template <> struct is_unsigned<unsigned char> : true_type {};
  template <> struct is_unsigned<wchar_t> : public etl::bool_constant<(wchar_t(-1) > wchar_t(0))> {};
  template <> struct is_unsigned<unsigned short> : true_type {};
  template <> struct is_unsigned<unsigned int> : true_type {};
  template <> struct is_unsigned<unsigned long> : true_type {};
  template <> struct is_unsigned<unsigned long long> : true_type {};
  template <typename T> struct is_unsigned<const T> : is_unsigned<T> {};
  template <typename T> struct is_unsigned<volatile T> : is_unsigned<T> {};
  template <typename T> struct is_unsigned<const volatile T> : is_unsigned<T> {};


  template <typename T>
  inline constexpr bool is_unsigned_v = is_unsigned<T>::value;




  template <typename T> struct is_floating_point : false_type {};
  template <> struct is_floating_point<float> : true_type {};
  template <> struct is_floating_point<double> : true_type {};
  template <> struct is_floating_point<long double> : true_type {};
  template <typename T> struct is_floating_point<const T> : is_floating_point<T> {};
  template <typename T> struct is_floating_point<volatile T> : is_floating_point<T> {};
  template <typename T> struct is_floating_point<const volatile T> : is_floating_point<T> {};


  template <typename T>
  inline constexpr bool is_floating_point_v = is_floating_point<T>::value;




  template <typename T1, typename T2> struct is_same : public false_type {};
  template <typename T> struct is_same<T, T> : public true_type {};


  template <typename T1, typename T2>
  inline constexpr bool is_same_v = is_same<T1, T2>::value;




  template<typename T> struct is_void : false_type {};
  template<> struct is_void<void> : true_type {};


  template <typename T>
  inline constexpr bool is_void_v = is_void<T>::value;




  template<typename T> struct is_arithmetic : etl::bool_constant<is_integral<T>::value || is_floating_point<T>::value> {};


  template <typename T>
  inline constexpr bool is_arithmetic_v = is_arithmetic<T>::value;




  template <typename T> struct is_fundamental : etl::bool_constant<is_arithmetic<T>::value || is_void<T>::value> {};


  template <typename T>
  inline constexpr bool is_fundamental_v = is_fundamental<T>::value;




  template <typename T> struct is_compound : etl::bool_constant<!is_fundamental<T>::value> {};


  template <typename T>
  inline constexpr bool is_compound_v = is_compound<T>::value;




  template <typename T> struct is_array : false_type {};
  template <typename T> struct is_array<T[]> : true_type {};
  template <typename T, size_t Size> struct is_array<T[Size]> : true_type {};


  template <typename T>
  inline constexpr bool is_array_v = is_array<T>::value;




  template<typename T> struct is_pointer_helper : false_type {};
  template<typename T> struct is_pointer_helper<T*> : true_type {};
  template<typename T> struct is_pointer_helper<const T*> : is_pointer_helper<T*> {};
  template<typename T> struct is_pointer_helper<volatile T*> : is_pointer_helper<T*> {};
  template<typename T> struct is_pointer_helper<const volatile T*> : is_pointer_helper<T*> {};
  template<typename T> struct is_pointer : is_pointer_helper<typename remove_cv<T>::type> {};


  template <typename T>
  inline constexpr bool is_pointer_v = is_pointer<T>::value;




  template<typename T> struct is_lvalue_reference_helper : false_type {};
  template<typename T> struct is_lvalue_reference_helper<T&> : true_type {};
  template<typename T> struct is_lvalue_reference : is_lvalue_reference_helper<typename remove_cv<T>::type> {};


  template <typename T>
  inline constexpr bool is_lvalue_reference_v = etl::is_lvalue_reference<T>::value;





  template<typename T> struct is_rvalue_reference_helper : false_type {};
  template<typename T> struct is_rvalue_reference_helper<T&&> : true_type {};
  template<typename T> struct is_rvalue_reference : is_rvalue_reference_helper<typename remove_cv<T>::type> {};


  template <typename T>
  inline constexpr bool is_rvalue_reference_v = etl::is_rvalue_reference<T>::value;






  template<typename T> struct is_reference : integral_constant<bool,
    is_lvalue_reference<T>::value

        || is_rvalue_reference<T>::value

  >{};


  template <typename T>
  inline constexpr bool is_reference_v = is_reference<T>::value;





  template <typename T> struct is_pod : etl::bool_constant<etl::is_fundamental<T>::value || etl::is_pointer<T>::value> {};


  template <typename T>
  inline constexpr bool is_pod_v = etl::is_pod<T>::value;




  template <bool BValue, typename T, typename F> struct conditional { typedef T type; };
  template <typename T, typename F> struct conditional<false, T, F> { typedef F type; };


  template <bool BValue, typename T, typename F>
  using conditional_t = typename conditional<BValue, T, F>::type;




  template <typename T> struct make_signed { typedef T type; };
  template <> struct make_signed<char> { typedef signed char type; };
  template <> struct make_signed<unsigned char> { typedef signed char type; };

  template <> struct make_signed<wchar_t>
  {
    typedef etl::conditional<sizeof(wchar_t) == sizeof(int16_t),
                             int16_t,
                             etl::conditional<sizeof(wchar_t) == sizeof(int32_t),
                                              int32_t,
                                              void>::type>::type type;
  };

  template <> struct make_signed<unsigned short> { typedef short type; };
  template <> struct make_signed<unsigned int> { typedef int type; };
  template <> struct make_signed<unsigned long> { typedef long type; };
  template <> struct make_signed<unsigned long long> { typedef long long type; };
  template <typename T> struct make_signed<const T> : add_const<typename make_signed<T>::type> {};
  template <typename T> struct make_signed<volatile T> : add_volatile<typename make_signed<T>::type> {};
  template <typename T> struct make_signed<const volatile T> : add_const<typename add_volatile<typename make_signed<T>::type>::type> {};


  template <typename T>
  using make_signed_t = typename make_signed<T>::type;




  template <typename T> struct make_unsigned { typedef T type; };
  template <> struct make_unsigned<char> { typedef unsigned char type; };
  template <> struct make_unsigned<signed char> { typedef unsigned char type; };
  template <> struct make_unsigned<short> { typedef unsigned short type; };

  template <> struct make_unsigned<wchar_t>
  {
    typedef etl::conditional<sizeof(wchar_t) == sizeof(uint16_t),
                             uint16_t,
                             etl::conditional<sizeof(wchar_t) == sizeof(uint32_t),
                                              uint32_t,
                                              void>::type>::type type;
  };

  template <> struct make_unsigned<int> { typedef unsigned int type; };
  template <> struct make_unsigned<long> { typedef unsigned long type; };
  template <> struct make_unsigned<long long> { typedef unsigned long long type; };
  template <typename T> struct make_unsigned<const T> : add_const<typename make_unsigned<T>::type> {};
  template <typename T> struct make_unsigned<volatile T> : add_volatile<typename make_unsigned<T>::type> {};
  template <typename T> struct make_unsigned<const volatile T> : add_const<typename add_volatile<typename make_unsigned<T>::type>::type> {};


  template <typename T>
  using make_unsigned_t = typename make_unsigned<T>::type;




  template <bool BValue, typename T = void> struct enable_if {};
  template <typename T> struct enable_if<true, T> { typedef T type; };


  template <bool BValue, typename T = void>
  using enable_if_t = typename enable_if<BValue, T>::type;




  template <typename T, unsigned Size = 0U>
  struct extent : integral_constant<size_t, 0U> {};

  template <typename T>
  struct extent<T[], 0> : integral_constant<size_t, 0U> {};

  template <typename T, unsigned Size>
  struct extent<T[], Size> : integral_constant<size_t, extent<T, Size - 1>::value> {};

  template <typename T, unsigned Size>
  struct extent<T[Size], 0> : integral_constant<size_t, Size> {};

  template <typename T, unsigned I, unsigned Size>
  struct extent<T[I], Size> : integral_constant<size_t, extent<T, Size - 1>::value> {};


  template <typename T, unsigned Size = 0U>
  inline constexpr size_t extent_v = extent<T, Size>::value;




  template <typename T> struct remove_extent { typedef T type; };
  template <typename T> struct remove_extent<T[]> { typedef T type; };
  template <typename T, size_t Size> struct remove_extent<T[Size]> { typedef T type; };


  template <typename T>
  using remove_extent_t = typename remove_extent<T>::type;




  template <typename T> struct remove_all_extents { typedef T type; };
  template <typename T> struct remove_all_extents<T[]> { typedef typename remove_all_extents<T>::type type; };
  template <typename T, size_t Size> struct remove_all_extents<T[Size]> { typedef typename remove_all_extents<T>::type type; };


  template <typename T>
  using remove_all_extents_t = typename remove_all_extents<T>::type;




  template <typename T>struct rank : integral_constant<size_t, 0> {};
  template <typename T> struct rank<T[]> : public integral_constant<size_t, rank<T>::value + 1> {};
  template <typename T, size_t Size> struct rank<T[Size]> : public integral_constant<size_t, rank<T>::value + 1> {};


  template <typename T>
  inline constexpr size_t rank_v = rank<T>::value;




  template <typename T>
  struct decay
  {
    typedef typename etl::remove_reference<T>::type U;
    typedef typename etl::conditional<etl::is_array<U>::value,
                                      typename etl::remove_extent<U>::type*,
                                      typename etl::remove_cv<U>::type>::type type;
  };


  template <typename T>
  using decay_t = typename decay<T>::type;




  template<typename TBase,
           typename TDerived,
           const bool IsFundamental = (etl::is_fundamental<TBase>::value || etl::is_fundamental<TDerived>::value || etl::is_array<TDerived>::value)>
  struct is_base_of
  {
  private:

    static TBase* check(TBase*) { return (TBase*)0; }
    static char check(...) { return 0; }

  public:

    static const bool value = (sizeof(check((TDerived*)0)) == sizeof(TBase*));
  };


  template<typename TBase, typename TDerived>
  struct is_base_of<TBase, TDerived, true>
  {
    static const bool value = false;
  };


  template <typename T1, typename T2>
  inline constexpr bool is_base_of_v = is_base_of<T1, T2>::value;




  namespace private_type_traits
  {
    template <typename T> char test(int T::*);

    struct dummy { char c[2]; };
    template <typename T> dummy test(...);
  }

  template <typename T>
  struct is_class : etl::bool_constant<sizeof(private_type_traits::test<T>(0)) == 1U> {};


  template <typename T>
  inline constexpr bool is_class_v = is_class<T>::value;




  template <typename T> struct add_lvalue_reference { typedef T& type; };
  template <typename T> struct add_lvalue_reference<T&> { typedef T& type; };
  template <> struct add_lvalue_reference<void> { typedef void type; };
  template <> struct add_lvalue_reference<const void> { typedef const void type; };
  template <> struct add_lvalue_reference<volatile void> { typedef volatile void type; };
  template <> struct add_lvalue_reference<const volatile void> { typedef const volatile void type; };


  template <typename T>
  using add_lvalue_reference_t = typename etl::add_lvalue_reference<T>::type;





  template <typename T> struct add_rvalue_reference { using type = T && ; };
  template <typename T> struct add_rvalue_reference<T&> { using type = T & ; };
  template <> struct add_rvalue_reference<void> { using type = void; };
  template <> struct add_rvalue_reference<const void> { using type = const void; };
  template <> struct add_rvalue_reference<volatile void> { using type = volatile void; };
  template <> struct add_rvalue_reference<const volatile void> { using type = const volatile void; };



  template <typename T>
  using add_rvalue_reference_t = typename etl::add_rvalue_reference<T>::type;





  template <typename T>
  typename etl::add_rvalue_reference<T>::type declval() ;
# 733 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  namespace private_type_traits
  {

    template <typename T, typename = int>
    struct is_convertible_to_int
      : false_type
    {
    };



    template <typename T>
    struct is_convertible_to_int<T, decltype(static_cast<int>(declval<T>()))>
      : true_type
    {
    };
  }

  template <typename T>
  struct is_enum
    : integral_constant<bool, private_type_traits::is_convertible_to_int<T>::value &&
                              !is_class<T>::value &&
                              !is_arithmetic<T>::value &&
                              !is_reference<T>::value>
  {
  };


  template <typename T>
  inline constexpr bool is_enum_v = etl::is_enum<T>::value;
# 792 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  namespace private_type_traits
  {
    template <typename>
    using true_type_for = etl::true_type;

    template <typename T>
    auto returnable(int)->true_type_for<T()>;

    template <typename>
    auto returnable(...)->etl::false_type;

    template <typename TFrom, typename TTo>
    auto nonvoid_convertible(int)->true_type_for<decltype(etl::declval<void(&)(TTo)>()(etl::declval<TFrom>()))
    >;
    template <typename, typename>
    auto nonvoid_convertible(...)->etl::false_type;
  }





  template <typename TFrom, typename TTo>
  struct is_convertible : etl::bool_constant<(decltype(private_type_traits::returnable<TTo>(0))::value &&
                                              decltype(private_type_traits::nonvoid_convertible<TFrom, TTo>(0))::value) ||
                                              (etl::is_void<TFrom>::value && etl::is_void<TTo>::value)> {};




  template <typename TFrom, typename TTo >
  inline constexpr bool is_convertible_v = etl::is_convertible<TFrom, TTo>::value;






  template <typename T> struct alignment_of : integral_constant<size_t, alignof(T)> { };
# 841 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  template <> struct alignment_of<void> : integral_constant <size_t, 0> {};
  template <> struct alignment_of<const void> : integral_constant <size_t, 0> {};


  template <typename T>
  inline constexpr size_t alignment_of_v = etl::alignment_of<T>::value;
# 1373 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  template <typename...>
  struct conjunction : public etl::true_type
  {
  };

  template <typename T1, typename... Tn>
  struct conjunction<T1, Tn...> : public etl::conditional_t<bool(T1::value), etl::conjunction<Tn...>, T1>
  {
  };

  template <typename T>
  struct conjunction<T> : public T
  {
  };



  template <typename... T>
  inline constexpr bool conjunction_v = conjunction<T...>::value;





  template <typename...>
  struct disjunction : public etl::false_type
  {
  };

  template <typename T1, typename... Tn>
  struct disjunction<T1, Tn...> : public etl::conditional_t<bool(T1::value), T1, disjunction<Tn...>>
  {
  };

  template <typename T1> struct disjunction<T1> : public T1
  {
  };



  template <typename... T>
  inline constexpr bool disjunction_v = etl::disjunction<T...>::value;







  template <typename... TTypes>
  struct exclusive_disjunction;

  template <typename T>
  struct exclusive_disjunction<T> : public etl::bool_constant<T::value>
  {
  };


  template <typename T1, typename T2, typename... TRest>
  struct exclusive_disjunction<T1, T2, TRest...> : public etl::exclusive_disjunction<etl::integral_constant<bool, etl::disjunction<T1, T2>::value && !etl::conjunction<T1, T2>::value>, TRest...>
  {
  };



  template <typename... T>
  inline constexpr bool exclusive_disjunction_v = etl::exclusive_disjunction<T...>::value;





  template <bool BValue, typename T, T TRUE_VALUE, T FALSE_VALUE>
  struct conditional_integral_constant;

  template <typename T, T TRUE_VALUE, T FALSE_VALUE>
  struct conditional_integral_constant<true, T, TRUE_VALUE, FALSE_VALUE>
  {
    static_assert(etl::is_integral<T>::value, "Not an integral type");
    static const T value = TRUE_VALUE;
  };

  template <typename T, T TRUE_VALUE, T FALSE_VALUE>
  struct conditional_integral_constant<false, T, TRUE_VALUE, FALSE_VALUE>
  {
    static_assert(etl::is_integral<T>::value, "Not an integral type");
    static const T value = FALSE_VALUE;
  };





  template <typename T, typename... TRest>
  struct is_one_of : etl::disjunction<etl::is_same<T, TRest>...>
  {
  };
# 1502 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  template <typename T, typename... TRest>
  inline constexpr bool is_one_of_v = etl::is_one_of<T, TRest...>::value;



  namespace private_type_traits
  {


    template<typename T, typename... TTypes>
    struct count_type;


    template<typename T>
    struct count_type<T> : etl::integral_constant<size_t, 0>
    {
    };


    template<typename T, typename THead, typename... TTail>
    struct count_type<T, THead, TTail...> : etl::integral_constant<size_t, (etl::is_same<T, THead>::value ? 1 : 0) + count_type<T, TTail...>::value>
    {
    };
  }

  template<typename T, typename... TTypes>
  struct has_duplicates_of
    : etl::integral_constant<bool, (private_type_traits::count_type<T, TTypes...>::value > 1)>
  {
  };



  template <typename T, typename... TRest>
  inline constexpr bool has_duplicates_of_v = etl::has_duplicates_of<T, TRest...>::value;






  template <typename TBase, typename... TDerived>
  struct is_base_of_all : etl::conjunction<etl::is_base_of<TBase, TDerived>...>
  {
  };



  template <typename T, typename... TRest>
  inline constexpr bool is_base_of_all_v = etl::is_base_of_all<T, TRest...>::value;






  template <typename TBase, typename... TDerived>
  struct is_base_of_any : etl::disjunction<etl::is_base_of<TBase, TDerived>...>
  {
  };




  template <typename T, typename... TRest>
  inline constexpr bool is_base_of_any_v = etl::is_base_of_any<T, TRest...>::value;







  template <size_t Index, typename TType>
  struct nth_base
  {
    typedef typename nth_base<Index - 1U, typename TType::base_type>::type type;
  };

  template <typename TType>
  struct nth_base<0, TType>
  {
    typedef TType type;
  };


  template <size_t Index, typename TType>
  using nth_base_t = typename nth_base<Index, TType>::type;







  template <typename T>
  struct types
  {
  private:

    typedef typename etl::remove_reference<typename etl::remove_cv<T>::type>::type type_t;

  public:

    typedef type_t type;
    typedef type_t& reference;
    typedef const type_t& const_reference;
    typedef type_t* pointer;
    typedef const type_t* const_pointer;
    typedef const type_t* const const_pointer_const;


    typedef type_t&& rvalue_reference;

  };


  template <typename T>
  struct types<T*>
  {
  private:

    typedef typename etl::remove_reference<typename etl::remove_cv<T>::type>::type type_t;

  public:

    typedef type_t type;
    typedef type_t& reference;
    typedef const type_t& const_reference;
    typedef type_t* pointer;
    typedef const type_t* const_pointer;
    typedef const type_t* const const_pointer_const;


    typedef type_t&& rvalue_reference;

  };


  template <typename T>
  struct types<T* const>
  {
  private:

    typedef typename etl::remove_reference<typename etl::remove_cv<T>::type>::type type_t;

  public:

    typedef type_t type;
    typedef type_t& reference;
    typedef const type_t& const_reference;
    typedef type_t* pointer;
    typedef const type_t* const_pointer;
    typedef const type_t* const const_pointer_const;


    typedef type_t&& rvalue_reference;

  };


  template <typename T>
  struct types<T&>
  {
  private:

    typedef typename etl::remove_reference<typename etl::remove_cv<T>::type>::type type_t;

  public:

    typedef type_t type;
    typedef type_t& reference;
    typedef const type_t& const_reference;
    typedef type_t* pointer;
    typedef const type_t* const_pointer;
    typedef const type_t* const const_pointer_const;


    typedef type_t&& rvalue_reference;

  };



  template <typename T>
  struct types<T&&>
  {
  private:

    typedef typename etl::remove_reference<typename etl::remove_cv<T>::type>::type type_t;

  public:

    typedef type_t type;
    typedef type_t& reference;
    typedef const type_t& const_reference;
    typedef type_t* pointer;
    typedef const type_t* const_pointer;
    typedef const type_t* const const_pointer_const;


    typedef type_t&& rvalue_reference;

  };



  template <typename T>
  using types_t = typename types<T>::type;

  template <typename T>
  using types_r = typename types<T>::reference;

  template <typename T>
  using types_cr = typename types<T>::const_reference;

  template <typename T>
  using types_rr = typename types<T>::rvalue_reference;

  template <typename T>
  using types_p = typename types<T>::pointer;

  template <typename T>
  using types_cp = typename types<T>::const_pointer;

  template <typename T>
  using types_cpc = typename types<T>::const_pointer_const;





  template <typename T> struct size_of : etl::integral_constant<size_t, sizeof(T)> {};
  template <> struct size_of<void> : etl::integral_constant<size_t, 1U> {};


  template <typename T>
  inline constexpr size_t size_of_v = etl::size_of<T>::value;





  template <typename T, typename... TRest>
  struct are_all_same : etl::conjunction<etl::is_same<T, TRest>...>
  {
  };



  template <typename T, typename... TRest>
  inline constexpr bool are_all_same_v = are_all_same<T, TRest...>::value;
# 2110 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  template <typename T1, typename T2>
  struct is_assignable : public etl::bool_constant<(etl::is_arithmetic<T1>::value || etl::is_pointer<T1>::value) && (etl::is_arithmetic<T2>::value || etl::is_pointer<T2>::value)>
  {
  };




  namespace private_type_traits
  {
    template <class, class T, class... Args>
    struct is_constructible_ : etl::false_type {};

    template <class T, class... Args>
    struct is_constructible_<void_t<decltype(T(etl::declval<Args>()...))>, T, Args...> : etl::true_type {};
  }



  template <class T, class... Args>
  using is_constructible = private_type_traits::is_constructible_<void_t<>, T, Args...>;



  template <class T> struct is_copy_constructible : public is_constructible<T, typename etl::add_lvalue_reference<typename etl::add_const<T>::type>::type>{};
  template <> struct is_copy_constructible<void> : public false_type{};
  template <> struct is_copy_constructible<void const> : public false_type{};
  template <> struct is_copy_constructible<void volatile> : public false_type{};
  template <> struct is_copy_constructible<void const volatile> : public false_type{};



  template <typename T> struct is_move_constructible: public is_constructible<T, typename etl::add_rvalue_reference<T>::type>{};
  template <> struct is_move_constructible<void> : public false_type{};
  template <> struct is_move_constructible<void const> : public false_type{};
  template <> struct is_move_constructible<void volatile> : public false_type{};
  template <> struct is_move_constructible<void const volatile> : public false_type{};
# 2167 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  template <typename T>
  struct is_trivially_constructible : public etl::bool_constant<etl::is_arithmetic<T>::value || etl::is_pointer<T>::value>
  {
  };



  template <typename T>
  struct is_trivially_copy_constructible : public etl::bool_constant<etl::is_arithmetic<T>::value || etl::is_pointer<T>::value>
  {
  };



  template <typename T>
  struct is_trivially_destructible : public etl::bool_constant<etl::is_arithmetic<T>::value || etl::is_pointer<T>::value>
  {
  };



  template <typename T>
  struct is_trivially_copy_assignable : public etl::bool_constant<etl::is_arithmetic<T>::value || etl::is_pointer<T>::value>
  {
  };



  template <typename T>
  struct is_trivially_copyable : public etl::bool_constant<etl::is_arithmetic<T>::value || etl::is_pointer<T>::value>
  {
  };



  template <typename T1, typename T2>
  struct is_lvalue_assignable : public etl::is_assignable<typename etl::add_lvalue_reference<T1>::type,
                                                          typename etl::add_lvalue_reference<typename etl::add_const<T2>::type>::type>
  {
  };




  template<typename T, typename = void>
  struct is_default_constructible : etl::false_type { };

  template<typename T>
  struct is_default_constructible<T, etl::void_t<decltype(T())>> : etl::true_type { };
# 2225 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  template <typename T1, typename T2>
  inline constexpr bool is_assignable_v = etl::is_assignable<T1, T2>::value;

  template <typename T1, typename T2>
  inline constexpr bool is_lvalue_assignable_v = etl::is_lvalue_assignable<T1, T2>::value;

  template<typename T, typename... TArgs>
  inline constexpr bool is_constructible_v = etl::is_constructible<T, TArgs...>::value;

  template<typename T, typename... TArgs>
  inline constexpr bool is_default_constructible_v = etl::is_default_constructible<T, TArgs...>::value;

  template<typename T>
  inline constexpr bool is_copy_constructible_v = etl::is_copy_constructible<T>::value;

  template<typename T>
  inline constexpr bool is_move_constructible_v = etl::is_move_constructible<T>::value;

  template <typename T>
  inline constexpr bool is_trivially_constructible_v = etl::is_trivially_constructible<T>::value;

  template <typename T>
  inline constexpr bool is_trivially_copy_constructible_v = etl::is_trivially_copy_constructible<T>::value;

  template <typename T>
  inline constexpr bool is_trivially_destructible_v = etl::is_trivially_destructible<T>::value;

  template <typename T>
  inline constexpr bool is_trivially_copy_assignable_v = etl::is_trivially_copy_assignable<T>::value;

  template <typename T>
  inline constexpr bool is_trivially_copyable_v = etl::is_trivially_copyable<T>::value;
# 2268 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  template<typename...>
  struct common_type
  {
  };



  template <typename T>
  struct common_type<T> : common_type<T, T>
  {
  };

  namespace private_common_type
  {
    template <typename T1, typename T2>
    using conditional_result_t = decltype(false ? declval<T1>() : declval<T2>());

    template <typename, typename, typename = void>
    struct decay_conditional_result
    {
    };

    template <typename T1, typename T2>
    struct decay_conditional_result<T1, T2, void_t<conditional_result_t<T1, T2>>>
      : etl::decay<conditional_result_t<T1, T2>>
    {
    };

    template <typename T1, typename T2, typename = void>
    struct common_type_2_impl
      : decay_conditional_result<const T1&, const T2&>
    {
    };

    template <typename T1, typename T2>
    struct common_type_2_impl<T1, T2, void_t<conditional_result_t<T1, T2>>>
      : decay_conditional_result<T1, T2>
    {
    };
  }



  template <typename T1, typename T2>
  struct common_type<T1, T2>
    : etl::conditional<etl::is_same<T1, typename etl::decay<T1>::type>::value&& etl::is_same<T2, typename etl::decay<T2>::type>::value,
                       private_common_type::common_type_2_impl<T1, T2>,
                       common_type<typename etl::decay<T2>::type,
                       typename etl::decay<T2>::type>>::type
  {
  };



  namespace private_common_type
  {
    template <typename AlwaysVoid, typename T1, typename T2, typename... TRest>
    struct common_type_multi_impl
    {
    };

    template <typename T1, typename T2, typename... TRest>
    struct common_type_multi_impl<void_t<typename common_type<T1, T2>::type>, T1, T2, TRest...>
      : common_type<typename common_type<T1, T2>::type, TRest...>
    {
    };
  }

  template<typename T1, typename T2, typename... TRest>
  struct common_type<T1, T2, TRest...>
    : private_common_type::common_type_multi_impl<void, T1, T2, TRest...>
  {
  };

  template <typename... T>
  using common_type_t = typename common_type<T...>::type;





  template <typename T>
  struct unsigned_type
  {
    typedef typename etl::conditional<sizeof(T) == sizeof(unsigned char), unsigned char,
      typename etl::conditional<sizeof(T) == sizeof(unsigned short), unsigned short,
        typename etl::conditional<sizeof(T) == sizeof(unsigned int), unsigned int,
          typename etl::conditional<sizeof(T) == sizeof(unsigned long), unsigned long,
            unsigned long long>::type>::type>::type>::type type;
  };


  template <typename T>
  using unsigned_type_t = typename unsigned_type<T>::type;





  template <typename T>
  struct signed_type
  {
    typedef typename etl::conditional<sizeof(T) == sizeof(char), char,
      typename etl::conditional<sizeof(T) == sizeof(short), short,
        typename etl::conditional<sizeof(T) == sizeof(int), int,
          typename etl::conditional<sizeof(T) == sizeof(long), long,
            long long>::type>::type>::type>::type type;
  };


  template <typename T>
  using signed_type_t = typename signed_type<T>::type;





  template <typename T>
  struct type_identity { typedef T type; };


  template <typename T>
  using type_identity_t = typename type_identity<T>::type;






  template <typename T, bool = etl::is_enum<T>::value>
  struct underlying_type;


  template <typename T>
  struct underlying_type<T, false>
  {

    static_assert(etl::is_enum<T>::value, "etl::underlying_type can only be used with enumeration types.");
  };

  template <typename T>
  struct underlying_type<T, true>
  {
    typedef __underlying_type(T) type;
  };
# 2424 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h"
  template <typename T>
  using underlying_type_t = typename underlying_type<T>::type;





  template <typename... TTypes>
  struct has_duplicates;

  template <typename TFirst, typename... TRest>
  struct has_duplicates<TFirst, TRest...> : etl::conditional_t<etl::is_one_of<TFirst, TRest...>::value,
                                                               etl::true_type,
                                                               has_duplicates<TRest...>> {};

  template <typename T>
  struct has_duplicates<T> : etl::false_type {};

  template <>
  struct has_duplicates<> : etl::false_type {};



  template <typename... TTypes>
  inline constexpr bool has_duplicates_v = etl::has_duplicates<TTypes...>::value;





  template <typename T, typename... TTypes>
  struct count_of;

  template <typename T, typename U, typename... URest>
  struct count_of<T, U, URest...> : etl::integral_constant<size_t,
                                                            etl::is_same<T, U>::value +
                                                              count_of<T, URest...>::value> {};

  template <typename T>
  struct count_of<T> : etl::integral_constant<size_t, 0> {};



  template <typename T, typename... TTypes>
  inline constexpr size_t count_of_v = etl::count_of<T, TTypes...>::value;





  template <typename T, template <typename...> class Template>
  struct is_specialization : etl::false_type {};

  template <template <typename...> class Template, typename... TArgs>
  struct is_specialization<Template<TArgs...>, Template> : etl::true_type {};



  template <typename T, template <typename...> class Template>
  inline constexpr bool is_specialization_v = etl::is_specialization<T, Template>::value;




  constexpr inline bool is_constant_evaluated()
  {

    if consteval
    {
      return true;
    }
    else
    {
      return false;
    }







  }
}


#define ETL_IS_CHAR_TYPE(type) (etl::is_same<char, type>::value || etl::is_same<signed char, type>::value || etl::is_same<unsigned char, type>::value)
#define ETL_IS_NOT_CHAR_TYPE(type) (!ETL_IS_CHAR_TYPE(type))

#define ETL_IS_POINTER_TYPE(type) (etl::is_pointer<type>::value)
#define ETL_IS_NOT_POINTER_TYPE(type) (!ETL_IS_POINTER_TYPE(type))

#define ETL_TARGET_IS_TRIVIALLY_COPYABLE(type) (etl::is_trivially_copyable<typename etl::iterator_traits<type>::value_type>::value)
#define ETL_TARGET_IS_NOT_TRIVIALLY_COPYABLE(type) (!ETL_TARGET_IS_TRIVIALLY_COPYABLE(type))
# 43 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h"
#define ETL_ITERATOR_INCLUDED 


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
#define ETL_UTILITY_INCLUDED 


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/tuple_element.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/tuple_element.h"
#define ETL_TUPLE_ELEMENT_INCLUDED 

namespace etl
{


  template <size_t Index, typename TType>
  struct tuple_element;


  template<size_t Index, typename TType>
  struct tuple_element<Index, const TType>
  {
    using type = typename etl::add_const_t<typename etl::tuple_element<Index, TType>::type>;
  };


  template <size_t Index, typename TType>
  using tuple_element_t = typename tuple_element<Index, TType>::type;

}
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/tuple_size.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/tuple_size.h"
#define ETL_TUPLE_SIZE_INCLUDED 

namespace etl
{

  template <typename T>
  struct tuple_size;


  template <typename T>
  struct tuple_size<const T> : etl::integral_constant<size_t, tuple_size<T>::value>
  {
  };



  template <typename T>
  inline constexpr size_t tuple_size_v = tuple_size<T>::value;

}
# 39 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h" 2
# 51 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
namespace etl
{


  template <typename T>
  constexpr typename etl::remove_reference<T>::type&& move(T&& t)
  {
    return static_cast<typename etl::remove_reference<T>::type&&>(t);
  }


  template <typename T>
  constexpr T&& forward(typename etl::remove_reference<T>::type& t)
  {
    return static_cast<T&&>(t);
  }

  template <typename T>
  constexpr T&& forward(typename etl::remove_reference<T>::type&& t)
  {
    static_assert(!etl::is_lvalue_reference<T>::value, "Invalid rvalue to lvalue conversion");
    return static_cast<T&&>(t);
  }
# 85 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
  template <typename T, typename U>
  [[nodiscard]]
  constexpr
  etl::enable_if_t<etl::is_const<etl::remove_reference_t<T>>::value && etl::is_lvalue_reference<T>::value, const etl::remove_reference_t<U>&>
    forward_like(U&& u)
  {
    return static_cast<const etl::remove_reference_t<U>&>(u);
  }




  template <typename T, typename U>
  [[nodiscard]]
  constexpr
  etl::enable_if_t<etl::is_const<etl::remove_reference_t<T>>::value && !etl::is_lvalue_reference<T>::value, const etl::remove_reference_t<U>&&>
    forward_like(U&& u)
  {
    return static_cast<const etl::remove_reference_t<U>&&>(u);
  }




  template <typename T, typename U>
  [[nodiscard]]
  constexpr
  etl::enable_if_t<!etl::is_const<etl::remove_reference_t<T>>::value && etl::is_lvalue_reference<T>::value, etl::remove_reference_t<U>&>
    forward_like(U&& u)
  {
    return static_cast<etl::remove_reference_t<U>&>(u);
  }




  template <typename T, typename U>
  [[nodiscard]]
  constexpr
  etl::enable_if_t<!etl::is_const<etl::remove_reference_t<T>>::value && !etl::is_lvalue_reference<T>::value, etl::remove_reference_t<U>&&>
    forward_like(U&& u)
  {
    return static_cast<etl::remove_reference_t<U>&&>(u);
  }




  template <typename T, typename U>
  using forward_like_t = decltype(etl::forward_like<T>(etl::declval<U&>()));





  template <typename T>
  constexpr typename underlying_type<T>::type to_underlying(T value)
  {
    return static_cast<typename underlying_type<T>::type>(value);
  }






  template <typename T>
  constexpr void swap(T& a, T& b)
  {
    T temp(etl::move(a));
    a = etl::move(b);
    b = etl::move(temp);
  }

  template< class T, size_t Size >
  constexpr void swap(T(&a)[Size], T(&b)[Size])
  {
    for (size_t i = 0UL; i < Size; ++i)
    {
      swap(a[i], b[i]);
    }
  }







  template <typename T1, typename T2>
  struct pair
  {
    typedef T1 first_type;
    typedef T2 second_type;

    T1 first;
    T2 second;






    constexpr pair()
      : first(T1())
      , second(T2())
    {
    }






    constexpr pair(const T1& a, const T2& b)
      : first(a)
      , second(b)
    {
    }





    template <typename U1, typename U2>
    constexpr pair(U1&& a, U2&& b)
      : first(etl::forward<U1>(a))
      , second(etl::forward<U2>(b))
    {
    }







    template <typename U1, typename U2>
    constexpr pair(const pair<U1, U2>& other)
      : first(other.first)
      , second(other.second)
    {
    }


    pair(const pair<T1, T2>& other)
      : first(other.first)
      , second(other.second)
    {
    }



    template <typename U1, typename U2>
    constexpr pair(pair<U1, U2>&& other)
      : first(etl::forward<U1>(other.first))
      , second(etl::forward<U2>(other.second))
    {
    }
# 273 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
    void swap(pair<T1, T2>& other)
    {
      using etl::swap;

      swap(first, other.first);
      swap(second, other.second);
    }

    pair<T1, T2>& operator =(const pair<T1, T2>& other)
    {
      first = other.first;
      second = other.second;

      return *this;
    }

    template <typename U1, typename U2>
    pair<U1, U2>& operator =(const pair<U1, U2>& other)
    {
      first = other.first;
      second = other.second;

      return *this;
    }


    pair<T1, T2>& operator =(pair<T1, T2>&& other)
    {
      first = etl::forward<T1>(other.first);
      second = etl::forward<T2>(other.second);

      return *this;
    }

    template <typename U1, typename U2>
    pair<U1, U2>& operator =(pair<U1, U2>&& other)
    {
      first = etl::forward<U1>(other.first);
      second = etl::forward<U2>(other.second);

      return *this;
    }

  };
# 327 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
  template <typename T1, typename T2>
  inline pair<T1, T2> make_pair(T1&& a, T2&& b)
  {
    return pair<T1, T2>(etl::forward<T1>(a), etl::forward<T2>(b));
  }
# 342 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
  template <size_t Index, typename T1, typename T2>
  struct tuple_element<Index, etl::pair<T1, T2> >
  {
    static_assert(Index < 2U, "pair has only 2 elements");
  };

  template <typename T1, typename T2>
  struct tuple_element<0U, etl::pair<T1, T2> >
  {
    typedef T1 type;
  };

  template <typename T1, typename T2>
  struct tuple_element<1U, etl::pair<T1, T2> >
  {
    typedef T2 type;
  };


  template <typename T1, typename T2>
  struct tuple_size<etl::pair<T1, T2>> : public etl::integral_constant<size_t, 2U>
  {
  };



  template <typename T1, typename T2>
  inline void swap(pair<T1, T2>& a, pair<T1, T2>& b)
  {
    a.swap(b);
  }


  template <typename T1, typename T2>
  inline bool operator ==(const pair<T1, T2>& a, const pair<T1, T2>& b)
  {
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
# 379 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h" 2
    return (a.first == b.first) && !(a.second < b.second) && !(a.second > b.second);
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 381 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h" 2
  }


  template <typename T1, typename T2>
  inline bool operator !=(const pair<T1, T2>& a, const pair<T1, T2>& b)
  {
    return !(a == b);
  }

  template <typename T1, typename T2>
  inline bool operator <(const pair<T1, T2>& a, const pair<T1, T2>& b)
  {
    return (a.first < b.first) ||
      (!(b.first < a.first) && (a.second < b.second));
  }


  template <typename T1, typename T2>
  inline bool operator >(const pair<T1, T2>& a, const pair<T1, T2>& b)
  {
    return (b < a);
  }


  template <typename T1, typename T2>
  inline bool operator <=(const pair<T1, T2>& a, const pair<T1, T2>& b)
  {
    return !(b < a);
  }


  template <typename T1, typename T2>
  inline bool operator >=(const pair<T1, T2>& a, const pair<T1, T2>& b)
  {
    return !(a < b);
  }
# 430 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
  template <typename TPair>
  struct select1st
  {
    typedef typename TPair::first_type type;





    type& operator()(TPair& p) const
    {
      return p.first;
    }




    const type& operator()(const TPair& p) const
    {
      return p.first;
    }
  };
# 465 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
  template <typename TPair>
  struct select2nd
  {
    typedef typename TPair::second_type type;





    type& operator()(TPair& p) const
    {
      return p.second;
    }




    const type& operator()(const TPair& p) const
    {
      return p.second;
    }
  };





  template <typename T>
  T exchange(T& object, const T& new_value)
  {
    T old_value = object;
    object = new_value;
    return old_value;
  }

  template <typename T, typename U>
  T exchange(T& object, const U& new_value)
  {
    T old_value = object;
    object = new_value;
    return old_value;
  }
# 521 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
  template <typename T>
  typename etl::add_const<T>::type& as_const(T& t)
  {
    return t;
  }





  template <typename T, T... Integers>
  class integer_sequence
  {
  public:

    static_assert(etl::is_integral<T>::value, "Integral types only");

    typedef T value_type;

    static constexpr size_t size()
    {
      return sizeof...(Integers);
    }
  };

  namespace private_integer_sequence
  {
    template <size_t Count, typename IndexSeq>
    struct make_index_sequence;

    template <size_t Count, size_t... Indices>
    struct make_index_sequence<Count, etl::integer_sequence<size_t, Indices...>>
    {
      using type = typename make_index_sequence<Count - 1, etl::integer_sequence<size_t, Count - 1, Indices...>>::type;
    };

    template <size_t... Indices>
    struct make_index_sequence<0, etl::integer_sequence<size_t, Indices...>>
    {
      using type = etl::integer_sequence<size_t, Indices...>;
    };
  }


  template <size_t Count>
  using make_index_sequence = typename private_integer_sequence::make_index_sequence<Count, etl::integer_sequence<size_t>>::type;

  template <typename... TTypes>
  using make_index_sequence_for = typename private_integer_sequence::make_index_sequence<sizeof...(TTypes), etl::integer_sequence<size_t>>::type;


  template <size_t... Indices>
  using index_sequence = etl::integer_sequence<size_t, Indices...>;

  template <typename... TTypes>
  using index_sequence_for = typename etl::make_index_sequence_for<TTypes...>;





  template <typename T>
  struct coordinate_2d
  {
    coordinate_2d()
      : x(T(0))
      , y(T(0))
    {
    }

    coordinate_2d(T x_, T y_)
      : x(x_)
      , y(y_)
    {
    }

    friend bool operator ==(const coordinate_2d& lhs, const coordinate_2d& rhs)
    {
      return (lhs.x == rhs.x) && (lhs.y == rhs.y);
    }

    friend bool operator !=(const coordinate_2d& lhs, const coordinate_2d& rhs)
    {
      return !(lhs == rhs);
    }

    T x;
    T y;
  };






  struct in_place_t
  {
    explicit constexpr in_place_t() {}
  };


  inline constexpr in_place_t in_place{};



  template <typename T> struct in_place_type_t
  {
    explicit constexpr in_place_type_t() {}
  };


  template <typename T>
  inline constexpr in_place_type_t<T> in_place_type{};



  template <size_t Index> struct in_place_index_t
  {
    explicit constexpr in_place_index_t() {}
  };


  template <size_t Index>
  inline constexpr in_place_index_t<Index> in_place_index{};
# 654 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
  template <typename TReturn, typename... TParams>
  class [[deprecated]] functor
  {
  public:




    constexpr functor(TReturn(*ptr_)(TParams...))
      : ptr(ptr_)
    {
    }




    constexpr TReturn operator()(TParams... args) const
    {
      return ptr(etl::forward<TParams>(args)...);
    }

  private:


    TReturn(*ptr)(TParams...);
  };







  template <typename T>
  class member_function_wrapper;

  template <typename TReturn, typename... TParams>
  class [[deprecated]] member_function_wrapper<TReturn(TParams...)>
  {
  public:

    template <typename T, T& Instance, TReturn(T::* Method)(TParams...)>
    static constexpr TReturn function(TParams... params)
    {
      return (Instance.*Method)(etl::forward<TParams>(params)...);
    }
  };







  template <typename T>
  class functor_wrapper;

  template <typename TReturn, typename... TParams>
  class functor_wrapper<TReturn(TParams...)>
  {
  public:

    template <typename TFunctor, TFunctor& Instance>
    static constexpr TReturn function(TParams... params)
    {
      return Instance(etl::forward<TParams>(params)...);
    }
  };







  template <auto& Instance>
  struct functor_as_static
  {
    template <typename... TArgs>
    static constexpr auto call(TArgs&&... args)
    {
      return (Instance.operator())(etl::forward<TArgs>(args)...);
    }
  };





  template <auto Method, auto& Instance>
  struct member_function_as_static
  {
    template <typename... TArgs>
    static constexpr auto call(TArgs&&... args)
    {
      return (Instance.*Method)(etl::forward<TArgs>(args)...);
    }
  };





  template <auto Method, auto& Instance>
  class member_function_as_functor
  {
  public:

    template <typename... TArgs>
    constexpr auto operator()(TArgs&&... args) const -> decltype((Instance.*Method)(etl::forward<TArgs>(args)...))
    {
      return (Instance.*Method)(etl::forward<TArgs>(args)...);
    }
  };





  template <auto Function>
  class function_as_functor
  {
  public:

    template<typename... TArgs>
    constexpr auto operator()(TArgs&&... args) const -> decltype(Function(etl::forward<TArgs>(args)...))
    {
      return Function(etl::forward<TArgs>(args)...);
    }
  };







  template <typename T>
  class function_ptr_as_functor;

  template <typename TReturn, typename... TArgs>
  class function_ptr_as_functor<TReturn(TArgs...)>
  {
  public:




    constexpr function_ptr_as_functor(TReturn(*ptr_)(TArgs...))
      : ptr(ptr_)
    {
    }




    constexpr TReturn operator()(TArgs... args) const
    {
      return ptr(etl::forward<TArgs>(args)...);
    }

  private:


    TReturn(*ptr)(TArgs...);
  };






  template <auto Value>
  struct nontype_t
  {
    static constexpr decltype(Value) value = Value;
  };
# 841 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/utility.h"
}
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/addressof.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/addressof.h"
#define ETL_ADDRESSOF_INCLUDED 

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/../platform.h" 1
# 35 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/addressof.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/../type_traits.h" 1
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/addressof.h" 2
# 44 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/addressof.h"
namespace etl
{





  template <typename T>
  constexpr typename etl::enable_if<!etl::is_same<T, etl::nullptr_t>::value, T>::type* addressof(T& t)
  {



    return reinterpret_cast<T*>(&const_cast<char&>(reinterpret_cast<const volatile char&>(t)));

  }
}
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h" 2
# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h"
namespace etl
{


  struct input_iterator_tag {};
  struct output_iterator_tag {};
  struct forward_iterator_tag : public input_iterator_tag {};
  struct bidirectional_iterator_tag : public forward_iterator_tag {};
  struct random_access_iterator_tag : public bidirectional_iterator_tag {};






  template <typename TIterator, typename = typename etl::enable_if<!etl::is_fundamental<TIterator>::value, void>::type>
  struct iterator_traits
  {
    typedef typename TIterator::iterator_category iterator_category;
    typedef typename TIterator::value_type value_type;
    typedef typename TIterator::difference_type difference_type;
    typedef typename TIterator::pointer pointer;
    typedef typename TIterator::reference reference;
  };


  template <typename T>
  struct iterator_traits<T*, void>
  {
    typedef etl::random_access_iterator_tag iterator_category;
    typedef T value_type;
    typedef ptrdiff_t difference_type;
    typedef typename etl::remove_cv<T>::type* pointer;
    typedef T& reference;
  };


  template <typename T>
  struct iterator_traits<const T*, void>
  {
    typedef etl::random_access_iterator_tag iterator_category;
    typedef T value_type;
    typedef ptrdiff_t difference_type;
    typedef const typename etl::remove_cv<T>::type* pointer;
    typedef const T& reference;
  };



  template <typename TIterator, typename TDistance>
  constexpr void advance_helper(TIterator& itr, TDistance n, etl::output_iterator_tag)
  {
    while (n--)
    {
      ++itr;
    }
  }

  template <typename TIterator, typename TDistance>
  constexpr void advance_helper(TIterator& itr, TDistance n, etl::forward_iterator_tag)
  {
    while (n--)
    {
      ++itr;
    }
  }

  template <typename TIterator, typename TDistance>
  constexpr void advance_helper(TIterator& itr, TDistance n, etl::bidirectional_iterator_tag)
  {
    if (n > 0)
    {
      while (n--)
      {
        ++itr;
      }
    }
    else
    {
      while (n++)
      {
        --itr;
      }
    }
  }

  template <typename TIterator, typename TDistance>
  constexpr void advance_helper(TIterator& itr, TDistance n, etl::random_access_iterator_tag)
  {
    itr += n;
  }

  template <typename TIterator, typename TDistance>
  constexpr void advance(TIterator& itr, TDistance n)
  {
    typedef typename etl::iterator_traits<TIterator>::iterator_category tag;

    advance_helper(itr, n, tag());
  }



  template<typename TIterator>
  constexpr typename etl::iterator_traits<TIterator>::difference_type distance_helper(TIterator first, TIterator last, etl::input_iterator_tag)
  {
    typename etl::iterator_traits<TIterator>::difference_type d = 0;

    while (first != last)
    {
      ++d;
      ++first;
    }

    return d;
  }

  template<typename TIterator>
  constexpr typename etl::iterator_traits<TIterator>::difference_type distance_helper(TIterator first, TIterator last, etl::forward_iterator_tag)
  {
    typename etl::iterator_traits<TIterator>::difference_type d = 0;

    while (first != last)
    {
      ++d;
      ++first;
    }

    return d;
  }

  template<typename TIterator>
  constexpr typename etl::iterator_traits<TIterator>::difference_type distance_helper(TIterator first, TIterator last, etl::bidirectional_iterator_tag)
  {
    typename etl::iterator_traits<TIterator>::difference_type d = 0;

    while (first != last)
    {
      ++d;
      ++first;
    }

    return d;
  }

  template<typename TIterator>
  constexpr typename etl::iterator_traits<TIterator>::difference_type distance_helper(TIterator first, TIterator last, etl::random_access_iterator_tag)
  {
    return last - first;
  }

  template<typename TIterator>
  constexpr typename etl::iterator_traits<TIterator>::difference_type distance(TIterator first, TIterator last)
  {
    typedef typename etl::iterator_traits<TIterator>::iterator_category tag;

    return distance_helper(first, last, tag());
  }



  template<typename TIterator>
  constexpr TIterator prev(TIterator itr, typename etl::iterator_traits<TIterator>::difference_type n = 1)
  {
    etl::advance(itr, -n);

    return itr;
  }



  template<typename TIterator>
  constexpr TIterator next(TIterator itr, typename etl::iterator_traits<TIterator>::difference_type n = 1)
  {
    etl::advance(itr, n);

    return itr;
  }



  template <typename TIterator>
  class reverse_iterator
  {
  public:

    typedef typename iterator_traits<TIterator>::iterator_category iterator_category;
    typedef typename iterator_traits<TIterator>::value_type value_type;
    typedef typename iterator_traits<TIterator>::difference_type difference_type;
    typedef typename iterator_traits<TIterator>::pointer pointer;
    typedef typename iterator_traits<TIterator>::reference reference;

    typedef TIterator iterator_type;

    constexpr reverse_iterator()
      : current()
    {
    }

    constexpr explicit reverse_iterator(TIterator itr)
      : current(itr)
    {
    }

    template <typename TOther>
    constexpr reverse_iterator(const reverse_iterator<TOther>& other)
      : current(other.base())
    {
    }

    template<class TOther>
    constexpr reverse_iterator& operator =(const reverse_iterator<TOther>& other)
    {
      current = other.base();

      return (*this);
    }

    constexpr TIterator base() const
    {
      return current;
    }

    [[nodiscard]] constexpr reference operator*() const
    {
      TIterator temp = current;

      return *(--temp);
    }

    [[nodiscard]] constexpr pointer operator->() const
    {
      TIterator temp = current;

      return &(*--temp);
    }

    constexpr reverse_iterator& operator++()
    {
      --current;

      return *this;
    }

    constexpr reverse_iterator operator++(int)
    {
      reverse_iterator temp = *this;
      --current;

      return temp;
    }

    constexpr reverse_iterator& operator--()
    {
      ++current;

      return (*this);
    }

    constexpr reverse_iterator operator--(int)
    {
      reverse_iterator temp = *this;
      ++current;

      return temp;
    }

    constexpr reverse_iterator& operator+=(const difference_type offset)
    {
      current -= offset;

      return (*this);
    }

    constexpr reverse_iterator& operator-=(const difference_type offset)
    {
      current += offset;

      return (*this);
    }

    [[nodiscard]] constexpr reverse_iterator operator+(const difference_type offset) const
    {
      return reverse_iterator(current - offset);
    }

    [[nodiscard]] constexpr reverse_iterator operator-(const difference_type offset) const
    {
      return (reverse_iterator(current + offset));
    }

    [[nodiscard]] constexpr reference operator[](const difference_type offset) const
    {
      return (*(*this + offset));
    }

  protected:

    TIterator current;
  };

  template <typename TIterator>
  constexpr bool operator ==(const reverse_iterator<TIterator>& lhs, const reverse_iterator<TIterator>& rhs)
  {
    return lhs.base() == rhs.base();
  }

  template <typename TIterator>
  constexpr bool operator !=(const reverse_iterator<TIterator>& lhs, const reverse_iterator<TIterator>& rhs)
  {
    return !(lhs == rhs);
  }

  template <typename TIterator>
  constexpr bool operator <(const reverse_iterator<TIterator>& lhs, const reverse_iterator<TIterator>& rhs)
  {
    return rhs.base() < lhs.base();
  }

  template <typename TIterator>
  constexpr bool operator >(const reverse_iterator<TIterator>& lhs, const reverse_iterator<TIterator>& rhs)
  {
    return rhs < lhs;
  }

  template <typename TIterator>
  constexpr bool operator <=(const reverse_iterator<TIterator>& lhs, const reverse_iterator<TIterator>& rhs)
  {
    return !(rhs < lhs);
  }

  template <typename TIterator>
  constexpr bool operator >=(const reverse_iterator<TIterator>& lhs, const reverse_iterator<TIterator>& rhs)
  {
    return !(lhs < rhs);
  }

  template <typename TIterator>
  constexpr typename reverse_iterator<TIterator>::difference_type operator -(const reverse_iterator<TIterator>& lhs, const reverse_iterator<TIterator>& rhs)
  {
    return rhs.base() - lhs.base();
  }

  template <typename TIterator, class TDifference>
  constexpr reverse_iterator<TIterator> operator +(TDifference n, const reverse_iterator<TIterator>& itr)
  {
    return itr.operator +(n);
  }




  template <typename TCategory, typename T, typename TDistance = ptrdiff_t, typename TPointer = T* , typename TReference = T& >
  struct iterator
  {
    typedef T value_type;
    typedef TDistance difference_type;
    typedef TPointer pointer;
    typedef TReference reference;
    typedef TCategory iterator_category;
  };




  template <typename TIterator>
  class move_iterator
  {
  public:

    typedef typename iterator_traits<TIterator>::iterator_category iterator_category;
    typedef typename iterator_traits<TIterator>::value_type value_type;
    typedef typename iterator_traits<TIterator>::difference_type difference_type;
    typedef TIterator iterator_type;
    typedef TIterator pointer;
    typedef value_type&& reference;

    move_iterator()
    {
    }

    explicit move_iterator(TIterator itr)
      : current(itr)
    {
    }

    template <typename U>
    move_iterator(const move_iterator<U>& itr)
      : current(itr.base())
    {
    }

    template <typename U>
    move_iterator& operator =(const move_iterator<U>& itr)
    {
      current = itr.current;
      return *this;
    }

    iterator_type base() const
    {
      return current;
    }

    pointer operator ->() const
    {
      return current;
    }

    reference operator *() const
    {
      return etl::move(*current);
    }

    move_iterator& operator++()
    {
      ++current;
      return *this;
    }

    move_iterator& operator--()
    {
      --current;
      return *this;
    }

    move_iterator operator++(int)
    {
      move_iterator temp = *this;
      ++current;
      return temp;
    }

    move_iterator operator--(int)
    {
      move_iterator temp = *this;
      --current;
      return temp;
    }

    move_iterator operator +(difference_type n) const
    {
      return move_iterator(current + n);
    }

    move_iterator operator -(difference_type n) const
    {
      return move_iterator(current - n);
    }

    move_iterator operator +=(difference_type n)
    {
      current += n;
      return *this;
    }

    move_iterator operator -=(difference_type n)
    {
      current -= n;
      return *this;
    }

    reference operator [](difference_type n) const
    {
      return etl::move(current[n]);
    }

  private:

    TIterator current;
  };

  template <typename TIterator>
  bool operator ==(const etl::move_iterator<TIterator>& lhs,
                   const etl::move_iterator<TIterator>& rhs)
  {
    return lhs.base() == rhs.base();
  }

  template <typename TIterator>
  bool operator !=(const etl::move_iterator<TIterator>& lhs,
                   const etl::move_iterator<TIterator>& rhs)
  {
    return !(lhs == rhs);
  }

  template <typename TIterator>
  bool operator <(const etl::move_iterator<TIterator>& lhs,
                  const etl::move_iterator<TIterator>& rhs)
  {
    return lhs.base() < rhs.base();
  }

  template <typename TIterator>
  bool operator <=(const etl::move_iterator<TIterator>& lhs,
                   const etl::move_iterator<TIterator>& rhs)
  {
    return !(rhs < lhs);
  }

  template <typename TIterator>
  bool operator >(const etl::move_iterator<TIterator>& lhs,
                  const etl::move_iterator<TIterator>& rhs)
  {
    return (rhs < lhs);
  }

  template <typename TIterator>
  bool operator >=(const etl::move_iterator<TIterator>& lhs,
                   const etl::move_iterator<TIterator>& rhs)
  {
    return !(lhs < rhs);
  }

  template <typename TIterator>
  move_iterator<TIterator> operator +(typename move_iterator<TIterator>::difference_type n,
                                      const move_iterator<TIterator>& rhs)
  {
    return rhs + n;
  }

  template <typename TIterator1, typename TIterator2 >
  auto operator -(const move_iterator<TIterator1>& lhs,
                  const move_iterator<TIterator2>& rhs) -> decltype(lhs.base() - rhs.base())
  {
    return lhs.base() - rhs.base();
  }

  template <typename TIterator>
  etl::move_iterator<TIterator> make_move_iterator(TIterator itr)
  {
    return etl::move_iterator<TIterator>(itr);
  }
# 588 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h"
  template <typename TContainer>
  class back_insert_iterator : public etl::iterator<etl::output_iterator_tag, void, void, void, void>
  {
  public:

    typedef TContainer container_type;




    explicit constexpr back_insert_iterator(TContainer& c)
      : container(etl::addressof(c))
    {
    }




    constexpr back_insert_iterator& operator =(const typename TContainer::value_type& value)
    {
      container->push_back(value);

      return (*this);
    }





    constexpr back_insert_iterator& operator =(typename TContainer::value_type&& value)
    {
      container->push_back(etl::move(value));

      return (*this);
    }





    [[nodiscard]] constexpr back_insert_iterator& operator *()
    {
      return (*this);
    }




    constexpr back_insert_iterator& operator ++()
    {
      return (*this);
    }




    constexpr back_insert_iterator operator ++(int)
    {
      return (*this);
    }

  protected:

    TContainer* container;
  };




  template <typename TContainer>
  [[nodiscard]]
  constexpr
  etl::back_insert_iterator<TContainer> back_inserter(TContainer& container)
  {
    return etl::back_insert_iterator<TContainer>(container);
  }
# 672 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h"
  template <typename TContainer>
  class front_insert_iterator : public etl::iterator<etl::output_iterator_tag, void, void, void, void>
  {
  public:

    typedef TContainer container_type;




    explicit constexpr front_insert_iterator(TContainer& c)
      : container(etl::addressof(c))
    {
    }




    constexpr front_insert_iterator& operator =(const typename TContainer::value_type& value)
    {
      container->push_front(value);
      return (*this);
    }





    constexpr front_insert_iterator& operator =(typename TContainer::value_type&& value)
    {
      container->push_front(etl::move(value));
      return (*this);
    }





    [[nodiscard]] constexpr front_insert_iterator& operator *()
    {
      return (*this);
    }




    constexpr front_insert_iterator& operator ++()
    {
      return (*this);
    }




    constexpr front_insert_iterator operator ++(int)
    {
      return (*this);
    }

  protected:

    TContainer* container;
  };




  template <typename TContainer>
  [[nodiscard]]
  constexpr
  etl::front_insert_iterator<TContainer> front_inserter(TContainer& container)
  {
    return etl::front_insert_iterator<TContainer>(container);
  }
# 754 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h"
  template <typename TContainer>
  class push_insert_iterator : public etl::iterator<etl::output_iterator_tag, void, void, void, void>
  {
  public:

    typedef TContainer container_type;




    explicit constexpr push_insert_iterator(TContainer& c)
      : container(etl::addressof(c))
    {
    }




    constexpr push_insert_iterator& operator =(const typename TContainer::value_type& value)
    {
      container->push(value);

      return (*this);
    }





    constexpr push_insert_iterator& operator =(typename TContainer::value_type&& value)
    {
      container->push(etl::move(value));

      return (*this);
    }





    [[nodiscard]] constexpr push_insert_iterator& operator *()
    {
      return (*this);
    }




    constexpr push_insert_iterator& operator ++()
    {
      return (*this);
    }




    constexpr push_insert_iterator operator ++(int)
    {
      return (*this);
    }

  protected:

    TContainer* container;
  };




  template <typename TContainer>
  [[nodiscard]]
    constexpr
    etl::push_insert_iterator<TContainer> push_inserter(TContainer& container)
  {
    return etl::push_insert_iterator<TContainer>(container);
  }




  template <typename T>
  struct is_input_iterator
  {
    static constexpr bool value = etl::is_same<typename etl::iterator_traits<T>::iterator_category, etl::input_iterator_tag>::value;
  };

  template <typename T>
  constexpr bool is_input_iterator<T>::value;

  template <typename T>
  struct is_output_iterator
  {
    static constexpr bool value = etl::is_same<typename etl::iterator_traits<T>::iterator_category, etl::output_iterator_tag>::value;
  };

  template <typename T>
  constexpr bool is_output_iterator<T>::value;

  template <typename T>
  struct is_forward_iterator
  {
    static constexpr bool value = etl::is_same<typename etl::iterator_traits<T>::iterator_category, etl::forward_iterator_tag>::value;
  };

  template <typename T>
  constexpr bool is_forward_iterator<T>::value;

  template <typename T>
  struct is_bidirectional_iterator
  {
    static constexpr bool value = etl::is_same<typename etl::iterator_traits<T>::iterator_category, etl::bidirectional_iterator_tag>::value;
  };

  template <typename T>
  constexpr bool is_bidirectional_iterator<T>::value;


  template <typename T>
  struct is_random_iterator
  {
    static constexpr bool value = etl::is_same<typename etl::iterator_traits<T>::iterator_category, etl::random_access_iterator_tag>::value;
  };

  template <typename T>
  constexpr bool is_random_iterator<T>::value;

  template <typename T>
  struct is_random_access_iterator
  {
    static constexpr bool value = etl::is_same<typename etl::iterator_traits<T>::iterator_category, etl::random_access_iterator_tag>::value;
  };

  template <typename T>
  constexpr bool is_random_access_iterator<T>::value;

  template <typename T>
  struct is_input_iterator_concept
  {
    static constexpr bool value = etl::is_input_iterator<T>::value ||
                                               etl::is_forward_iterator<T>::value ||
                                               etl::is_bidirectional_iterator<T>::value ||
                                               etl::is_random_iterator<T>::value;
  };

  template <typename T>
  constexpr bool is_input_iterator_concept<T>::value;

  template <typename T>
  struct is_output_iterator_concept
  {
    static constexpr bool value = etl::is_output_iterator<T>::value ||
                                               etl::is_forward_iterator<T>::value ||
                                               etl::is_bidirectional_iterator<T>::value ||
                                               etl::is_random_iterator<T>::value;
  };

  template <typename T>
  constexpr bool is_output_iterator_concept<T>::value;

  template <typename T>
  struct is_forward_iterator_concept
  {
    static constexpr bool value = etl::is_forward_iterator<T>::value ||
                                               etl::is_bidirectional_iterator<T>::value ||
                                               etl::is_random_iterator<T>::value;
  };

  template <typename T>
  constexpr bool is_forward_iterator_concept<T>::value;

  template <typename T>
  struct is_bidirectional_iterator_concept
  {
    static constexpr bool value = etl::is_bidirectional_iterator<T>::value ||
                                               etl::is_random_iterator<T>::value;
  };

  template <typename T>
  constexpr bool is_bidirectional_iterator_concept<T>::value;


  template <typename T>
  struct is_random_iterator_concept
  {
    static constexpr bool value = etl::is_random_iterator<T>::value;
  };


  template <typename T>
  constexpr bool is_random_iterator_concept<T>::value;


  template <typename T>
  struct is_random_access_iterator_concept
  {
    static constexpr bool value = etl::is_random_access_iterator<T>::value;
  };


  template <typename T>
  constexpr bool is_random_access_iterator_concept<T>::value;






  template<typename TContainer>
  constexpr typename TContainer::iterator begin(TContainer& container)
  {
    return container.begin();
  }





  template<typename TContainer>
  constexpr typename TContainer::const_iterator begin(const TContainer& container)
  {
    return container.begin();
  }





  template<typename TContainer>
  constexpr typename TContainer::const_iterator cbegin(const TContainer& container)
  {
    return container.cbegin();
  }





  template<typename TContainer>
  constexpr typename TContainer::iterator end(TContainer& container)
  {
    return container.end();
  }





  template<typename TContainer>
  constexpr typename TContainer::const_iterator end(const TContainer& container)
  {
    return container.end();
  }





  template<typename TContainer>
  constexpr typename TContainer::const_iterator cend(const TContainer& container)
  {
    return container.cend();
  }





  template<typename TValue, size_t Array_Size>
  constexpr TValue* begin(TValue(&data)[Array_Size])
  {
    return &data[0];
  }





  template<typename TValue, size_t Array_Size>
  constexpr const TValue* begin(const TValue(&data)[Array_Size])
  {
    return &data[0];
  }





  template<typename TValue, size_t Array_Size>
  constexpr const TValue* cbegin(const TValue(&data)[Array_Size])
  {
    return &data[0];
  }





  template<typename TValue, size_t Array_Size>
  constexpr TValue* end(TValue(&data)[Array_Size])
  {
    return &data[Array_Size];
  }





  template<typename TValue, size_t Array_Size>
  constexpr const TValue* end(const TValue(&data)[Array_Size])
  {
    return &data[Array_Size];
  }





  template<typename TValue, size_t Array_Size>
  constexpr const TValue* cend(const TValue(&data)[Array_Size])
  {
    return &data[Array_Size];
  }







  template<typename TContainer>
  constexpr typename TContainer::reverse_iterator rbegin(TContainer& container)
  {
    return container.rbegin();
  }





  template<typename TContainer>
  constexpr typename TContainer::const_reverse_iterator rbegin(const TContainer& container)
  {
    return container.rbegin();
  }





  template<typename TContainer>
  constexpr typename TContainer::const_reverse_iterator crbegin(const TContainer& container)
  {
    return container.crbegin();
  }





  template<typename TContainer>
  constexpr typename TContainer::reverse_iterator rend(TContainer& container)
  {
    return container.rend();
  }





  template<typename TContainer>
  constexpr typename TContainer::const_reverse_iterator rend(const TContainer& container)
  {
    return container.rend();
  }





  template<typename TContainer>
  constexpr typename TContainer::const_reverse_iterator crend(const TContainer& container)
  {
    return container.crend();
  }





  template<typename TValue, size_t Array_Size>
  etl::reverse_iterator<TValue*> rbegin(TValue(&data)[Array_Size])
  {
    return etl::reverse_iterator<TValue*>(&data[Array_Size]);
  }





  template<typename TValue, size_t Array_Size>
  constexpr etl::reverse_iterator<const TValue*> crbegin(const TValue(&data)[Array_Size])
  {
    return etl::reverse_iterator<const TValue*>(&data[Array_Size]);
  }





  template<typename TValue, size_t Array_Size>
  constexpr etl::reverse_iterator<TValue*> rend(TValue(&data)[Array_Size])
  {
    return etl::reverse_iterator<TValue*>(&data[0]);
  }





  template<typename TValue, size_t Array_Size>
  constexpr etl::reverse_iterator<const TValue*> crend(const TValue(&data)[Array_Size])
  {
    return etl::reverse_iterator<const TValue*>(&data[0]);
  }
# 1186 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h"
  template<typename TContainer>
  constexpr typename TContainer::size_type size(const TContainer& container)
  {
    return container.size();
  }





  template<typename TValue, size_t Array_Size>
  constexpr size_t size(TValue(&)[Array_Size])
  {
    return Array_Size;
  }
# 1210 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/iterator.h"
  template <typename T, size_t Array_Size>
  char(&array_size(T(&array)[Array_Size]))[Array_Size];

#define ETL_ARRAY_SIZE(a) sizeof(etl::array_size(a))
}
# 44 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/functional.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/functional.h"
#define ETL_FUNCTIONAL_INCLUDED 
# 43 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/functional.h"
namespace etl
{




  template <typename T>
  class reference_wrapper
  {
  public:

    typedef T type;

    constexpr explicit reference_wrapper(T& t_)
      : t(&t_)
    {
    }

    constexpr reference_wrapper(const reference_wrapper& rhs)
      : t(rhs.t)
    {
    }

    constexpr reference_wrapper<T>& operator = (const reference_wrapper& rhs)
    {
      t = rhs.t;
      return *this;
    }

    constexpr T& get() const
    {
      return *t;
    }

    constexpr operator T&() const
    {
      return *t;
    }

  private:

    T* t;
  };


  template <typename T>
  reference_wrapper<T> ref(T& t)
  {
    return reference_wrapper<T>(t);
  }


  template <typename T>
  reference_wrapper<T> ref(reference_wrapper<T> t)
  {
    return reference_wrapper<T>(t.get());
  }


  template <typename T>
  reference_wrapper<const T> cref(const T& t)
  {
    return reference_wrapper<const T>(t);
  }


  template <typename T>
  reference_wrapper<const T> cref(reference_wrapper<T> t)
  {
    return reference_wrapper<const T>(t.get());
  }




  template <class T>
  struct unwrap_reference
  {
    typedef T type;
  };

  template <typename T>
  struct unwrap_reference<etl::reference_wrapper<T> >
  {
    typedef T& type;
  };


  template <typename T>
  using unwrap_reference_t = typename unwrap_reference<T>::type;





  template <typename T>
  struct unwrap_ref_decay : etl::unwrap_reference<typename etl::decay<T>::type> {};


  template <typename T>
  using unwrap_ref_decay_t = typename unwrap_ref_decay<T>::type;





  template <typename TArgumentType, typename TResultType>
  struct unary_function
  {
    typedef TArgumentType argument_type;
    typedef TResultType result_type;
  };




  template <typename TFirstArgumentType, typename TSecondArgumentType, typename TResultType>
  struct binary_function
  {
    typedef TFirstArgumentType first_argument_type;
    typedef TSecondArgumentType second_argument_type;
    typedef TResultType result_type;
  };


  template <typename T = void>
  struct less : public etl::binary_function<T, T, bool>
  {
    typedef T value_type;

    constexpr bool operator()(const T &lhs, const T &rhs) const
    {
      return (lhs < rhs);
    }
  };


  template <>
  struct less<void> : public etl::binary_function<void, void, bool>
  {
    typedef int is_transparent;

    template <typename T1, typename T2>
    constexpr auto operator()(T1&& lhs, T2&& rhs) const -> decltype(static_cast<T1&&>(lhs) < static_cast<T2&&>(rhs))
    {
      return static_cast<T1&&>(lhs) < static_cast<T2&&>(rhs);
    }
  };



  template <typename T = void>
  struct less_equal : public etl::binary_function<T, T, bool>
  {
    typedef T value_type;

    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
      return !(rhs < lhs);
    }
  };


  template <>
  struct less_equal<void> : public etl::binary_function<void, void, bool>
  {
    typedef int is_transparent;

    template <typename T1, typename T2>
    constexpr auto operator()(T1&& lhs, T2&& rhs) const -> decltype(static_cast<T1&&>(lhs) < static_cast<T2&&>(rhs))
    {
      return !(static_cast<T1&&>(lhs) < static_cast<T2&&>(rhs));
    }
  };



  template <typename T = void>
  struct greater : public etl::binary_function<T, T, bool>
  {
    typedef T value_type;

    constexpr bool operator()(const T &lhs, const T &rhs) const
    {
      return (rhs < lhs);
    }
  };


  template <>
  struct greater<void> : public etl::binary_function<void, void, bool>
  {
    typedef int is_transparent;

    template <typename T1, typename T2>
    constexpr auto operator()(T1&& lhs, T2&& rhs) const -> decltype(static_cast<T1&&>(lhs) < static_cast<T2&&>(rhs))
    {
      return static_cast<T2&&>(rhs) < static_cast<T1&&>(lhs);
    }
  };



  template <typename T = void>
  struct greater_equal : public etl::binary_function<T, T, bool>
  {
    typedef T value_type;

    constexpr bool operator()(const T& lhs, const T& rhs) const
    {
      return !(lhs < rhs);
    }
  };


  template <>
  struct greater_equal<void> : public etl::binary_function<void, void, bool>
  {
    typedef int is_transparent;

    template <typename T1, typename T2>
    constexpr auto operator()(T1&& lhs, T2&& rhs) const -> decltype(static_cast<T1&&>(lhs) < static_cast<T2&&>(rhs))
    {
      return static_cast<T1&&>(rhs) < static_cast<T2&&>(lhs);
    }
  };



  template <typename T = void>
  struct equal_to : public etl::binary_function<T, T, bool>
  {
    typedef T value_type;

    constexpr bool operator()(const T &lhs, const T &rhs) const
    {
      return lhs == rhs;
    }
  };


  template <>
  struct equal_to<void> : public etl::binary_function<void, void, bool>
  {
    typedef void value_type;
    typedef int is_transparent;

    template <typename T1, typename T2>
    constexpr auto operator()(T1&& lhs, T2&& rhs) const -> decltype(static_cast<T1&&>(lhs) < static_cast<T2&&>(rhs))
    {
      return static_cast<T1&&>(lhs) == static_cast<T2&&>(rhs);
    }
  };



  template <typename T = void>
  struct not_equal_to : public etl::binary_function<T, T, bool>
  {
    typedef T value_type;

    constexpr bool operator()(const T &lhs, const T &rhs) const
    {
      return !(lhs == rhs);
    }
  };


  template <>
  struct not_equal_to<void> : public etl::binary_function<void, void, bool>
  {
    typedef int is_transparent;

    template <typename T1, typename T2>
    constexpr auto operator()(T1&& lhs, T2&& rhs) const -> decltype(static_cast<T1&&>(lhs) < static_cast<T2&&>(rhs))
    {
      return !(static_cast<T1&&>(lhs) == static_cast<T2&&>(rhs));
    }
  };



  template <typename TFunction>
  class binder1st : public etl::unary_function<typename TFunction::second_argument_type, typename TFunction::result_type>
  {
  protected:

    TFunction operation;
    typename TFunction::first_argument_type value;

  public:

    binder1st(const TFunction& f, const typename TFunction::first_argument_type& v)
      : operation(f), value(v)
    {
    }

    typename TFunction::result_type operator()(typename TFunction::second_argument_type& x) const
    {
      return operation(value, x);
    }

    typename TFunction::result_type operator()(const typename TFunction::second_argument_type& x) const
    {
      return operation(value, x);
    }
  };

  template <typename F, typename T>
  binder1st<F> bind1st(const F& f, const T& x)
  {
    return binder1st<F>(f, x);
  }


  template <typename TFunction >
  class binder2nd : public etl::unary_function<typename TFunction::first_argument_type, typename TFunction::result_type>
  {
  protected:
    TFunction operation;
    typename TFunction::second_argument_type value;
  public:
    binder2nd(const TFunction& f, const typename TFunction::second_argument_type& v)
      : operation(f), value(v)
    {
    }

    typename TFunction::result_type operator()(typename TFunction::first_argument_type& x) const
    {
      return operation(x, value);
    }

    typename TFunction::result_type operator()(const typename TFunction::first_argument_type& x) const
    {
      return operation(x, value);
    }
  };

  template <typename F, typename T>
  binder2nd<F> bind2nd(const F& f, const T& x)
  {
    return binder2nd<F>(f, x);
  }


  template <typename T = void>
  struct plus
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs + rhs;
    }
  };


  template <typename T = void>
  struct minus
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs - rhs;
    }
  };


  template <typename T = void>
  struct negate
  {
    typedef T argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs) const
    {
      return -lhs;
    }
  };


  template <typename T = void>
  struct multiplies
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs * rhs;
    }
  };


  template <typename T = void>
  struct divides
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs / rhs;
    }
  };


  template <typename T = void>
  struct modulus
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs % rhs;
    }
  };


  template <typename T = void>
  struct logical_and
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs && rhs;
    }
  };


  template <typename T = void>
  struct logical_or
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs || rhs;
    }
  };


  template <typename T = void>
  struct logical_not
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs) const
    {
      return !lhs;
    }
  };


  template <typename T = void>
  struct bit_and
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs & rhs;
    }
  };


  template <typename T = void>
  struct bit_or
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs | rhs;
    }
  };


  template <typename T = void>
  struct bit_xor
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs, const T& rhs) const
    {
      return lhs ^ rhs;
    }
  };


  template <typename T = void>
  struct bit_not
  {
    typedef T first_argument_type;
    typedef T second_argument_type;
    typedef T result_type;

    constexpr T operator()(const T& lhs) const
    {
      return ~lhs;
    }
  };


  namespace private_functional
  {

    template<typename TReturnType, typename TClassType, typename... TArgs>
    class mem_fn_impl
    {
    public:

      typedef TReturnType(TClassType::* MemberFunctionType)(TArgs...);

      constexpr mem_fn_impl(MemberFunctionType member_function_)
        : member_function(member_function_)
      {
      }

      constexpr TReturnType operator()(TClassType& instance, TArgs... args) const
      {
        return (instance.*member_function)(etl::forward<TArgs>(args)...);
      }

    private:

      MemberFunctionType member_function;
    };


    template<typename TReturnType, typename TClassType, typename... TArgs>
    class const_mem_fn_impl
    {
    public:

      typedef TReturnType(TClassType::* MemberFunctionType)(TArgs...) const;

      constexpr const_mem_fn_impl(MemberFunctionType member_function_)
        : member_function(member_function_)
      {
      }

      constexpr TReturnType operator()(const TClassType& instance, TArgs... args) const
      {
        return (instance.*member_function)(etl::forward<TArgs>(args)...);
      }

    private:

      MemberFunctionType member_function;
    };
  }


  template<typename TReturnType, typename TClassType, typename... TArgs>
  constexpr
  private_functional::mem_fn_impl<TReturnType, TClassType, TArgs...> mem_fn(TReturnType(TClassType::* member_function)(TArgs...))
  {
    return private_functional::mem_fn_impl<TReturnType, TClassType, TArgs...>(member_function);
  }


  template<typename TReturnType, typename TClassType, typename... TArgs>
  constexpr
  private_functional::const_mem_fn_impl<TReturnType, TClassType, TArgs...> mem_fn(TReturnType(TClassType::* member_function)(TArgs...) const)
  {
    return private_functional::const_mem_fn_impl<TReturnType, TClassType, TArgs...>(member_function);
  }

}
# 45 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/largest.h" 1
# 54 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/largest.h"
#define ETL_LARGEST_INCLUDED 





# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 61 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/largest.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h" 1
# 54 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
#define ETL_SMALLEST_INCLUDED 


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
#define ETL_INTEGRAL_LIMITS_INCLUDED 


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 2

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 2
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 1 3 4
# 39 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
             
             
# 56 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
#define ETL_PUSHED_MIN_MAX 
# 41 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 2
# 49 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
#define LLONG_MAX 9223372036854775807LL



#define LLONG_MIN (-LLONG_MAX - 1LL)



#define ULLONG_MAX 18446744073709551615ULL


namespace etl
{
  namespace private_integral_limits
  {
# 75 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
    template <typename T = void>
    struct statics_signed_char
    {
      typedef signed char value_type;

      static constexpr signed char min = 
# 80 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                                 (-0x7f - 1)
# 80 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                          ;
      static constexpr signed char max = 0x7f
# 81 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                          ;
      static constexpr int bits = 8
# 82 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                         ;
      static constexpr bool is_signed = etl::is_signed<signed char>::value;
    };

    template <typename T>
    constexpr signed char statics_signed_char<T>::min;

    template <typename T>
    constexpr signed char statics_signed_char<T>::max;

    template <typename T>
    constexpr int statics_signed_char<T>::bits;

    template <typename T>
    constexpr bool statics_signed_char<T>::is_signed;



    template <typename T = void>
    struct statics_unsigned_char
    {
      typedef unsigned char value_type;

      static constexpr unsigned char min = 0;
      static constexpr unsigned char max = 
# 106 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                                   (0x7f * 2 + 1)
# 106 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                            ;
      static constexpr int bits = 8
# 107 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                           ;
      static constexpr bool is_signed = etl::is_signed<unsigned char>::value;
    };

    template <typename T>
    constexpr unsigned char statics_unsigned_char<T>::min;

    template <typename T>
    constexpr unsigned char statics_unsigned_char<T>::max;

    template <typename T>
    constexpr int statics_unsigned_char<T>::bits;

    template <typename T>
    constexpr bool statics_unsigned_char<T>::is_signed;



    template <typename T = void>
    struct statics_char
    {
      typedef char value_type;

      static constexpr char min = (etl::is_signed<char>::value) ? 
# 130 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                                                          (-0x7f - 1) 
# 130 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                                                    : 0;
      static constexpr char max = (etl::is_signed<char>::value) ? 0x7f 
# 131 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                                                    : static_cast<char>(
# 131 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                                                                                        (0x7f * 2 + 1)
# 131 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                                                                                 );
      static constexpr int bits = 8
# 132 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                  ;
      static constexpr bool is_signed = etl::is_signed<char>::value;
    };

    template <typename T>
    constexpr char statics_char<T>::min;

    template <typename T>
    constexpr char statics_char<T>::max;

    template <typename T>
    constexpr int statics_char<T>::bits;

    template <typename T>
    constexpr bool statics_char<T>::is_signed;



    template <typename T = void>
    struct statics_wchar_t
    {
      typedef wchar_t value_type;

      static constexpr wchar_t min = (-0x7fffffff - 1)
# 155 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                      ;
      static constexpr wchar_t max = 0x7fffffff
# 156 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                      ;
      static constexpr int bits = 8 
# 157 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                      * sizeof(wchar_t);
      static constexpr bool is_signed = etl::is_signed<wchar_t>::value;
    };

    template <typename T>
    constexpr wchar_t statics_wchar_t<T>::min;

    template <typename T>
    constexpr wchar_t statics_wchar_t<T>::max;

    template <typename T>
    constexpr int statics_wchar_t<T>::bits;

    template <typename T>
    constexpr bool statics_wchar_t<T>::is_signed;
# 180 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
    template <typename T = void>
    struct statics_short
    {
      typedef short value_type;

      static constexpr short min = 
# 185 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                           (-0x7fff - 1)
# 185 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                   ;
      static constexpr short max = 0x7fff
# 186 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                   ;
      static constexpr int bits = 8 
# 187 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                    * (sizeof(short) / sizeof(char));
      static constexpr bool is_signed = etl::is_signed<short>::value;
    };

    template <typename T>
    constexpr short statics_short<T>::min;

    template <typename T>
    constexpr short statics_short<T>::max;

    template <typename T>
    constexpr int statics_short<T>::bits;

    template <typename T>
    constexpr bool statics_short<T>::is_signed;







    template <typename T = void>
    struct statics_unsigned_short
    {
      typedef unsigned short value_type;

      static constexpr unsigned short min = 0;
      static constexpr unsigned short max = 
# 215 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                                    (0x7fff * 2 + 1)
# 215 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                             ;
      static constexpr int bits = 8 
# 216 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                             * (sizeof(unsigned short) / sizeof(char));
      static constexpr bool is_signed = etl::is_signed<unsigned short>::value;
    };

    template <typename T>
    constexpr unsigned short statics_unsigned_short<T>::min;

    template <typename T>
    constexpr unsigned short statics_unsigned_short<T>::max;

    template <typename T>
    constexpr int statics_unsigned_short<T>::bits;

    template <typename T>
    constexpr bool statics_unsigned_short<T>::is_signed;



    template <typename T = void>
    struct statics_int
    {
      typedef int value_type;

      static constexpr int min = 
# 239 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                          (-0x7fffffff - 1)
# 239 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                 ;
      static constexpr int max = 0x7fffffff
# 240 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                 ;
      static constexpr int bits = 8 
# 241 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                   * (sizeof(int) / sizeof(char));
      static constexpr bool is_signed = etl::is_signed<int>::value;
    };

    template <typename T>
    constexpr int statics_int<T>::min;

    template <typename T>
    constexpr int statics_int<T>::max;

    template <typename T>
    constexpr int statics_int<T>::bits;

    template <typename T>
    constexpr bool statics_int<T>::is_signed;



    template <typename T = void>
    struct statics_unsigned_int
    {
      typedef unsigned int value_type;

      static constexpr unsigned int min = 0;
      static constexpr unsigned int max = 
# 265 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                                  (0x7fffffff * 2U + 1U)
# 265 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                          ;
      static constexpr int bits = 8 
# 266 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                           * (sizeof(unsigned int) / sizeof(char));
      static constexpr bool is_signed = etl::is_signed<unsigned int>::value;
    };

    template <typename T>
    constexpr unsigned int statics_unsigned_int<T>::min;

    template <typename T>
    constexpr unsigned int statics_unsigned_int<T>::max;

    template <typename T>
    constexpr int statics_unsigned_int<T>::bits;

    template <typename T>
    constexpr bool statics_unsigned_int<T>::is_signed;



    template <typename T = void>
    struct statics_long
    {
      typedef long value_type;

      static constexpr long min = 
# 289 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                          (-0x7fffffffL - 1L)
# 289 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                  ;
      static constexpr long max = 0x7fffffffL
# 290 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                  ;
      static constexpr int bits = 8 
# 291 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                   * (sizeof(long) / sizeof(char));
      static constexpr bool is_signed = etl::is_signed<long>::value;
    };

    template <typename T>
    constexpr long statics_long<T>::min;

    template <typename T>
    constexpr long statics_long<T>::max;

    template <typename T>
    constexpr int statics_long<T>::bits;

    template <typename T>
    constexpr bool statics_long<T>::is_signed;



    template <typename T = void>
    struct statics_unsigned_long
    {
      typedef unsigned long value_type;

      static constexpr unsigned long min = 0;
      static constexpr unsigned long max = 
# 315 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                                   (0x7fffffffL * 2UL + 1UL)
# 315 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                            ;
      static constexpr int bits = 8 
# 316 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                            * (sizeof(unsigned long) / sizeof(char));
      static constexpr bool is_signed = etl::is_signed<unsigned long>::value;
    };

    template <typename T>
    constexpr unsigned long statics_unsigned_long<T>::min;

    template <typename T>
    constexpr unsigned long statics_unsigned_long<T>::max;

    template <typename T>
    constexpr int statics_unsigned_long<T>::bits;

    template <typename T>
    constexpr bool statics_unsigned_long<T>::is_signed;



    template <typename T = void>
    struct statics_long_long
    {
      typedef long long value_type;

      static constexpr long long min = (-9223372036854775807LL - 1LL);
      static constexpr long long max = 9223372036854775807LL;
      static constexpr int bits = 8 
# 341 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                        * (sizeof(long long) / sizeof(char));
      static constexpr bool is_signed = etl::is_signed<long long>::value;
    };

    template <typename T>
    constexpr long long statics_long_long<T>::min;

    template <typename T>
    constexpr long long statics_long_long<T>::max;

    template <typename T>
    constexpr int statics_long_long<T>::bits;

    template <typename T>
    constexpr bool statics_long_long<T>::is_signed;



    template <typename T = void>
    struct statics_unsigned_long_long
    {
      typedef unsigned long value_type;

      static constexpr unsigned long long min = 0;
      static constexpr unsigned long long max = 18446744073709551615ULL;
      static constexpr int bits = 8 
# 366 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                                 * (sizeof(unsigned long long) / sizeof(char));
      static constexpr bool is_signed = etl::is_signed<unsigned long long>::value;
    };

    template <typename T>
    constexpr unsigned long long statics_unsigned_long_long<T>::min;

    template <typename T>
    constexpr unsigned long long statics_unsigned_long_long<T>::max;

    template <typename T>
    constexpr int statics_unsigned_long_long<T>::bits;

    template <typename T>
    constexpr bool statics_unsigned_long_long<T>::is_signed;




    template <typename T = void>
    struct statics_char8_t
    {
      typedef char8_t value_type;

      static constexpr char8_t min = (etl::is_signed<char8_t>::value) ? 
# 390 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                                                                (-0x7f - 1) 
# 390 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                                                          : 0;
      static constexpr char8_t max = (etl::is_signed<char8_t>::value) ? 0x7f 
# 391 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                                                          : static_cast<char8_t>(
# 391 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 3 4
                                                                                                                 (0x7f * 2 + 1)
# 391 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                                                                                          );
      static constexpr int bits = 8
# 392 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
                                                     ;
      static constexpr bool is_signed = etl::is_signed<char8_t>::value;
    };

    template <typename T>
    constexpr char8_t statics_char8_t<T>::min;

    template <typename T>
    constexpr char8_t statics_char8_t<T>::max;

    template <typename T>
    constexpr int statics_char8_t<T>::bits;

    template <typename T>
    constexpr bool statics_char8_t<T>::is_signed;





    template <typename T = void>
    struct statics_char16_t
    {
      typedef char16_t value_type;

      static constexpr char16_t min = 0;
      static constexpr char16_t max = 0xFFFFU;
      static constexpr int bits = 16;
      static constexpr bool is_signed = false;
    };

    template <typename T>
    constexpr char16_t statics_char16_t<T>::min;

    template <typename T>
    constexpr char16_t statics_char16_t<T>::max;

    template <typename T>
    constexpr int statics_char16_t<T>::bits;

    template <typename T>
    constexpr bool statics_char16_t<T>::is_signed;





    template <typename T = void>
    struct statics_char32_t
    {
      typedef char32_t value_type;

      static constexpr char32_t min = 0;
      static constexpr char32_t max = 0xFFFFFFFFU;
      static constexpr int bits = 32;
      static constexpr bool is_signed = false;
    };

    template <typename T>
    constexpr char32_t statics_char32_t<T>::min;

    template <typename T>
    constexpr char32_t statics_char32_t<T>::max;

    template <typename T>
    constexpr int statics_char32_t<T>::bits;

    template <typename T>
    constexpr bool statics_char32_t<T>::is_signed;
# 510 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
  }




  template <typename T>
  struct integral_limits;




  template <>
  struct integral_limits<signed char> : public private_integral_limits::statics_signed_char<>
  {
  };




  template <>
  struct integral_limits<unsigned char> : public private_integral_limits::statics_unsigned_char<>
  {
  };





  template <>
  struct integral_limits<char> : public private_integral_limits::statics_char<>
  {
    typedef char value_type;
  };




  template <>
  struct integral_limits<short> : public private_integral_limits::statics_short<>
  {
  };




  template <>
  struct integral_limits<unsigned short> : public private_integral_limits::statics_unsigned_short<>
  {
  };




  template <>
  struct integral_limits<int> : public private_integral_limits::statics_int<>
  {
  };




  template <>
  struct integral_limits<unsigned int> : public private_integral_limits::statics_unsigned_int<>
  {
  };




  template <>
  struct integral_limits<long> : public private_integral_limits::statics_long<>
  {
  };




  template <>
  struct integral_limits<unsigned long> : public private_integral_limits::statics_unsigned_long<>
  {
  };




  template <>
  struct integral_limits<long long> : public private_integral_limits::statics_long_long<>
  {
  };




  template <>
  struct integral_limits<unsigned long long> : public private_integral_limits::statics_unsigned_long_long<>
  {
  };
# 622 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h"
}

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
             
             
# 52 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
#undef ETL_PUSHED_MIN_MAX
# 625 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/integral_limits.h" 2
# 58 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h" 2






namespace etl
{







  template <typename T1, typename... TRest>
  class smallest_type
  {
  private:


    using smallest_other = typename smallest_type<TRest...>::type;

  public:



    using type = typename etl::conditional<(etl::size_of<T1>::value < etl::size_of<smallest_other>::value),
                                            T1,
                                            smallest_other>
                                            ::type;


    enum
    {
      size = etl::size_of<type>::value
    };
  };




  template <typename T1>
  class smallest_type<T1>
  {
  public:

    using type = T1;

    enum
    {
      size = etl::size_of<type>::value
    };
  };


  template <typename... T>
  using smallest_type_t = typename smallest_type<T...>::type;



  template <typename... T>
  constexpr size_t smallest_type_v = smallest_type<T...>::size;
# 194 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
  namespace private_smallest
  {



    template <int index>
    struct best_fit_uint_type;




    template <>
    struct best_fit_uint_type<0>
    {
      typedef uint_least8_t type;
    };




    template <>
    struct best_fit_uint_type<1>
    {
      typedef uint_least16_t type;
    };




    template <>
    struct best_fit_uint_type<2>
    {
      typedef uint_least32_t type;
    };





    template <>
    struct best_fit_uint_type<3>
    {
      typedef uint_least64_t type;
    };





    template <int index>
    struct best_fit_int_type;




    template <>
    struct best_fit_int_type<0>
    {
      typedef int_least8_t type;
    };




    template <>
    struct best_fit_int_type<1>
    {
      typedef int_least16_t type;
    };




    template <>
    struct best_fit_int_type<2>
    {
      typedef int_least32_t type;
    };





    template <>
    struct best_fit_int_type<3>
    {
      typedef int_least64_t type;
    };

  }







  template <size_t NBITS>
  struct smallest_uint_for_bits
  {
  private:


    static constexpr int TYPE_INDEX = ((NBITS > 8) ? 1 : 0) +
                                         ((NBITS > 16) ? 1 : 0) +
                                         ((NBITS > 32) ? 1 : 0);

  public:

    typedef typename private_smallest::best_fit_uint_type<TYPE_INDEX>::type type;
  };

  template <size_t NBITS>
  constexpr int smallest_uint_for_bits<NBITS>::TYPE_INDEX;


  template <size_t NBITS>
  using smallest_uint_for_bits_t = typename smallest_uint_for_bits<NBITS>::type;
# 320 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
  template <size_t NBITS>
  struct smallest_int_for_bits
  {
  private:


    static constexpr int TYPE_INDEX = ((NBITS > 8) ? 1 : 0) +
                                         ((NBITS > 16) ? 1 : 0) +
                                         ((NBITS > 32) ? 1 : 0);

  public:

    typedef typename private_smallest::best_fit_int_type<TYPE_INDEX>::type type;
  };

  template <size_t NBITS>
  constexpr int smallest_int_for_bits<NBITS>::TYPE_INDEX;


  template <size_t NBITS>
  using smallest_int_for_bits_t = typename smallest_int_for_bits<NBITS>::type;
# 349 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
  template <uintmax_t VALUE>
  struct smallest_uint_for_value
  {
  private:


    static constexpr int TYPE_INDEX = ((VALUE > 0xff
# 355 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
                                                                 ) ? 1 : 0) +
      ((VALUE > 0xffff
# 356 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
                         ) ? 1 : 0) +
      ((VALUE > 0xffffffffUL
# 357 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
                         ) ? 1 : 0);

  public:

    typedef typename private_smallest::best_fit_uint_type<TYPE_INDEX>::type type;
  };

  template <uintmax_t VALUE>
  constexpr int smallest_uint_for_value<VALUE>::TYPE_INDEX;


  template <uintmax_t VALUE>
  using smallest_uint_for_value_t = typename smallest_uint_for_value<VALUE>::type;
# 378 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
  template <intmax_t VALUE>
  struct smallest_int_for_value
  {
  private:


    static constexpr int TYPE_INDEX = (((VALUE > intmax_t(0x7f
# 384 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
                                                                          )) || (VALUE < intmax_t(
# 384 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h" 3 4
                                                                                                  (-0x7f - 1)
# 384 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
                                                                                                                ))) ? 1 : 0) +
      (((VALUE > intmax_t(0x7fff
# 385 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
                                  )) || (VALUE < intmax_t(
# 385 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h" 3 4
                                                          (-0x7fff - 1)
# 385 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
                                                                   ))) ? 1 : 0) +
      (((VALUE > intmax_t(0x7fffffffL
# 386 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
                                  )) || (VALUE < intmax_t(
# 386 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h" 3 4
                                                          (-0x7fffffffL - 1)
# 386 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h"
                                                                   ))) ? 1 : 0);

  public:

    typedef typename private_smallest::best_fit_int_type<TYPE_INDEX>::type type;
  };

  template <intmax_t VALUE>
  constexpr int smallest_int_for_value<VALUE>::TYPE_INDEX;


  template <intmax_t VALUE>
  using smallest_int_for_value_t = typename smallest_int_for_value<VALUE>::type;

}
# 62 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/largest.h" 2


namespace etl
{







  template <typename T1, typename... TRest>
  class largest_type
  {
  private:


    using largest_other = typename largest_type<TRest...>::type;

  public:



    using type = typename etl::conditional<(etl::size_of<T1>::value > etl::size_of<largest_other>::value),
                                            T1,
                                            largest_other>
                                            ::type;


    enum
    {
      size = etl::size_of<type>::value
    };
  };




  template <typename T1>
  class largest_type<T1>
  {
  public:

    using type = T1;

    enum
    {
      size = etl::size_of<type>::value
    };
  };


  template <typename... T>
  using largest_type_t = typename largest_type<T...>::type;



  template <typename... T>
  constexpr size_t largest_type_v = largest_type<T...>::size;
# 176 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/largest.h"
  template <typename T1, typename... TRest>
  struct largest_alignment
  {

    using largest_other = typename largest_alignment<TRest...>::type;



    using type = typename etl::conditional<(etl::alignment_of<T1>::value > etl::alignment_of<largest_other>::value),
                                            T1,
                                            largest_other>
                                            ::type;


    enum
    {
      value = etl::alignment_of<type>::value
    };
  };




  template <typename T1>
  struct largest_alignment<T1>
  {
    typedef T1 type;

    enum
    {
      value = etl::alignment_of<type>::value
    };
  };


  template <typename... T>
  inline constexpr size_t largest_alignment_v = largest_alignment<T...>::value;
# 266 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/largest.h"
  template <typename T>
  struct larger_int_type
  {
    static_assert(etl::is_integral<T>::value, "Must be an integral type");

    typedef typename etl::smallest_int_for_bits<etl::integral_limits<typename etl::make_signed<T>::type>::bits + 1>::type type;
  };


  template <typename T>
  using larger_int_type_t = typename larger_int_type<T>::type;







  template <typename T>
  struct larger_uint_type
  {
    static_assert(etl::is_integral<T>::value, "Must be an integral type");

    typedef typename etl::smallest_uint_for_bits<etl::integral_limits<typename etl::make_unsigned<T>::type>::bits + 1>::type type;
  };


  template <typename T>
  using larger_uint_type_t = typename larger_uint_type<T>::type;
# 303 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/largest.h"
  template <typename T, bool IS_SIGNED = etl::is_signed<T>::value>
  struct larger_type;

  template <typename T>
  struct larger_type<T, false>
  {
    static_assert(etl::is_integral<T>::value, "Must be an integral type");

    typedef typename etl::smallest_uint_for_bits<etl::integral_limits<T>::bits + 1>::type type;
  };

  template <typename T>
  struct larger_type<T, true>
  {
    static_assert(etl::is_integral<T>::value, "Must be an integral type");

    typedef typename etl::smallest_int_for_bits<etl::integral_limits<T>::bits + 1>::type type;
  };


  template <typename T>
  using larger_type_t = typename larger_type<T>::type;
# 333 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/largest.h"
  template <typename... T>
  struct largest
  {
    using type = typename etl::largest_type<T...>::type;

    enum
    {
      size = etl::largest_type<T...>::size,
      alignment = etl::largest_alignment<T...>::value
    };
  };


    template <typename... T>
    using largest_t = typename largest<T...>::type;



    template <typename... T>
    inline constexpr size_t largest_size = largest<T...>::size;
# 377 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/largest.h"
}
# 47 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/gcd.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/gcd.h"
#define ETL_GDC_INCLUDED 

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 35 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/gcd.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/absolute.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/absolute.h"
#define ETL_ABSOLUTE_INCLUDED 

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 35 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/absolute.h" 2


namespace etl
{



  template <typename T>
  [[nodiscard]]
  constexpr
  typename etl::enable_if<etl::is_signed<T>::value, T>::type
    absolute(T value)
  {
    return (value < T(0)) ? -value : value;
  }




  template <typename T>
  [[nodiscard]]
  constexpr
  typename etl::enable_if<etl::is_unsigned<T>::value, T>::type
    absolute(T value)
  {
    return value;
  }





  template <typename T>
  [[nodiscard]]
  constexpr
  typename etl::enable_if<etl::is_signed<T>::value, typename etl::make_unsigned<T>::type>::type
    absolute_unsigned(T value)
  {
    typedef typename etl::make_unsigned<T>::type TReturn;

    return (value == etl::integral_limits<T>::min) ? (etl::integral_limits<TReturn>::max / 2U) + 1U
                                                   : (value < T(0)) ? TReturn(-value) : TReturn(value);
  }





  template <typename T>
  [[nodiscard]]
  constexpr
  typename etl::enable_if<etl::is_unsigned<T>::value, T>::type
    absolute_unsigned(T value)
  {
    return etl::absolute(value);
  }
}
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/gcd.h" 2


namespace etl
{




  template <intmax_t Value1, intmax_t Value2>
  struct gcd_const
  {
    static constexpr intmax_t value = gcd_const<Value2, Value1 % Value2>::value;
  };

  template <intmax_t Value1>
  struct gcd_const<Value1, 0>
  {
    static constexpr intmax_t value = Value1;
  };





  template <typename T>
  [[nodiscard]]
  constexpr
  typename etl::enable_if<etl::is_unsigned<T>::value, T>::type
    gcd(T a, T b)
  {
    static_assert(etl::is_integral<T>::value, "Integral type required");

    if ((a == 0 || b == 0))
    {
      return (a + b);
    }

    while (b != 0)
    {
      T t = b;
      b = a % b;
      a = t;
    }

    return a;
  }





  template <typename T>
  [[nodiscard]]
  constexpr
  typename etl::enable_if<etl::is_signed<T>::value, T>::type
    gcd(T a, T b)
  {
    static_assert(etl::is_integral<T>::value, "Integral type required");

    typedef typename etl::make_unsigned<T>::type utype;

    utype ua = etl::absolute_unsigned(a);
    utype ub = etl::absolute_unsigned(b);

    return static_cast<T>(gcd(ua, ub));
  }
# 110 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/gcd.h"
  template<typename T, typename... TRest>
  [[nodiscard]]
  constexpr
  T gcd(T first, TRest... rest)
  {
    T result = first;

    for (T value : {rest...})
    {
      result = gcd(result, value);

      if (result == 1)
      {


        return 1;
      }
    }

    return result;
  }
# 157 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/gcd.h"
}
# 48 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h" 1
# 33 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h"
#define ETL_ERROR_HANDLER_INCLUDED 






# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/exception.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/exception.h"
#define ETL_EXCEPTION_INCLUDED 







namespace etl
{




  class exception
  {
  public:

    typedef const char* string_type;
    typedef int numeric_type;
# 68 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/exception.h"
    constexpr
    exception(string_type reason_, string_type , numeric_type line_)
      : reason_text(reason_),
        line(line_)
    {
    }






    constexpr
    string_type what() const
    {
      return reason_text;
    }






    constexpr
    string_type file_name() const
    {



      return "";

    }





    constexpr
    numeric_type line_number() const
    {
      return line;
    }

  private:

    string_type reason_text;



    numeric_type line;
  };
}
# 41 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/function.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/function.h"
#define ETL_FUNCTION_INCLUDED 
# 45 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/function.h"
namespace etl
{





  template <typename TParameter>
  class ifunction
  {
  public:

    typedef TParameter parameter_type;

    virtual ~ifunction() {}




    virtual void operator ()(TParameter) const = 0;
  };





  template <>
  class ifunction<void>
  {
  public:

    typedef void parameter_type;

    virtual ~ifunction() {}




    virtual void operator ()() const = 0;
  };







  template <typename TObject, typename TParameter>
  class function : public ifunction<TParameter>
  {
  public:

    typedef TObject object_type;
    typedef TParameter parameter_type;






    function(TObject& object_, void(TObject::* p_function_)(TParameter))
      : p_object(&object_),
        p_function(p_function_)
    {
    }





    virtual void operator ()(TParameter data) const override
    {

      (p_object->*p_function)(data);
    }

  private:

    TObject* p_object;
    void (TObject::* p_function)(TParameter);
  };






  template <typename TObject>
  class function<TObject, void> : public ifunction<void>
  {
  public:






    function(TObject& object_, void(TObject::* p_function_)(void))
      : p_object(&object_),
        p_function(p_function_)
    {
    }




    virtual void operator ()() const override
    {

      (p_object->*p_function)();
    }

  private:

    TObject* p_object;
    void (TObject::* p_function)();
  };





  template <typename TParameter>
  class function<void, TParameter> : public ifunction<TParameter>
  {
  public:





    explicit function(void(*p_function_)(TParameter))
      : p_function(p_function_)
    {
    }





    virtual void operator ()(TParameter data) const override
    {

      (*p_function)(data);
    }

  private:

    void (*p_function)(TParameter);
  };





  template <>
  class function<void, void> : public ifunction<void>
  {
  public:





    explicit function(void(*p_function_)(void))
      : p_function(p_function_)
    {
    }




    virtual void operator ()() const override
    {

      (*p_function)();
    }

  private:

    void (*p_function)();
  };







  template <typename TObject, typename TParameter, void (TObject::*Function)(TParameter)>
  class function_mp : public ifunction<TParameter>
  {
  public:

    typedef TObject object_type;
    typedef TParameter parameter_type;





    explicit function_mp(TObject& object_)
      : p_object(&object_)
    {
    }





    virtual void operator ()(TParameter data) const override
    {

      (p_object->*Function)(data);
    }

  private:

    TObject* p_object;
  };







  template <typename TObject, void (TObject::*Function)(void)>
  class function_mv : public ifunction<void>
  {
  public:

    typedef TObject object_type;
    typedef void parameter_type;





    explicit function_mv(TObject& object_)
      : p_object(&object_)
    {
    }





    virtual void operator ()() const override
    {

      (p_object->*Function)();
    }

  private:

    TObject* p_object;
  };







  template <typename TObject, typename TParameter, TObject& Instance, void (TObject::*Function)(TParameter)>
  class function_imp : public ifunction<TParameter>
  {
  public:

    typedef TObject object_type;
    typedef TParameter parameter_type;





    virtual void operator ()(TParameter data) const override
    {

      (Instance.*Function)(data);
    }
  };







  template <typename TObject, TObject& Instance, void (TObject::*Function)(void)>
  class function_imv : public ifunction<void>
  {
  public:

    typedef TObject object_type;
    typedef void parameter_type;





    virtual void operator ()() const override
    {

      (Instance.*Function)();
    }
  };






  template <typename TParameter, void (*Function)(TParameter)>
  class function_fp : public ifunction<TParameter>
  {
  public:

    typedef TParameter parameter_type;






    function_fp()
    {
    }





    virtual void operator ()(TParameter data) const override
    {

      (*Function)(data);
    }
  };






  template <void(*Function)(void)>
  class function_fv : public ifunction<void>
  {
  public:

    typedef void parameter_type;






    function_fv()
    {
    }





    virtual void operator ()() const override
    {

      (*Function)();
    }
  };

}
# 42 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h" 2


# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/assert.h" 1 3






# 6 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/assert.h" 3
extern "C" {




#undef assert




#define assert(__e) ((__e) ? (void)0 : __assert_func (__FILE__, __LINE__, __ASSERT_FUNC, #__e))





#define __ASSERT_FUNC __PRETTY_FUNCTION__
# 39 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/assert.h" 3
void __assert (const char *, int, const char *)
     __attribute__ ((__noreturn__));
void __assert_func (const char *, int, const char *, const char *)
     __attribute__ ((__noreturn__));






}
# 45 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h" 2
# 356 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h"
#define ETL_ASSERT(b,e) static_cast<void>(sizeof(b))
#define ETL_ASSERT_OR_RETURN(b,e) do {if (!(b)) ETL_UNLIKELY return;} while(false)
#define ETL_ASSERT_OR_RETURN_VALUE(b,e,v) do {if (!(b)) ETL_UNLIKELY return(v);} while(false)

#define ETL_ASSERT_FAIL(e) ETL_DO_NOTHING
#define ETL_ASSERT_FAIL_AND_RETURN(e) do {return;} while(false)
#define ETL_ASSERT_FAIL_AND_RETURN_VALUE(e,v) do {return(v);} while(false)
# 372 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h"
#define ETL_ASSERT_CHECK_PUSH_POP(b,e) 
#define ETL_ASSERT_CHECK_PUSH_POP_OR_RETURN(b,e) 
# 382 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h"
#define ETL_CHECKING_INDEX_OPERATOR 0
#define ETL_NOT_CHECKING_INDEX_OPERATOR 1
#define ETL_ASSERT_CHECK_INDEX_OPERATOR(b,e) 
# 393 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h"
#define ETL_CHECKING_EXTRA 0
#define ETL_NOT_CHECKING_EXTRA 1
#define ETL_ASSERT_CHECK_EXTRA(b,e) 
# 405 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/error_handler.h"
#define ETL_ERROR(e) (e("", __LINE__))
#define ETL_ERROR_WITH_VALUE(e,v) (e("", __LINE__, (v)))
#define ETL_ERROR_TEXT(verbose_text,terse_text) (terse_text)
#define ETL_ERROR_GENERIC(text) (etl::exception((text),"", __LINE__))
# 49 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 2



# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/string.h" 1 3







#define _STRING_H_ 






#define __need_size_t 
#define __need_NULL 
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 173 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 252 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_size_t
# 364 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_wchar_t
# 414 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef NULL

#define NULL __null
# 425 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_NULL




#undef offsetof
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 18 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/string.h" 2 3
# 27 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/string.h" 3
extern "C" {

void * memchr (const void *, int, size_t);
int memcmp (const void *, const void *, size_t);
void * memcpy (void *__restrict, const void *__restrict, size_t);
void * memmove (void *, const void *, size_t);
void * memset (void *, int, size_t);
char *strcat (char *__restrict, const char *__restrict);
char *strchr (const char *, int);
int strcmp (const char *, const char *);
int strcoll (const char *, const char *);
char *strcpy (char *__restrict, const char *__restrict);
size_t strcspn (const char *, const char *);
char *strerror (int);
size_t strlen (const char *);
char *strncat (char *__restrict, const char *__restrict, size_t);
int strncmp (const char *, const char *, size_t);
char *strncpy (char *__restrict, const char *__restrict, size_t);
char *strpbrk (const char *, const char *);
char *strrchr (const char *, int);
size_t strspn (const char *, const char *);
char *strstr (const char *, const char *);

char *strtok (char *__restrict, const char *__restrict);

size_t strxfrm (char *__restrict, const char *__restrict, size_t);
# 86 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/string.h" 3
char *_strdup_r (struct _reent *, const char *);



char *_strndup_r (struct _reent *, const char *, size_t);
# 112 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/string.h" 3
char * _strerror_r (struct _reent *, int, int, int *);
# 175 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/string.h" 3
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/string.h" 1 3
# 13 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/sys/string.h" 3
#define _SYS_STRING_H 

static inline unsigned long __libc_detect_null(unsigned long w)
{
  unsigned long mask = 0x7f7f7f7f;
  if (sizeof (long) == 8)
    mask = ((mask << 16) << 16) | mask;
  return ~(((w & mask) + mask) | w | mask);
}
# 176 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/string.h" 2 3

}
# 53 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
             
             
# 56 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
#define ETL_PUSHED_MIN_MAX 
# 55 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 2
# 64 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"

# 64 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
namespace etl
{

  template <typename TIterator>



  constexpr

  void shell_sort(TIterator first, TIterator last);

  template <typename TIterator, typename TCompare>



  constexpr

  void shell_sort(TIterator first, TIterator last, TCompare compare);

  template <typename TIterator>
  constexpr void insertion_sort(TIterator first, TIterator last);

  template <typename TIterator, typename TCompare>
  constexpr void insertion_sort(TIterator first, TIterator last, TCompare compare);

  class algorithm_exception : public etl::exception
  {
  public:

    algorithm_exception(string_type reason_, string_type file_name_, numeric_type line_number_)
      : exception(reason_, file_name_, line_number_)
    {
    }
  };

  class algorithm_error : public algorithm_exception
  {
  public:

    algorithm_error(string_type file_name_, numeric_type line_number_)
      : algorithm_exception(("76""A"), file_name_, line_number_)
    {
    }
  };

}




namespace etl
{
  namespace private_algorithm
  {
    template <bool use_swap>
    struct swap_impl;


    template <>
    struct swap_impl<false>
    {
      template <typename TIterator1, typename TIterator2>
      static void do_swap(TIterator1 a, TIterator2 b)
      {
        typename etl::iterator_traits<TIterator1>::value_type tmp = *a;
        *a = *b;
        *b = tmp;
      }
    };


    template <>
    struct swap_impl<true>
    {
      template <typename TIterator1, typename TIterator2>
      static void do_swap(TIterator1 a, TIterator2 b)
      {
        using etl::swap;
        swap(*a, *b);
      }
    };
  }




  template <typename TIterator1, typename TIterator2>



  constexpr

  void iter_swap(TIterator1 a, TIterator2 b)
  {
    typedef etl::iterator_traits<TIterator1> traits1;
    typedef etl::iterator_traits<TIterator2> traits2;

    typedef typename traits1::value_type v1;
    typedef typename traits2::value_type v2;

    typedef typename traits1::reference r1;
    typedef typename traits2::reference r2;

    const bool use_swap = etl::is_same<v1, v2>::value &&
                          etl::is_reference<r1>::value &&
                          etl::is_reference<r2>::value;

    private_algorithm::swap_impl<use_swap>::do_swap(a, b);
  }




  template <typename TIterator1, typename TIterator2>



  constexpr

  TIterator2 swap_ranges(TIterator1 first1,
                         TIterator1 last1,
                         TIterator2 first2)
  {
    while (first1 != last1)
    {
      iter_swap(first1, first2);
      ++first1;
      ++first2;
    }

    return first2;
  }



  template <typename TIterator, typename TFunction>
  constexpr
  void generate(TIterator db, TIterator de, TFunction funct)
  {
    while (db != de)
    {
      *db++ = funct();
    }
  }
# 220 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator1, typename TIterator2>
  constexpr TIterator2 copy(TIterator1 sb, TIterator1 se, TIterator2 db)
  {
    while (sb != se)
    {
      *db = *sb;
      ++db;
      ++sb;
    }

    return db;
  }
# 243 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator1, typename TIterator2>
  constexpr
  TIterator2 reverse_copy(TIterator1 sb, TIterator1 se, TIterator2 db)
  {
    while (sb != se)
    {
      *db = *--se;
      ++db;
    }

    return db;
  }
# 268 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator1, typename TSize, typename TIterator2>
  constexpr TIterator2 copy_n(TIterator1 sb, TSize count, TIterator2 db)
  {
    while (count != 0)
    {
      *db = *sb;
      ++db;
      ++sb;
      --count;
    }

    return db;
  }
# 292 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator1, typename TIterator2>
  constexpr TIterator2 copy_backward(TIterator1 sb, TIterator1 se, TIterator2 de)
  {
    while (se != sb)
    {
      *(--de) = *(--se);
    }

    return de;
  }
# 314 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator1, typename TIterator2>
  constexpr TIterator2 move(TIterator1 sb, TIterator1 se, TIterator2 db)
  {
    while (sb != se)
    {
      *db = etl::move(*sb);
      ++db;
      ++sb;
    }

    return db;
  }
# 345 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator1, typename TIterator2>
  constexpr TIterator2 move_backward(TIterator1 sb, TIterator1 se, TIterator2 de)
  {
    while (sb != se)
    {
      *(--de) = etl::move(*(--se));
    }

    return de;
  }
# 368 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator>
  constexpr
  typename etl::enable_if<etl::is_pointer<TIterator>::value, void>::type
    reverse(TIterator b, TIterator e)
  {
    if (b != e)
    {
      while (b < --e)
      {
        etl::iter_swap(b, e);
        ++b;
      }
    }
  }


  template <typename TIterator>
  constexpr
  typename etl::enable_if<!etl::is_pointer<TIterator>::value, void>::type
    reverse(TIterator b, TIterator e)
  {
    while ((b != e) && (b != --e))
    {
      etl::iter_swap(b++, e);
    }
  }




  template<typename TIterator, typename TValue, typename TCompare>
  [[nodiscard]]
  constexpr
  TIterator lower_bound(TIterator first, TIterator last, const TValue& value, TCompare compare)
  {
    typedef typename etl::iterator_traits<TIterator>::difference_type difference_t;

    difference_t count = etl::distance(first, last);

    while (count > 0)
    {
      TIterator itr = first;
      difference_t step = count / 2;

      etl::advance(itr, step);

      if (compare(*itr, value))
      {
        first = ++itr;
        count -= step + 1;
      }
      else
      {
        count = step;
      }
    }

    return first;
  }

  template<typename TIterator, typename TValue>
  [[nodiscard]]
  constexpr
  TIterator lower_bound(TIterator first, TIterator last, const TValue& value)
  {
    typedef etl::less<typename etl::iterator_traits<TIterator>::value_type> compare;

    return etl::lower_bound(first, last, value, compare());
  }




  template<typename TIterator, typename TValue, typename TCompare>
  [[nodiscard]]
  constexpr
  TIterator upper_bound(TIterator first, TIterator last, const TValue& value, TCompare compare)
  {
    typedef typename etl::iterator_traits<TIterator>::difference_type difference_t;

    difference_t count = etl::distance(first, last);

    while (count > 0)
    {
      TIterator itr = first;
      difference_t step = count / 2;

      etl::advance(itr, step);

      if (!compare(value, *itr))
      {
        first = ++itr;
        count -= step + 1;
      }
      else
      {
        count = step;
      }
    }

    return first;
  }

  template<typename TIterator, typename TValue>
  [[nodiscard]]
  constexpr
  TIterator upper_bound(TIterator first, TIterator last, const TValue& value)
  {
    typedef etl::less<typename etl::iterator_traits<TIterator>::value_type> compare;

    return etl::upper_bound(first, last, value, compare());
  }




  template<typename TIterator, typename TValue, typename TCompare>
  [[nodiscard]]
  constexpr
  etl::pair<TIterator, TIterator> equal_range(TIterator first, TIterator last, const TValue& value, TCompare compare)
  {
    return etl::make_pair(etl::lower_bound(first, last, value, compare),
                                 etl::upper_bound(first, last, value, compare));
  }

  template<typename TIterator, typename TValue>
  [[nodiscard]]
  etl::pair<TIterator, TIterator> equal_range(TIterator first, TIterator last, const TValue& value)
  {
    typedef etl::less<typename etl::iterator_traits<TIterator>::value_type> compare;

    return etl::make_pair(etl::lower_bound(first, last, value, compare()),
                                 etl::upper_bound(first, last, value, compare()));
  }




  template <typename TIterator, typename T, typename Compare>
  [[nodiscard]]
  bool binary_search(TIterator first, TIterator last, const T& value, Compare compare)
  {
    first = etl::lower_bound(first, last, value, compare);

    return (!(first == last) && !(compare(value, *first)));
  }

  template <typename TIterator, typename T>
  [[nodiscard]]
  bool binary_search(TIterator first, TIterator last, const T& value)
  {
    typedef etl::less<typename etl::iterator_traits<TIterator>::value_type> compare;

    return binary_search(first, last, value, compare());
  }




  template <typename TIterator, typename TUnaryPredicate>
  [[nodiscard]]
  constexpr
  TIterator find_if(TIterator first, TIterator last, TUnaryPredicate predicate)
  {
    while (first != last)
    {
      if (predicate(*first))
      {
        return first;
      }

      ++first;
    }

    return last;
  }




  template <typename TIterator, typename T>
  [[nodiscard]]
  constexpr
  TIterator find(TIterator first, TIterator last, const T& value)
  {
    while (first != last)
    {
      if (*first == value)
      {
        return first;
      }

      ++first;
    }

    return last;
  }
# 575 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template<typename TIterator, typename TValue>
  constexpr void fill(TIterator first, TIterator last, const TValue& value)
  {
    while (first != last)
    {
      *first = value;
      ++first;
    }
  }
# 595 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template<typename TIterator, typename TSize, typename TValue>
  constexpr TIterator fill_n(TIterator first, TSize count, const TValue& value)
  {
    while (count != 0)
    {
      *first++ = value;
      --count;
    }

    return first;
  }





  template <typename TIterator, typename T>
  [[nodiscard]]
  constexpr
  typename etl::iterator_traits<TIterator>::difference_type count(TIterator first, TIterator last, const T& value)
  {
    typename iterator_traits<TIterator>::difference_type n = 0;

    while (first != last)
    {
      if (*first == value)
      {
        ++n;
      }

      ++first;
    }

    return n;
  }




  template <typename TIterator, typename TUnaryPredicate>
  [[nodiscard]]
  constexpr
  typename etl::iterator_traits<TIterator>::difference_type
    count_if(TIterator first, TIterator last, TUnaryPredicate predicate)
  {
    typename iterator_traits<TIterator>::difference_type n = 0;

    while (first != last)
    {
      if (predicate(*first))
      {
        ++n;
      }

      ++first;
    }

    return n;
  }
# 696 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator1, typename TIterator2>
  [[nodiscard]]
  constexpr
  bool equal(TIterator1 first1, TIterator1 last1, TIterator2 first2)
  {
    while (first1 != last1)
    {
      if (*first1 != *first2)
      {
        return false;
      }

      ++first1;
      ++first2;
    }

    return true;
  }


  template <typename TIterator1, typename TIterator2, typename TPredicate>
  [[nodiscard]]
  constexpr
  bool equal(TIterator1 first1, TIterator1 last1, TIterator2 first2, TPredicate predicate)
  {
    while (first1 != last1)
    {
      if (!predicate(*first1, *first2))
      {
        return false;
      }

      ++first1;
      ++first2;
    }

    return true;
  }


  template <typename TIterator1, typename TIterator2>
  [[nodiscard]]
  constexpr
  bool equal(TIterator1 first1, TIterator1 last1, TIterator2 first2, TIterator2 last2)
  {
    while ((first1 != last1) && (first2 != last2))
    {
      if (*first1 != *first2)
      {
        return false;
      }

      ++first1;
      ++first2;
    }

    return (first1 == last1) && (first2 == last2);
  }


  template <typename TIterator1, typename TIterator2, typename TPredicate>
  [[nodiscard]]
  constexpr
  bool equal(TIterator1 first1, TIterator1 last1, TIterator2 first2, TIterator2 last2, TPredicate predicate)
  {
    while ((first1 != last1) && (first2 != last2))
    {
      if (!predicate(*first1 , *first2))
      {
        return false;
      }

      ++first1;
      ++first2;
    }

    return (first1 == last1) && (first2 == last2);
  }





  template <typename TIterator1, typename TIterator2, typename TCompare>
  [[nodiscard]]
  constexpr
  bool lexicographical_compare(TIterator1 first1, TIterator1 last1,
                               TIterator2 first2, TIterator2 last2,
                               TCompare compare)
  {
    while ((first1 != last1) && (first2 != last2))
    {
      if (compare(*first1, *first2))
      {
        return true;
      }

      if (compare(*first2, *first1))
      {
        return false;
      }

      ++first1;
      ++first2;
    }

    return (first1 == last1) && (first2 != last2);
  }


  template <typename TIterator1, typename TIterator2>
  [[nodiscard]]
  constexpr
  bool lexicographical_compare(TIterator1 first1, TIterator1 last1,
                               TIterator2 first2, TIterator2 last2)
  {
    typedef etl::less<typename etl::iterator_traits<TIterator1>::value_type> compare;

    return etl::lexicographical_compare(first1, last1, first2, last2, compare());
  }




  template <typename T, typename TCompare>
  [[nodiscard]]
  constexpr
  const T& min(const T& a, const T& b, TCompare compare)
  {
    return (compare(a, b)) ? a : b;
  }

  template <typename T>
  [[nodiscard]]
  constexpr
  const T& min(const T& a, const T& b)
  {
    typedef etl::less<T> compare;

    return etl::min(a, b, compare());
  }




  template <typename T, typename TCompare>
  [[nodiscard]]
  constexpr
  const T& max(const T& a, const T& b, TCompare compare)
  {
    return (compare(a, b)) ? b : a;
  }

  template <typename T>
  [[nodiscard]]
  constexpr
  const T& max(const T& a, const T& b)
  {
    typedef etl::less<T> compare;

    return etl::max(a, b, compare());
  }




  template <typename TIterator, typename TUnaryOperation>
  constexpr
  TUnaryOperation for_each(TIterator first, TIterator last, TUnaryOperation unary_operation)
  {
    while (first != last)
    {
      unary_operation(*first);
      ++first;
    }

    return unary_operation;
  }




  template <typename TIteratorIn, typename TIteratorOut, typename TUnaryOperation>
  constexpr
  TIteratorOut transform(TIteratorIn first1, TIteratorIn last1, TIteratorOut d_first, TUnaryOperation unary_operation)
  {
    while (first1 != last1)
    {
      *d_first = unary_operation(*first1);

      ++d_first;
      ++first1;
    }

    return d_first;
  }

  template <typename TIteratorIn1, typename TIteratorIn2, typename TIteratorOut, typename TBinaryOperation>
  constexpr
  TIteratorOut transform(TIteratorIn1 first1, TIteratorIn1 last1, TIteratorIn2 first2, TIteratorOut d_first, TBinaryOperation binary_operation)
  {
    while (first1 != last1)
    {
      *d_first = binary_operation(*first1, *first2);

      ++d_first;
      ++first1;
      ++first2;
    }

    return d_first;
  }




  template <typename TIterator, typename T>
  constexpr void replace(TIterator first, TIterator last, const T& old_value, const T& new_value)
  {
    while (first != last)
    {
      if (*first == old_value)
      {
        *first = new_value;
      }

      ++first;
    }
  }




  template <typename TIterator, typename TPredicate, typename T>
  constexpr void replace_if(TIterator first, TIterator last, TPredicate predicate, const T& new_value)
  {
    while (first != last)
    {
      if (predicate(*first))
      {
        *first = new_value;
      }

      ++first;
    }
  }




  namespace private_heap
  {

    template <typename TIterator, typename TDistance, typename TValue, typename TCompare>
    void push_heap(TIterator first, TDistance value_index, TDistance top_index, TValue value, TCompare compare)
    {
      TDistance parent = (value_index - 1) / 2;

      while ((value_index > top_index) && compare(first[parent], value))
      {
        first[value_index] = etl::move(first[parent]);
        value_index = parent;
        parent = (value_index - 1) / 2;
      }

      first[value_index] = etl::move(value);
    }


    template <typename TIterator, typename TDistance, typename TValue, typename TCompare>
    void adjust_heap(TIterator first, TDistance value_index, TDistance length, TValue value, TCompare compare)
    {
      TDistance top_index = value_index;
      TDistance child2nd = (2 * value_index) + 2;

      while (child2nd < length)
      {
        if (compare(first[child2nd], first[child2nd - 1]))
        {
          --child2nd;
        }

        first[value_index] = etl::move(first[child2nd]);
        value_index = child2nd;
        child2nd = 2 * (child2nd + 1);
      }

      if (child2nd == length)
      {
        first[value_index] = etl::move(first[child2nd - 1]);
        value_index = child2nd - 1;
      }

      push_heap(first, value_index, top_index, etl::move(value), compare);
    }


    template <typename TIterator, typename TDistance, typename TCompare>
    bool is_heap(const TIterator first, const TDistance n, TCompare compare)
    {
      TDistance parent = 0;

      for (TDistance child = 1; child < n; ++child)
      {
        if (compare(first[parent], first[child]))
        {
          return false;
        }

        if ((child & 1) == 0)
        {
          ++parent;
        }
      }

      return true;
    }
  }


  template <typename TIterator, typename TCompare>
  void pop_heap(TIterator first, TIterator last, TCompare compare)
  {
    typedef typename etl::iterator_traits<TIterator>::value_type value_t;
    typedef typename etl::iterator_traits<TIterator>::difference_type distance_t;

    value_t value = etl::move(last[-1]);
    last[-1] = etl::move(first[0]);

    private_heap::adjust_heap(first, distance_t(0), distance_t(last - first - 1), etl::move(value), compare);
  }


  template <typename TIterator>
  void pop_heap(TIterator first, TIterator last)
  {
    typedef etl::less<typename etl::iterator_traits<TIterator>::value_type> compare;

    etl::pop_heap(first, last, compare());
  }


  template <typename TIterator, typename TCompare>
  void push_heap(TIterator first, TIterator last, TCompare compare)
  {
    typedef typename etl::iterator_traits<TIterator>::difference_type difference_t;
    typedef typename etl::iterator_traits<TIterator>::value_type value_t;

    private_heap::push_heap(first, difference_t(last - first - 1), difference_t(0), value_t(etl::move(*(last - 1))), compare);
  }


  template <typename TIterator>
  void push_heap(TIterator first, TIterator last)
  {
    typedef etl::less<typename etl::iterator_traits<TIterator>::value_type> compare;

    etl::push_heap(first, last, compare());
  }


  template <typename TIterator, typename TCompare>
  void make_heap(TIterator first, TIterator last, TCompare compare)
  {
    typedef typename etl::iterator_traits<TIterator>::difference_type difference_t;

    if ((last - first) < 2)
    {
      return;
    }

    difference_t length = last - first;
    difference_t parent = (length - 2) / 2;

    while (true)
    {
      private_heap::adjust_heap(first, parent, length, etl::move(*(first + parent)), compare);

      if (parent == 0)
      {
        return;
      }

      --parent;
    }
  }


  template <typename TIterator>
  void make_heap(TIterator first, TIterator last)
  {
    typedef etl::less<typename etl::iterator_traits<TIterator>::value_type> compare;

    etl::make_heap(first, last, compare());
  }


  template <typename TIterator>
  [[nodiscard]]
    bool is_heap(TIterator first, TIterator last)
  {
    typedef etl::less<typename etl::iterator_traits<TIterator>::value_type> compare;

    return private_heap::is_heap(first, last - first, compare());
  }


  template <typename TIterator, typename TCompare>
  [[nodiscard]]
  bool is_heap(TIterator first, TIterator last, TCompare compare)
  {
    return private_heap::is_heap(first, last - first, compare);
  }


  template <typename TIterator>
  void sort_heap(TIterator first, TIterator last)
  {
    while (first != last)
    {
      etl::pop_heap(first, last);
      --last;
    }
  }


  template <typename TIterator, typename TCompare>
  void sort_heap(TIterator first, TIterator last, TCompare compare)
  {
    while (first != last)
    {
      etl::pop_heap(first, last, compare);
      --last;
    }
  }




  template<typename TIterator1, typename TIterator2, typename TCompare>
  [[nodiscard]]
  constexpr
  TIterator1 search(TIterator1 first, TIterator1 last, TIterator2 search_first, TIterator2 search_last, TCompare compare)
  {
    while (true)
    {
      TIterator1 itr = first;
      TIterator2 search_itr = search_first;

      while (true)
      {
        if (search_itr == search_last)
        {
          return first;
        }

        if (itr == last)
        {
          return last;
        }

        if (!compare(*itr, *search_itr))
        {
          break;
        }

        ++itr;
        ++search_itr;
      }

      ++first;
    }
  }


  template<typename TIterator1, typename TIterator2>
  [[nodiscard]]
  constexpr
  TIterator1 search(TIterator1 first, TIterator1 last, TIterator2 search_first, TIterator2 search_last)
  {
    typedef etl::equal_to<typename etl::iterator_traits<TIterator1>::value_type> compare;

    return etl::search(first, last, search_first, search_last, compare());
  }




  namespace private_algorithm
  {



    template <typename TIterator>
    constexpr
    typename etl::enable_if<etl::is_random_access_iterator<TIterator>::value, TIterator>::type
      rotate_general(TIterator first, TIterator middle, TIterator last)
    {
      if (first == middle || middle == last)
      {
        return first;
      }

      typedef typename etl::iterator_traits<TIterator>::value_type value_type;

      int n = last - first;
      int m = middle - first;
      int gcd_nm = (n == 0 || m == 0) ? n + m : etl::gcd(n, m);

      TIterator result = first + (last - middle);

      for (int i = 0; i < gcd_nm; i++)
      {
        value_type temp = etl::move(*(first + i));
        int j = i;

        while (true)
        {
          int k = j + m;

          if (k >= n)
          {
            k = k - n;
          }

          if (k == i)
          {
            break;
          }

          *(first + j) = etl::move(*(first + k));
          j = k;
        }

        *(first + j) = etl::move(temp);
      }

      return result;
    }
# 1288 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
    template <typename TIterator>
    constexpr
    typename etl::enable_if<etl::is_bidirectional_iterator<TIterator>::value, TIterator>::type
      rotate_general(TIterator first, TIterator middle, TIterator last)
    {
      if (first == middle || middle == last)
      {
        return first;
      }

      TIterator result = first;
      etl::advance(result, etl::distance(middle, last));

      reverse(first, middle);
      reverse(middle, last);
      reverse(first, last);

      return result;
    }



    template <typename TIterator>
    constexpr
    typename etl::enable_if<etl::is_forward_iterator<TIterator>::value, TIterator>::type
      rotate_general(TIterator first, TIterator middle, TIterator last)
    {
      if (first == middle || middle == last)
      {
        return first;
      }

      TIterator next = middle;
      TIterator result = first;
      etl::advance(result, etl::distance(middle, last));

      while (first != next)
      {
        using etl::swap;
        swap(*first++, *next++);

        if (next == last)
        {
          next = middle;
        }
        else if (first == middle)
        {
          middle = next;
        }
      }

      return result;
    }



    template <typename TIterator>
    constexpr
    TIterator rotate_left_by_one(TIterator first, TIterator last)
    {
      typedef typename etl::iterator_traits<TIterator>::value_type value_type;


      value_type temp(etl::move(*first));


      TIterator result = etl::move(etl::next(first), last, first);


      *result = etl::move(temp);


      return result;
    }



    template <typename TIterator>
    constexpr
    TIterator rotate_right_by_one(TIterator first, TIterator last)
    {
      typedef typename etl::iterator_traits<TIterator>::value_type value_type;


      TIterator previous = etl::prev(last);
      value_type temp(etl::move(*previous));


      TIterator result = etl::move_backward(first, previous, last);


      *first = etl::move(temp);


      return result;
    }
  }


  template<typename TIterator>
  constexpr
  TIterator rotate(TIterator first, TIterator middle, TIterator last)
  {
    if (etl::next(first) == middle)
    {
      return private_algorithm::rotate_left_by_one(first, last);
    }

    if (etl::next(middle) == last)
    {

      if constexpr(etl::is_forward_iterator<TIterator>::value)
      {
        return private_algorithm::rotate_general(first, middle, last);
      }
      else
      {
        return private_algorithm::rotate_right_by_one(first, last);
      }



    }

    return private_algorithm::rotate_general(first, middle, last);
  }





  template <typename TIterator1, typename TIterator2, typename TPredicate>
  [[nodiscard]]
  constexpr
  TIterator1 find_end(TIterator1 b, TIterator1 e,
                      TIterator2 sb, TIterator2 se,
                      TPredicate predicate)
  {
    if (sb == se)
    {
      return e;
    }

    TIterator1 result = e;

    while (true)
    {
      TIterator1 new_result = etl::search(b, e, sb, se, predicate);

      if (new_result == e)
      {
        break;
      }
      else
      {
        result = new_result;
        b = result;
        ++b;
      }
    }
    return result;
  }


  template <typename TIterator1, typename TIterator2>
  [[nodiscard]]
  constexpr
  TIterator1 find_end(TIterator1 b, TIterator1 e,
                      TIterator2 sb, TIterator2 se)
  {
    typedef etl::equal_to<typename etl::iterator_traits<TIterator1>::value_type> predicate;

    return find_end(b, e, sb, se, predicate());
  }






  template <typename TIterator, typename TCompare>
  [[nodiscard]]
  constexpr
  TIterator min_element(TIterator begin,
                        TIterator end,
                        TCompare compare)
  {
    TIterator minimum = begin;

    if (begin != end)
    {
      ++begin;

      while (begin != end)
      {
        if (compare(*begin, *minimum))
        {
          minimum = begin;
        }

        ++begin;
      }
    }

    return minimum;
  }






  template <typename TIterator>
  [[nodiscard]]
  constexpr
  TIterator min_element(TIterator begin,
                        TIterator end)
  {
    typedef typename etl::iterator_traits<TIterator>::value_type value_t;

    return etl::min_element(begin, end, etl::less<value_t>());
  }






  template <typename TIterator, typename TCompare>
  [[nodiscard]]
  constexpr
  TIterator max_element(TIterator begin,
                        TIterator end,
                        TCompare compare)
  {
    TIterator maximum = begin;

    if (begin != end)
    {
      ++begin;

      while (begin != end)
      {
        if (!compare(*begin, *maximum))
        {
          maximum = begin;
        }

        ++begin;
      }
    }

    return maximum;
  }






  template <typename TIterator>
  [[nodiscard]]
  constexpr
  TIterator max_element(TIterator begin,
                        TIterator end)
  {
    typedef typename etl::iterator_traits<TIterator>::value_type value_t;

    return etl::max_element(begin, end, etl::less<value_t>());
  }






  template <typename TIterator, typename TCompare>
  [[nodiscard]]
  constexpr
  etl::pair<TIterator, TIterator> minmax_element(TIterator begin,
                                                        TIterator end,
                                                        TCompare compare)
  {
    TIterator minimum = begin;
    TIterator maximum = begin;

    if (begin != end)
    {
      ++begin;

      while (begin != end)
      {
        if (compare(*begin, *minimum))
        {
          minimum = begin;
        }

        if (compare(*maximum, *begin))
        {
          maximum = begin;
        }

        ++begin;
      }
    }

    return etl::pair<TIterator, TIterator>(minimum, maximum);
  }






  template <typename TIterator>
  [[nodiscard]]
  constexpr
  etl::pair<TIterator, TIterator> minmax_element(TIterator begin,
                                                        TIterator end)
  {
    typedef typename etl::iterator_traits<TIterator>::value_type value_t;

    return etl::minmax_element(begin, end, etl::less<value_t>());
  }






  template <typename T>
  [[nodiscard]]
  constexpr
  etl::pair<const T&, const T&> minmax(const T& a,
                                              const T& b)
  {
    return (b < a) ? etl::pair<const T&, const T&>(b, a) : etl::pair<const T&, const T&>(a, b);
  }






  template <typename T, typename TCompare>
  [[nodiscard]]
  constexpr
  etl::pair<const T&, const T&> minmax(const T& a,
                                              const T& b,
                                              TCompare compare)
  {
    return compare(b, a) ? etl::pair<const T&, const T&>(b, a) : etl::pair<const T&, const T&>(a, b);
  }






  template <typename TIterator>
  [[nodiscard]]
  constexpr
  TIterator is_sorted_until(TIterator begin,
                            TIterator end)
  {
    if (begin != end)
    {
      TIterator next = begin;

      while (++next != end)
      {
        if (*next < *begin)
        {
          return next;
        }

        ++begin;
      }
    }

    return end;
  }






  template <typename TIterator, typename TCompare>
  [[nodiscard]]
  constexpr
  TIterator is_sorted_until(TIterator begin,
                            TIterator end,
                            TCompare compare)
  {
    if (begin != end)
    {
      TIterator next = begin;

      while (++next != end)
      {
        if (compare(*next, *begin))
        {
          return next;
        }

        ++begin;
      }
    }

    return end;
  }






  template<typename TIterator>
  [[nodiscard]]
  constexpr
  bool is_sorted(TIterator begin,
                 TIterator end)
  {
    return etl::is_sorted_until(begin, end) == end;
  }






  template<typename TIterator, typename TCompare>
  [[nodiscard]]
  constexpr
  bool is_sorted(TIterator begin,
                 TIterator end,
                 TCompare compare)
  {
    return etl::is_sorted_until(begin, end, compare) == end;
  }





  template <typename TIterator, typename TCompare>
  [[nodiscard]]
  constexpr
  TIterator is_unique_sorted_until(TIterator begin,
                                   TIterator end,
                                   TCompare compare)
  {
    if (begin != end)
    {
      TIterator next = begin;

      while (++next != end)
      {
        if (!compare(*begin, *next))
        {
          return next;
        }

        ++begin;
      }
    }

    return end;
  }





  template <typename TIterator>
  [[nodiscard]]
  constexpr
  TIterator is_unique_sorted_until(TIterator begin,
                                   TIterator end)
  {
    if (begin != end)
    {
      TIterator next = begin;

      while (++next != end)
      {
        if (!(*begin < *next))
        {
          return next;
        }

        ++begin;
      }
    }

    return end;
  }





  template<typename TIterator>
  [[nodiscard]]
  constexpr
  bool is_unique_sorted(TIterator begin,
                        TIterator end)
  {
    return etl::is_unique_sorted_until(begin, end) == end;
  }





  template<typename TIterator, typename TCompare>
  [[nodiscard]]
    constexpr
    bool is_unique_sorted(TIterator begin,
                          TIterator end,
                          TCompare compare)
  {
    return etl::is_unique_sorted_until(begin, end, compare) == end;
  }






  template <typename TIterator, typename TUnaryPredicate>
  [[nodiscard]]
  constexpr
  TIterator find_if_not(TIterator begin,
                        TIterator end,
                        TUnaryPredicate predicate)
  {
    while (begin != end)
    {
      if (!predicate(*begin))
      {
        return begin;
      }

      ++begin;
    }

    return end;
  }






  template <typename TIterator1, typename TIterator2>
  [[nodiscard]]
  constexpr
  bool is_permutation(TIterator1 begin1,
                      TIterator1 end1,
                      TIterator2 begin2)
  {
    if (begin1 != end1)
    {
      TIterator2 end2 = begin2;

      etl::advance(end2, etl::distance(begin1, end1));

      for (TIterator1 i = begin1; i != end1; ++i)
      {
        if (i == etl::find(begin1, i, *i))
        {
          size_t n = etl::count(begin2, end2, *i);

          if (n == 0 || size_t(etl::count(i, end1, *i)) != n)
          {
            return false;
          }
        }
      }
    }

    return true;
  }






  template <typename TIterator1, typename TIterator2, typename TBinaryPredicate>
  [[nodiscard]]
  constexpr
  bool is_permutation(TIterator1 begin1,
                      TIterator1 end1,
                      TIterator2 begin2,
                      TBinaryPredicate predicate)
  {
    if (begin1 != end1)
    {
      TIterator2 end2 = begin2;

      etl::advance(end2, etl::distance(begin1, end1));

      for (TIterator1 i = begin1; i != end1; ++i)
      {
        if (i == etl::find_if(begin1, i, etl::bind1st(predicate, *i)))
        {
          size_t n = etl::count(begin2, end2, *i);

          if (n == 0 || size_t(etl::count(i, end1, *i)) != n)
          {
            return false;
          }
        }
      }
    }

    return true;
  }






  template <typename TIterator1, typename TIterator2>
  [[nodiscard]]
  constexpr
  bool is_permutation(TIterator1 begin1,
                      TIterator1 end1,
                      TIterator2 begin2,
                      TIterator2 end2)
  {
    if (begin1 != end1)
    {
      for (TIterator1 i = begin1; i != end1; ++i)
      {
        if (i == etl::find(begin1, i, *i))
        {
          size_t n = etl::count(begin2, end2, *i);

          if (n == 0 || size_t(etl::count(i, end1, *i)) != n)
          {
            return false;
          }
        }
      }
    }

    return true;
  }






  template <typename TIterator1, typename TIterator2, typename TBinaryPredicate>
  [[nodiscard]]
  bool is_permutation(TIterator1 begin1,
                      TIterator1 end1,
                      TIterator2 begin2,
                      TIterator2 end2,
                      TBinaryPredicate predicate)
  {
    if (begin1 != end1)
    {
      for (TIterator1 i = begin1; i != end1; ++i)
      {
        if (i == etl::find_if(begin1, i, etl::bind1st(predicate, *i)))
        {
          size_t n = etl::count(begin2, end2, *i);

          if (n == 0 || size_t(etl::count(i, end1, *i)) != n)
          {
            return false;
          }
        }
      }
    }

    return true;
  }






  template <typename TIterator, typename TUnaryPredicate>
  [[nodiscard]]
  constexpr
  bool is_partitioned(TIterator begin,
                      TIterator end,
                      TUnaryPredicate predicate)
  {
    while (begin != end)
    {
      if (!predicate(*begin))
      {
        break;
      }

      ++begin;
    }

    while (begin != end)
    {
      if (predicate(*begin))
      {
        return false;
      }

      ++begin;
    }

    return true;
  }






  template <typename TIterator, typename TUnaryPredicate>
  [[nodiscard]]
  constexpr
  TIterator partition_point(TIterator begin,
                            TIterator end,
                            TUnaryPredicate predicate)
  {
    while (begin != end)
    {
      if (!predicate(*begin))
      {
        return begin;
      }

      ++begin;
    }

    return begin;
  }







  template <typename TSource, typename TDestinationTrue, typename TDestinationFalse, typename TUnaryPredicate>
  constexpr
  etl::pair<TDestinationTrue, TDestinationFalse> partition_copy(TSource begin,
                                                                       TSource end,
                                                                       TDestinationTrue destination_true,
                                                                       TDestinationFalse destination_false,
                                                                       TUnaryPredicate predicate)
  {
    while (begin != end)
    {
      if (predicate(*begin))
      {
        *destination_true = *begin;
        ++destination_true;
      }
      else
      {
        *destination_false = *begin;
        ++destination_false;
      }

      ++begin;
    }

    return etl::pair<TDestinationTrue, TDestinationFalse>(destination_true, destination_false);
  }






  template <typename TIterator, typename TOutputIterator, typename TUnaryPredicate>
  constexpr
  TOutputIterator copy_if(TIterator begin,
                          TIterator end,
                          TOutputIterator out,
                          TUnaryPredicate predicate)
  {
    while (begin != end)
    {
      if (predicate(*begin))
      {
        *out = *begin;
        ++out;
      }

      ++begin;
    }

    return out;
  }






  template <typename TIterator, typename TUnaryPredicate>
  [[nodiscard]]
  constexpr
  bool all_of(TIterator begin,
              TIterator end,
              TUnaryPredicate predicate)
  {
    return etl::find_if_not(begin, end, predicate) == end;
  }






  template <typename TIterator, typename TUnaryPredicate>
  [[nodiscard]]
  constexpr
  bool any_of(TIterator begin,
              TIterator end,
              TUnaryPredicate predicate)
  {
    return etl::find_if(begin, end, predicate) != end;
  }






  template <typename TIterator, typename TUnaryPredicate>
  [[nodiscard]]
  constexpr
  bool none_of(TIterator begin,
               TIterator end,
               TUnaryPredicate predicate)
  {
    return etl::find_if(begin, end, predicate) == end;
  }







  template <typename TIterator, typename TCompare>
  void sort(TIterator first, TIterator last, TCompare compare)
  {
    etl::shell_sort(first, last, compare);
  }





  template <typename TIterator>
  void sort(TIterator first, TIterator last)
  {
    etl::shell_sort(first, last, etl::less<typename etl::iterator_traits<TIterator>::value_type>());
  }







  template <typename TIterator, typename TCompare>
  void stable_sort(TIterator first, TIterator last, TCompare compare)
  {
    etl::insertion_sort(first, last, compare);
  }






  template <typename TIterator>
  void stable_sort(TIterator first, TIterator last)
  {
    etl::insertion_sort(first, last, etl::less<typename etl::iterator_traits<TIterator>::value_type>());
  }
# 2232 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator, typename T>
  constexpr
  T accumulate(TIterator first, TIterator last, T sum)
  {
    while (first != last)
    {
      sum = etl::move(sum) + *first;
      ++first;
    }

    return sum;
  }





  template <typename TIterator, typename T, typename TBinaryOperation>
  constexpr
  T accumulate(TIterator first, TIterator last, T sum, TBinaryOperation operation)
  {
    while (first != last)
    {
      sum = operation(etl::move(sum), *first);
      ++first;
    }

    return sum;
  }





  template<typename T, typename TCompare>
  constexpr
  T clamp(const T& value, const T& low, const T& high, TCompare compare)
  {
    return compare(value, low) ? low : compare(high, value) ? high : value;
  }

  template <typename T>
  constexpr
  T clamp(const T& value, const T& low, const T& high)
  {
    return clamp(value, low, high, etl::less<T>());
  }

  template<typename T, T Low, T High, typename TCompare>
  constexpr
  T clamp(const T& value, TCompare compare)
  {
    return compare(value, Low) ? Low : compare(High, value) ? High : value;
  }

  template <typename T, T Low, T High>
  constexpr
  T clamp(const T& value)
  {
    return clamp<T, Low, High>(value, etl::less<T>());
  }





  template <typename TIterator, typename T>
  constexpr
  TIterator remove(TIterator first, TIterator last, const T& value)
  {
    first = etl::find(first, last, value);

    if (first != last)
    {
      TIterator itr = first;

      while (++itr != last)
      {
        if (!(*itr == value))
        {
          *first++ = etl::move(*itr);
        }
      }
    }

    return first;
  }





  template <typename TIterator, typename TUnaryPredicate>
  constexpr
  TIterator remove_if(TIterator first, TIterator last, TUnaryPredicate predicate)
  {
    first = etl::find_if(first, last, predicate);

    if (first != last)
    {
      TIterator itr = first;

      while (++itr != last)
      {
        if (!predicate(*itr))
        {
          *first++ = etl::move(*itr);
        }
      }
    }

    return first;
  }
}




namespace etl
{
# 2363 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TInputIterator,
            typename TOutputIterator>
  constexpr
  typename etl::enable_if<etl::is_random_iterator<TInputIterator>::value &&
                          etl::is_random_iterator<TOutputIterator>::value, TOutputIterator>::type
    copy_s(TInputIterator i_begin,
           TInputIterator i_end,
           TOutputIterator o_begin,
           TOutputIterator o_end)
  {
    typedef typename iterator_traits<TInputIterator>::difference_type s_size_type;
    typedef typename iterator_traits<TOutputIterator>::difference_type d_size_type;


    typedef typename etl::common_type<s_size_type, d_size_type>::type min_size_type;




    s_size_type s_size = etl::distance(i_begin, i_end);
    d_size_type d_size = etl::distance(o_begin, o_end);
    min_size_type min_size = etl::min<min_size_type>(s_size, d_size);

    return etl::copy(i_begin, i_begin + min_size, o_begin);
  }
# 2400 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TInputIterator,
            typename TOutputIterator>
  constexpr
  typename etl::enable_if<!etl::is_random_iterator<TInputIterator>::value ||
                          !etl::is_random_iterator<TOutputIterator>::value, TOutputIterator>::type
   copy_s(TInputIterator i_begin,
          TInputIterator i_end,
          TOutputIterator o_begin,
          TOutputIterator o_end)
  {
    while ((i_begin != i_end) && (o_begin != o_end))
    {
      *o_begin = *i_begin;
      ++o_begin;
      ++i_begin;
    }

    return o_begin;
  }






  template <typename TInputIterator,
            typename TSize,
            typename TOutputIterator>
  constexpr
  TOutputIterator copy_n_s(TInputIterator i_begin,
                           TSize n,
                           TOutputIterator o_begin,
                           TOutputIterator o_end)
  {
    while ((n-- > 0) && (o_begin != o_end))
    {
      *o_begin = *i_begin;
      ++o_begin;
      ++i_begin;
    }

    return o_begin;
  }






  template <typename TInputIterator,
            typename TSize1,
            typename TOutputIterator,
            typename TSize2>
  constexpr
  TOutputIterator copy_n_s(TInputIterator i_begin,
                           TSize1 n1,
                           TOutputIterator o_begin,
                           TSize2 n2)
  {
    while ((n1-- > 0) && (n2-- > 0))
    {
      *o_begin = *i_begin;
      ++o_begin;
      ++i_begin;
    }

    return o_begin;
  }







  template <typename TInputIterator,
            typename TOutputIterator,
            typename TUnaryPredicate>
  constexpr
  TOutputIterator copy_if_s(TInputIterator i_begin,
                            TInputIterator i_end,
                            TOutputIterator o_begin,
                            TOutputIterator o_end,
                            TUnaryPredicate predicate)
  {
    while ((i_begin != i_end) && (o_begin != o_end))
    {
      if (predicate(*i_begin))
      {
        *o_begin = *i_begin;
        ++o_begin;
      }

      ++i_begin;
    }

    return o_begin;
  }






  template <typename TInputIterator,
            typename TSize,
            typename TOutputIterator,
            typename TUnaryPredicate>
  constexpr
  TOutputIterator copy_n_if(TInputIterator i_begin,
                            TSize n,
                            TOutputIterator o_begin,
                            TUnaryPredicate predicate)
  {
    while (n-- > 0)
    {
      if (predicate(*i_begin))
      {
        *o_begin = *i_begin;
        ++o_begin;
      }

      ++i_begin;
    }

    return o_begin;
  }
# 2540 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TInputIterator, typename TOutputIterator>
  constexpr
  typename etl::enable_if<etl::is_random_iterator<TInputIterator>::value &&
                          etl::is_random_iterator<TOutputIterator>::value, TOutputIterator>::type
  move_s(TInputIterator i_begin,
         TInputIterator i_end,
         TOutputIterator o_begin,
         TOutputIterator o_end)
  {
    using s_size_type = typename iterator_traits<TInputIterator>::difference_type;
    using d_size_type = typename iterator_traits<TOutputIterator>::difference_type;
    using min_size_type = typename etl::common_type<s_size_type, d_size_type>::type;

    s_size_type s_size = etl::distance(i_begin, i_end);
    d_size_type d_size = etl::distance(o_begin, o_end);
    min_size_type min_size = etl::min<min_size_type>(s_size, d_size);

    return etl::move(i_begin, i_begin + min_size, o_begin);
  }
# 2571 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TInputIterator, typename TOutputIterator>
  constexpr
  typename etl::enable_if<!etl::is_random_iterator<TInputIterator>::value ||
                          !etl::is_random_iterator<TOutputIterator>::value, TOutputIterator>::type
  move_s(TInputIterator i_begin,
         TInputIterator i_end,
         TOutputIterator o_begin,
         TOutputIterator o_end)
  {
    while ((i_begin != i_end) && (o_begin != o_end))
    {
      *o_begin = etl::move(*i_begin);
      ++i_begin;
      ++o_begin;
    }

    return o_begin;
  }
# 2618 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
  template <typename TIterator, typename TValue>
  [[nodiscard]]
  constexpr
  TIterator binary_find(TIterator begin,
                        TIterator end,
                        const TValue& value)
  {
    TIterator it = etl::lower_bound(begin, end, value);

    if ((it == end) || (*it != value))
    {
      it = end;
    }

    return it;
  }






  template <typename TIterator,
            typename TValue,
            typename TBinaryPredicate,
            typename TBinaryEquality>
  [[nodiscard]]
  constexpr
  TIterator binary_find(TIterator begin,
                        TIterator end,
                        const TValue& value,
                        TBinaryPredicate predicate,
                        TBinaryEquality equality)
  {
    TIterator it = etl::lower_bound(begin, end, value, predicate);

    if ((it == end) || !equality(*it, value))
    {
      it = end;
    }

    return it;
  }





  template <typename TIterator,
            typename TUnaryFunction,
            typename TUnaryPredicate>
  constexpr
  TUnaryFunction for_each_if(TIterator begin,
                             const TIterator end,
                             TUnaryFunction function,
                             TUnaryPredicate predicate)
  {
    while (begin != end)
    {
      if (predicate(*begin))
      {
        function(*begin);
      }

      ++begin;
    }

    return function;
  }





  template <typename TIterator,
            typename TSize,
            typename TUnaryFunction>
  constexpr
  TIterator for_each_n(TIterator begin,
                       TSize n,
                       TUnaryFunction function)
  {
    while (n-- > 0)
    {
      function(*begin);
      ++begin;
    }

    return begin;
  }





  template <typename TIterator,
            typename TSize,
            typename TUnaryFunction,
            typename TUnaryPredicate>
  constexpr
  TIterator for_each_n_if(TIterator begin,
                          TSize n,
                          TUnaryFunction function,
                          TUnaryPredicate predicate)
  {
    while (n-- > 0)
    {
      if (predicate(*begin))
      {
        function(*begin);
      }

      ++begin;
    }

    return begin;
  }







  template <typename TInputIterator, typename TOutputIterator, typename TUnaryFunction>
  constexpr
  TOutputIterator transform_s(TInputIterator i_begin,
                              TInputIterator i_end,
                              TOutputIterator o_begin,
                              TOutputIterator o_end,
                              TUnaryFunction function)
  {
    while ((i_begin != i_end) && (o_begin != o_end))
    {
      *o_begin = function(*i_begin);
      ++i_begin;
      ++o_begin;
    }

    return o_begin;
  }







  template <typename TInputIterator,
            typename TSize,
            typename TOutputIterator,
            typename TUnaryFunction>
  constexpr
  void transform_n(TInputIterator i_begin,
                   TSize n,
                   TOutputIterator o_begin,
                   TUnaryFunction function)
  {
    TInputIterator i_end(i_begin);
    etl::advance(i_end, n);

    etl::transform(i_begin, i_end, o_begin, function);
  }







  template <typename TInputIterator1,
            typename TInputIterator2,
            typename TSize,
            typename TOutputIterator,
            typename TBinaryFunction>
  constexpr
  void transform_n(TInputIterator1 i_begin1,
                   TInputIterator2 i_begin2,
                   TSize n,
                   TOutputIterator o_begin,
                   TBinaryFunction function)
  {
    TInputIterator1 i_end1(i_begin1);
    etl::advance(i_end1, n);

    etl::transform(i_begin1, i_end1, i_begin2, o_begin, function);
  }





  template <typename TInputIterator,
            typename TOutputIterator,
            typename TUnaryFunction,
            typename TUnaryPredicate>
  constexpr
  TOutputIterator transform_if(TInputIterator i_begin,
                               const TInputIterator i_end,
                               TOutputIterator o_begin,
                               TUnaryFunction function,
                               TUnaryPredicate predicate)
  {
    while (i_begin != i_end)
    {
      if (predicate(*i_begin))
      {
        *o_begin = function(*i_begin);
        ++o_begin;
      }

      ++i_begin;
    }

    return o_begin;
  }





  template <typename TInputIterator1,
            typename TInputIterator2,
            typename TOutputIterator,
            typename TBinaryFunction,
            typename TBinaryPredicate>
  constexpr
  TOutputIterator transform_if(TInputIterator1 i_begin1,
                               const TInputIterator1 i_end1,
                               TInputIterator2 i_begin2,
                               TOutputIterator o_begin,
                               TBinaryFunction function,
                               TBinaryPredicate predicate)
  {
    while (i_begin1 != i_end1)
    {
      if (predicate(*i_begin1, *i_begin2))
      {
        *o_begin = function(*i_begin1, *i_begin2);
        ++o_begin;
      }

      ++i_begin1;
      ++i_begin2;
    }

    return o_begin;
  }





  template <typename TInputIterator,
            typename TSize,
            typename TOutputIterator,
            typename TUnaryFunction,
            typename TUnaryPredicate>
  constexpr
  TOutputIterator transform_n_if(TInputIterator i_begin,
                                 TSize n,
                                 TOutputIterator o_begin,
                                 TUnaryFunction function,
                                 TUnaryPredicate predicate)
  {
    while (n-- > 0)
    {
      if (predicate(*i_begin))
      {
        *o_begin = function(*i_begin);
        ++o_begin;
      }

      ++i_begin;
    }

    return o_begin;
  }





  template <typename TInputIterator1,
            typename TInputIterator2,
            typename TSize,
            typename TOutputIterator,
            typename TBinaryFunction,
            typename TBinaryPredicate>
  constexpr
  TOutputIterator transform_n_if(TInputIterator1 i_begin1,
                                 TInputIterator2 i_begin2,
                                 TSize n,
                                 TOutputIterator o_begin,
                                 TBinaryFunction function,
                                 TBinaryPredicate predicate)
  {
    while (n-- > 0)
    {
      if (predicate(*i_begin1, *i_begin2))
      {
        *o_begin++ = function(*i_begin1, *i_begin2);
      }

      ++i_begin1;
      ++i_begin2;
    }

    return o_begin;
  }






  template <typename TSource, typename TDestinationTrue, typename TDestinationFalse,
            typename TUnaryFunctionTrue, typename TUnaryFunctionFalse,
            typename TUnaryPredicate>
  constexpr
  etl::pair<TDestinationTrue, TDestinationFalse> partition_transform(TSource begin,
                                                                            TSource end,
                                                                            TDestinationTrue destination_true,
                                                                            TDestinationFalse destination_false,
                                                                            TUnaryFunctionTrue function_true,
                                                                            TUnaryFunctionFalse function_false,
                                                                            TUnaryPredicate predicate)
  {
    while (begin != end)
    {
      if (predicate(*begin))
      {
        *destination_true = function_true(*begin);
        ++destination_true;
      }
      else
      {
        *destination_false = function_false(*begin);
        ++destination_false;
      }

      ++begin;
    }

    return etl::pair<TDestinationTrue, TDestinationFalse>(destination_true, destination_false);
  }






  template <typename TSource1,
            typename TSource2,
            typename TDestinationTrue,
            typename TDestinationFalse,
            typename TBinaryFunctionTrue,
            typename TBinaryFunctionFalse,
            typename TBinaryPredicate>
  constexpr
  etl::pair<TDestinationTrue, TDestinationFalse> partition_transform(TSource1 begin1,
                                                                            TSource1 end1,
                                                                            TSource2 begin2,
                                                                            TDestinationTrue destination_true,
                                                                            TDestinationFalse destination_false,
                                                                            TBinaryFunctionTrue function_true,
                                                                            TBinaryFunctionFalse function_false,
                                                                            TBinaryPredicate predicate)
  {
    while (begin1 != end1)
    {
      if (predicate(*begin1, *begin2))
      {
        *destination_true = function_true(*begin1, *begin2);
        ++destination_true;
      }
      else
      {
        *destination_false = function_false(*begin1, *begin2);
        ++destination_false;
      }

      ++begin1;
      ++begin2;
    }

    return etl::pair<TDestinationTrue, TDestinationFalse>(destination_true, destination_false);
  }






  template <typename TIterator, typename TCompare>



  constexpr

  void shell_sort(TIterator first, TIterator last, TCompare compare)
  {
    if (first == last)
    {
      return;
    }

    typedef typename etl::iterator_traits<TIterator>::difference_type difference_t;

    difference_t n = etl::distance(first, last);

    for (difference_t i = n / 2; i > 0; i /= 2)
    {
      for (difference_t j = i; j < n; ++j)
      {
        for (difference_t k = j - i; k >= 0; k -= i)
        {
          TIterator itr1 = first;
          TIterator itr2 = first;

          etl::advance(itr1, k);
          etl::advance(itr2, k + i);

          if (compare(*itr2, *itr1))
          {
            etl::iter_swap(itr1, itr2);
          }
        }
      }
    }
  }





  template <typename TIterator>



  constexpr

  void shell_sort(TIterator first, TIterator last)
  {
    etl::shell_sort(first, last, etl::less<typename etl::iterator_traits<TIterator>::value_type>());
  }






  template <typename TIterator, typename TCompare>
  constexpr
  void insertion_sort(TIterator first, TIterator last, TCompare compare)
  {
    for (TIterator itr = first; itr != last; ++itr)
    {
      etl::rotate(etl::upper_bound(first, itr, *itr, compare), itr, etl::next(itr));
    }
  }





  template <typename TIterator>
  constexpr
  void insertion_sort(TIterator first, TIterator last)
  {
    etl::insertion_sort(first, last, etl::less<typename etl::iterator_traits<TIterator>::value_type>());
  }


  namespace private_algorithm
  {
    template <typename TIterator>
    constexpr
    typename etl::enable_if<etl::is_forward_iterator<TIterator>::value, TIterator>::type
      get_before_last(TIterator first_, TIterator last_)
    {
      TIterator last = first_;
      TIterator lastplus1 = first_;
      ++lastplus1;

      while (lastplus1 != last_)
      {
        ++last;
        ++lastplus1;
      }

      return last;
    }

    template <typename TIterator>
    constexpr
    typename etl::enable_if<etl::is_bidirectional_iterator<TIterator>::value, TIterator>::type
      get_before_last(TIterator , TIterator last_)
    {
      TIterator last = last_;
      --last;

      return last;
    }

    template <typename TIterator>
    constexpr
    typename etl::enable_if<etl::is_random_access_iterator<TIterator>::value, TIterator>::type
      get_before_last(TIterator , TIterator last_)
    {
      return last_ - 1;
    }
  }






  template <typename TIterator, typename TCompare>
  constexpr
  void selection_sort(TIterator first, TIterator last, TCompare compare)
  {
    TIterator min;
    const TIterator ilast = private_algorithm::get_before_last(first, last);
    const TIterator jlast = last;

    for (TIterator i = first; i != ilast; ++i)
    {
      min = i;

      TIterator j = i;
      ++j;

      for (; j != jlast; ++j)
      {
        if (compare(*j, *min))
        {
          min = j;
        }
      }

      using etl::swap;
      swap(*i, *min);
    }
  }





  template <typename TIterator>
  constexpr
  void selection_sort(TIterator first, TIterator last)
  {
    selection_sort(first, last, etl::less<typename etl::iterator_traits<TIterator>::value_type>());
  }






  template <typename TIterator, typename TCompare>
  constexpr
  void heap_sort(TIterator first, TIterator last, TCompare compare)
  {
    if (!etl::is_heap(first, last, compare))
    {
      etl::make_heap(first, last, compare);
    }

    etl::sort_heap(first, last, compare);
  }





  template <typename TIterator>
  constexpr
  void heap_sort(TIterator first, TIterator last)
  {
    if (!etl::is_heap(first, last))
    {
      etl::make_heap(first, last);
    }

    etl::sort_heap(first, last);
  }





  template <typename T>
  [[nodiscard]]
  constexpr const T& multimax(const T& a, const T& b)
  {
    return a < b ? b : a;
  }

  template <typename T, typename... Tx>
  [[nodiscard]]
  constexpr const T& multimax(const T& t, const Tx&... tx)
  {
    return multimax(t, multimax(tx...));
  }







  template <typename TCompare, typename T>
  [[nodiscard]]
  constexpr const T& multimax_compare(TCompare compare, const T& a, const T& b)
  {
    return compare(a, b) ? b : a;
  }

  template <typename TCompare, typename T, typename... Tx>
  [[nodiscard]]
  constexpr const T& multimax_compare(TCompare compare, const T& t, const Tx&... tx)
  {
    return multimax_compare(compare, t, multimax_compare(compare, tx...));
  }






  template <typename T>
  [[nodiscard]]
  constexpr const T& multimin(const T& a, const T& b)
  {
    return a < b ? a : b;
  }

  template <typename T, typename... Tx>
  [[nodiscard]]
  constexpr const T& multimin(const T& t, const Tx&... tx)
  {
    return multimin(t, multimin(tx...));
  }







  template <typename TCompare, typename T>
  [[nodiscard]]
  constexpr const T& multimin_compare(TCompare compare, const T& a, const T& b)
  {
    return compare(a, b) ? a : b;
  }

  template <typename TCompare, typename T, typename... Tx>
  [[nodiscard]]
  constexpr const T& multimin_compare(TCompare compare, const T& t, const Tx&... tx)
  {
    return multimin_compare(compare, t, multimin_compare(compare, tx...));
  }






  template <typename TIterator>
  [[nodiscard]]
  constexpr const TIterator& multimax_iter(const TIterator& a, const TIterator& b)
  {
    return *a < *b ? b : a;
  }

  template <typename TIterator, typename... TIteratorx>
  [[nodiscard]]
  constexpr const TIterator& multimax_iter(const TIterator& t, const TIteratorx&... tx)
  {
    return multimax_iter(t, multimax_iter(tx...));
  }







  template <typename TCompare, typename TIterator>
  [[nodiscard]]
  constexpr const TIterator& multimax_iter_compare(TCompare compare, const TIterator& a, const TIterator& b)
  {
    return compare(*a, *b) ? b : a;
  }

  template <typename TCompare, typename TIterator, typename... TIteratorx>
  [[nodiscard]]
  constexpr const TIterator& multimax_iter_compare(TCompare compare, const TIterator& t, const TIteratorx&... tx)
  {
    return multimax_iter_compare(compare, t, multimax_iter_compare(compare, tx...));
  }






  template <typename TIterator>
  [[nodiscard]]
  constexpr const TIterator& multimin_iter(const TIterator& a, const TIterator& b)
  {
    return *a < *b ? a : b;
  }

  template <typename TIterator, typename... Tx>
  [[nodiscard]]
  constexpr const TIterator& multimin_iter(const TIterator& t, const Tx&... tx)
  {
    return multimin_iter(t, multimin_iter(tx...));
  }







  template <typename TCompare, typename TIterator>
  [[nodiscard]]
  constexpr const TIterator& multimin_iter_compare(TCompare compare, const TIterator& a, const TIterator& b)
  {
    return compare(*a, *b) ? a : b;
  }

  template <typename TCompare, typename TIterator, typename... Tx>
  [[nodiscard]]
  constexpr const TIterator& multimin_iter_compare(TCompare compare, const TIterator& t, const Tx&... tx)
  {
    return multimin_iter_compare(compare, t, multimin_iter_compare(compare, tx...));
  }







  template <typename TIterator, typename TPredicate>
  constexpr
  typename etl::enable_if<etl::is_forward_iterator<TIterator>::value, TIterator>::type
    partition(TIterator first, TIterator last, TPredicate predicate)
  {
    first = etl::find_if_not(first, last, predicate);

    if (first == last)
    {
      return first;
    }

    for (TIterator i = etl::next(first); i != last; ++i)
    {
      if (predicate(*i))
      {
        using etl::swap;
        swap(*i, *first);
        ++first;
      }
    }

    return first;
  }






  template <typename TIterator, typename TPredicate>
  constexpr
  typename etl::enable_if<etl::is_bidirectional_iterator_concept<TIterator>::value, TIterator>::type
    partition(TIterator first, TIterator last, TPredicate predicate)
  {
    while (first != last)
    {
      first = etl::find_if_not(first, last, predicate);

      if (first == last)
      {
        break;
      }

      last = etl::find_if(etl::reverse_iterator<TIterator>(last),
                          etl::reverse_iterator<TIterator>(first),
                          predicate).base();

      if (first == last)
      {
        break;
      }

      --last;
      using etl::swap;
      swap(*first, *last);
      ++first;
    }

    return first;
  }


  namespace private_algorithm
  {
    using etl::swap;

    template <typename TIterator, typename TCompare>

    constexpr

    TIterator nth_partition(TIterator first, TIterator last, TCompare compare)
    {
      typedef typename etl::iterator_traits<TIterator>::value_type value_type;

      TIterator pivot = last;
      value_type pivot_value = *pivot;


      if (pivot != last)
      {
        swap(*pivot, *last);
      }

      TIterator i = first;

      for (TIterator j = first; j < last; ++j)
      {
        if (!compare(pivot_value, *j))
        {
          swap(*i, *j);
          ++i;
        }
      }

      swap(*i, *last);

      return i;
    }
  }






  template <typename TIterator, typename TCompare = etl::less<typename etl::iterator_traits<TIterator>::value_type>>

  constexpr

  typename etl::enable_if<etl::is_random_access_iterator_concept<TIterator>::value, void>::type
    nth_element(TIterator first, TIterator nth, TIterator last, TCompare compare = TCompare())
  {
    if (first == last)
    {
      return;
    }


    --last;

    while (first <= last)
    {
      TIterator p = private_algorithm::nth_partition(first, last, compare);

      if (p == nth)
      {
        return;
      }
      else if (p > nth)
      {
        last = p - 1;
      }
      else
      {
        first = p + 1;
      }
    }
  }
# 3554 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h"
}

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
             
             
# 52 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
#undef ETL_PUSHED_MIN_MAX
# 3557 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/algorithm.h" 2
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
#define ETL_ALIGNMENT_INCLUDED 


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h" 2
# 48 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
namespace etl
{



  class alignment_exception : public etl::exception
  {
  public:

    alignment_exception(string_type reason_, string_type file_name_, numeric_type line_number_)
      : exception(reason_, file_name_, line_number_)
    {
    }
  };




  class alignment_error : public alignment_exception
  {
  public:

    alignment_error(string_type file_name_, numeric_type line_number_)
      : alignment_exception(("71""A"), file_name_, line_number_)
    {
    }
  };




  class typed_storage_error : public alignment_exception
  {
  public:

    typed_storage_error(string_type file_name_, numeric_type line_number_)
      : alignment_exception(("71""B"), file_name_, line_number_)
    {
    }
  };




  inline bool is_aligned(const void* p, size_t required_alignment)
  {
    uintptr_t address = reinterpret_cast<uintptr_t>(p);
    return (address % required_alignment) == 0U;
  }




  template <size_t Alignment>
  bool is_aligned(const void* p)
  {
    uintptr_t address = reinterpret_cast<uintptr_t>(p);
    return (address % Alignment) == 0U;
  }




  template <typename T>
  bool is_aligned(const void* p)
  {
    return is_aligned<etl::alignment_of<T>::value>(p);
  }

  namespace private_alignment
  {




    template <bool Is_Match, size_t Alignment, typename... TRest>
    class type_with_alignment_matcher;


    template <size_t Alignment, typename T1, typename... TRest>
    class type_with_alignment_matcher<true, Alignment, T1, TRest...>
    {
    public:

      typedef T1 type;
    };


    template <size_t Alignment, typename T1, typename T2, typename... TRest>
    class type_with_alignment_matcher <false, Alignment, T1, T2, TRest...>
    {
    public:

      typedef typename type_with_alignment_matcher < Alignment <= etl::alignment_of<T2>::value , Alignment, T2, TRest... > ::type type;
    };


    template <size_t Alignment, typename T1>
    class type_with_alignment_matcher <false, Alignment, T1>
    {
    public:

      typedef char type;
    };




    template <size_t Alignment, typename T1, typename... T>
    class type_with_alignment_helper
    {
    public:

      typedef typename type_with_alignment_matcher<Alignment <= etl::alignment_of<T1>::value, Alignment, T1, T...>::type type;
    };
# 210 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
  }





  template <size_t Alignment>
  class type_with_alignment
  {
  public:


    typedef struct { alignas(Alignment) char dummy; } type;
# 231 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
    static_assert(etl::alignment_of<type>::value == Alignment, "Unable to create the type with the specified alignment");
  };


  template <size_t Alignment>
  using type_with_alignment_t = typename type_with_alignment<Alignment>::type;







  template <size_t Length, const size_t Alignment>
  struct aligned_storage
  {
    struct type
    {

      template <typename T>
      operator T& ()
      {
        static_assert((etl::is_same<T*, void*>:: value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
        T* t = *this;
        return *t;
      }


      template <typename T>
      operator const T& () const
      {
        static_assert((etl::is_same<T*, void*>:: value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
        const T* t = *this;
        return *t;
      }


      template <typename T>
      operator T* ()
      {
        static_assert((etl::is_same<T*, void*>:: value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
        return reinterpret_cast<T*>(data);
      }


      template <typename T>
      operator const T* () const
      {
        static_assert((etl::is_same<T*, void*>:: value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
        return reinterpret_cast<const T*>(data);
      }


      template <typename T>
      T& get_reference()
      {
        static_assert((etl::is_same<T*, void*>:: value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
        T* t = *this;
        return *t;
      }


      template <typename T>
      const T& get_reference() const
      {
        static_assert((etl::is_same<T*, void*>:: value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
        const T* t = *this;
        return *t;
      }


      template <typename T>
      T* get_address()
      {
        static_assert((etl::is_same<T*, void*>:: value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
        return reinterpret_cast<T*>(data);
      }


      template <typename T>
      const T* get_address() const
      {
        static_assert((etl::is_same<T*, void*>:: value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
        return reinterpret_cast<const T*>(data);
      }


      alignas(Alignment) char data[Length];







    };
  };


  template <size_t Length, const size_t Alignment>
  using aligned_storage_t = typename aligned_storage<Length, Alignment>::type;






  template <size_t Length, typename T>
  struct aligned_storage_as : public etl::aligned_storage<Length, etl::alignment_of<T>::value>
  {
  };


  template <size_t Length, typename T>
  using aligned_storage_as_t = typename aligned_storage_as<Length, T>::type;
# 356 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
  template <typename T>
  class typed_storage
  {
  public:

    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* pointer;
    typedef const T* const_pointer;




    typed_storage()
      : valid(false)
    {
    }





    template <typename... TArgs>
    typed_storage(TArgs&&... args)
      : valid(false)
    {
      create(etl::forward<TArgs>(args)...);
    }
# 431 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
    ~typed_storage()
    {

    }





    bool has_value() const
    {
      return valid;
    }






    template <typename... TArgs>
    reference create(TArgs&&... args)
    {
      static_cast<void>(sizeof(!has_value()));
      pointer p = ::new (&storage.value) value_type(etl::forward<TArgs>(args)...);
      valid = true;
      return *p;
    }
# 515 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
    void destroy()
    {
      if (has_value())
      {
        storage.value.~T();
        valid = false;
      }
    }




    pointer operator->()
    {
      static_cast<void>(sizeof(has_value()));

      return &storage.value;
    }




    const_pointer operator->() const
    {
      static_cast<void>(sizeof(has_value()));

      return &storage.value;
    }




    reference operator*()
    {
      return *operator->();
    }




    const_reference operator*() const
    {
      return *operator->();
    }

  private:

    typed_storage(etl::typed_storage<T>&) = delete;
    typed_storage& operator =(etl::typed_storage<T>&) = delete;

    struct dummy_t {};


    union union_type
    {
      union_type()
        : dummy()
      {
      }

      ~union_type()
      {
      }

      dummy_t dummy;
      value_type value;
    } storage;

    bool valid;
  };
# 594 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
  template <typename T>
  class typed_storage_ext
  {
  public:

    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* pointer;
    typedef const T* const_pointer;

    template <typename U>
    friend constexpr void swap(typed_storage_ext<U>& lhs, typed_storage_ext<U>& rhs) ;




    typed_storage_ext(void* pbuffer_)
      : pbuffer(reinterpret_cast<T*>(pbuffer_)),
        valid(false)
    {
      static_cast<void>(sizeof(etl::is_aligned(pbuffer_, etl::alignment_of<T>::value)));
    }





    template <typename... TArgs>
    typed_storage_ext(void* pbuffer_, TArgs&&... args)
      : pbuffer(reinterpret_cast<T*>(pbuffer_))
      , valid(false)
    {
      static_cast<void>(sizeof(etl::is_aligned(pbuffer_, etl::alignment_of<T>::value)));
      create(etl::forward<TArgs>(args)...);
    }





    typed_storage_ext(typed_storage_ext<T>&& other)
      : pbuffer(other.pbuffer)
      , valid(other.valid)
    {
      other.pbuffer = nullptr;
      other.valid = false;
    }
# 696 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
    ~typed_storage_ext()
    {

    }





    bool has_value() const
    {
      return valid;
    }






    template <typename... TArgs>
    reference create(TArgs&&... args)
    {
      static_cast<void>(sizeof(!has_value()));
      pointer p = ::new (pbuffer) value_type(etl::forward<TArgs>(args)...);
      valid = true;
      return *p;
    }
# 780 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/alignment.h"
    void destroy()
    {
      if (has_value())
      {
        pbuffer->~T();
        valid = false;
      }
    }




    pointer operator->()
    {
      static_cast<void>(sizeof(has_value()));

      return pbuffer;
    }




    const_pointer operator->() const
    {
      static_cast<void>(sizeof(has_value()));

      return pbuffer;
    }




    reference operator*()
    {
      return *operator->();
    }




    const_reference operator*() const
    {
      return *operator->();
    }

  private:

    typed_storage_ext(etl::typed_storage_ext<T>&) = delete;
    typed_storage_ext& operator =(etl::typed_storage_ext<T>&) = delete;

    pointer pbuffer;
    bool valid;
  };




  template <typename T>
  constexpr void swap(etl::typed_storage_ext<T>& lhs, etl::typed_storage_ext<T>& rhs)
  {
    using etl::swap;

    swap(lhs.pbuffer, rhs.pbuffer);
    swap(lhs.valid, rhs.valid);
  }
}
# 39 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
#define ETL_ARRAY_INCLUDED 






# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 40 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/parameter_type.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/parameter_type.h"
#define ETL_PARAMETER_INCLUDED 


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/parameter_type.h" 2

namespace etl
{



  template <typename T>
  struct parameter_type
  {

    typedef typename etl::conditional<etl::is_fundamental<T>::value || etl::is_pointer<T>::value,
                                         T,
                                         const T&>::type type;
  };


  template <typename T>
  using parameter_type_t = typename etl::parameter_type<T>::type;

}
# 41 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h" 2


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/nth_type.h" 1
# 30 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/nth_type.h"
#define ETL_NTH_TYPE_INCLUDED 





namespace etl
{
  namespace private_nth_type
  {

    template <size_t Index, typename T1, typename... TRest>
    struct nth_type_helper
    {
      using type = typename nth_type_helper<Index - 1U, TRest...>::type;
    };

    template <typename T1, typename... TRest>
    struct nth_type_helper<0U, T1, TRest...>
    {
      using type = T1;
    };
  }


  template <size_t Index, typename... TTypes>
  struct nth_type
  {
    static_assert(Index < sizeof...(TTypes), "etl::nth_type index 'Index' out of bounds");

    using type = typename private_nth_type::nth_type_helper<Index, TTypes...>::type;
  };


  template <size_t Index, typename... TTypes>
  using nth_type_t = typename nth_type<Index, TTypes...>::type;
}
# 44 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/initializer_list.h" 1
# 34 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/initializer_list.h"
#define ETL_INITIALIZER_LIST_INCLUDED 







# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 43 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/initializer_list.h" 2
# 52 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/initializer_list.h"
namespace std
{
# 142 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/initializer_list.h"
  template<class T>
  class initializer_list
  {
  public:

    using value_type = T;
    using reference = const T&;
    using const_reference = const T&;
    using size_type = size_t;
    using iterator = const T*;
    using const_iterator = const T*;




    constexpr initializer_list()
      : pfirst(nullptr), length(0)
    {
    }




    constexpr const T* begin() const
    {
      return pfirst;
    }




    constexpr const T* end() const
    {
      return pfirst + length;
    }




    constexpr size_t size() const
    {
      return length;
    }

  private:




    constexpr initializer_list(const T* pfirst_, size_t length_)
      : pfirst(pfirst_)
      , length(length_)
    {
    }

    const T* pfirst;
    size_t length;
  };




  template<class T>
  constexpr const T* begin(initializer_list<T> init)
  {
    return init.begin();
  }




  template<class T>
  constexpr const T* end(initializer_list<T> init)
  {
    return init.end();
  }





}
# 45 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h" 2

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 47 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h" 2





namespace etl
{




  class array_exception : public exception
  {
  public:

    array_exception(string_type reason_, string_type file_name_, numeric_type line_number_)
      : exception(reason_, file_name_, line_number_)
    {
    }
  };





  class array_out_of_range : public array_exception
  {
  public:

    array_out_of_range(string_type file_name_, numeric_type line_number_)
      : array_exception("array:range", file_name_, line_number_)
    {
    }
  };





  template <typename T, size_t SIZE_>
  class array
  {
  private:

    typedef typename etl::parameter_type<T>::type parameter_t;

  public:

    static constexpr size_t SIZE = SIZE_;

    typedef T value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T* iterator;
    typedef const T* const_iterator;
    typedef etl::reverse_iterator<iterator> reverse_iterator;
    typedef etl::reverse_iterator<const_iterator> const_reverse_iterator;
# 117 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    [[nodiscard]]
    constexpr
    reference at(size_t i)
    {
      static_cast<void>(sizeof(i < SIZE));

      return _buffer[i];
    }





    [[nodiscard]]
    constexpr
    const_reference at(size_t i) const
    {
      static_cast<void>(sizeof(i < SIZE));

      return _buffer[i];
    }






    [[nodiscard]]
    constexpr
    reference operator[](size_t i)
    {
      ;

      return _buffer[i];
    }






    [[nodiscard]]
    constexpr const_reference operator[](size_t i) const
    {




      ;

      return _buffer[i];

    }




    [[nodiscard]]
    constexpr
    reference front()
    {
      static_assert(SIZE > 0, "Array is empty.");

      return _buffer[0];
    }




    [[nodiscard]]
    constexpr const_reference front() const
    {
      static_assert(SIZE > 0, "Array is empty.");

      return _buffer[0];
    }




    [[nodiscard]]
    constexpr
    reference back()
    {
      static_assert(SIZE > 0, "Array is empty.");

      return _buffer[SIZE - 1];
    }




    [[nodiscard]]
    constexpr const_reference back() const
    {
      static_assert(SIZE > 0, "Array is empty.");

      return _buffer[SIZE - 1];
    }




    [[nodiscard]]
    constexpr
    pointer data()
    {
      return _buffer;
    }




    [[nodiscard]]
    constexpr const_pointer data() const
    {
      return _buffer;
    }
# 243 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    [[nodiscard]]
    constexpr
    iterator begin()
    {
      return _buffer;
    }




    [[nodiscard]]
    constexpr const_iterator begin() const
    {
      return _buffer;
    }




    [[nodiscard]]
    constexpr const_iterator cbegin() const
    {
      return begin();
    }




    [[nodiscard]]
    constexpr
    iterator end()
    {
      return _buffer + SIZE;
    }




    [[nodiscard]]
    constexpr const_iterator end() const
    {
      return _buffer + SIZE;
    }




    [[nodiscard]]
    constexpr const_iterator cend() const
    {
      return _buffer + SIZE;
    }




    [[nodiscard]]
    constexpr
    reverse_iterator rbegin()
    {
      return reverse_iterator(end());
    }




    [[nodiscard]]
    constexpr const_reverse_iterator rbegin() const
    {
      return const_reverse_iterator(end());
    }




    [[nodiscard]]
    constexpr const_reverse_iterator crbegin() const
    {
      return const_reverse_iterator(end());
    }




    [[nodiscard]]
    constexpr
    reverse_iterator rend()
    {
      return reverse_iterator(begin());
    }




    [[nodiscard]]
    constexpr const_reverse_iterator rend() const
    {
      return const_reverse_iterator(begin());
    }




    [[nodiscard]]
    constexpr const_reverse_iterator crend() const
    {
      return const_reverse_iterator(begin());
    }
# 359 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    [[nodiscard]]
    constexpr bool empty() const
    {
      return (SIZE == 0);
    }




    [[nodiscard]]
    constexpr size_t size() const
    {
      return SIZE;
    }




    [[nodiscard]]
    constexpr size_t max_size() const
    {
      return SIZE;
    }
# 391 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    constexpr void fill(parameter_t value)
    {
      etl::fill(_buffer, _buffer + SIZE, value);
    }





    constexpr void swap(array& other)
    {
      using etl::swap;

      for (size_t i = 0UL; i < SIZE; ++i)
      {
        swap(_buffer[i], other._buffer[i]);
      }
    }
# 417 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    template <typename TIterator>
    iterator assign(TIterator first, const TIterator last)
    {
      return etl::copy_s(first, last, begin(), end());
    }
# 430 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    template <typename TIterator>
    iterator assign(TIterator first, const TIterator last, parameter_t value)
    {

      iterator p = etl::copy_s(first, last, begin(), end());


      etl::fill(p, end(), value);

      return p;
    }






    inline iterator insert_at(size_t position, parameter_t value)
    {
      ;

      return insert(begin() + position, value);
    }






    iterator insert(const_iterator position, parameter_t value)
    {
      ;

      iterator p = to_iterator(position);

      etl::move_backward(p, end() - 1, end());
      *p = value;

      return p;
    }







    template <typename TIterator>
    inline iterator insert_at(size_t position, TIterator first, const TIterator last)
    {
      ;

      return insert(begin() + position, first, last);
    }







    template <typename TIterator>
    iterator insert(const_iterator position, TIterator first, const TIterator last)
    {
      ;

      iterator p = to_iterator(position);
      iterator result(p);

      size_t source_size = etl::distance(first, last);
      size_t destination_space = etl::distance(position, cend());


      if (source_size < destination_space)
      {
        size_t length = SIZE - (etl::distance(begin(), p) + source_size);
        etl::move_backward(p, p + length, end());
      }


      etl::copy_s(first, last, p, end());

      return result;
    }






    inline iterator erase_at(size_t position)
    {
      ;

      return erase(begin() + position);
    }






    iterator erase(const_iterator position)
    {
      ;

      iterator p = to_iterator(position);
      etl::move(p + 1, end(), p);

      return p;
    }







    iterator erase_range(size_t first, size_t last)
    {
      ;

      return erase(begin() + first, begin() + last);
    }







    iterator erase(const_iterator first, const_iterator last)
    {
      ;

      iterator p = to_iterator(first);
      etl::move(last, cend(), p);
      return p;
    }






    inline iterator erase_at(size_t position, parameter_t value)
    {
      ;

      return erase(begin() + position, value);
    }






    iterator erase(const_iterator position, parameter_t value)
    {
      ;

      iterator p = to_iterator(position);

      etl::move(p + 1, end(), p);
      back() = value;

      return p;
    }







    iterator erase_range(size_t first, size_t last, parameter_t value)
    {
      ;

      return erase(begin() + first, begin() + last, value);
    }







    iterator erase(const_iterator first, const_iterator last, parameter_t value)
    {
      ;

      iterator p = to_iterator(first);

      p = etl::move(last, cend(), p);
      etl::fill(p, end(), value);

      return to_iterator(first);
    }


    T _buffer[SIZE];

  private:




    iterator to_iterator(const_iterator itr) const
    {
      return const_cast<iterator>(itr);
    }
  };

  template <typename T, size_t SIZE_>
  constexpr size_t array<T, SIZE_>::SIZE;






  template <typename T>
  class array<T, 0>
  {
  private:

    typedef typename etl::parameter_type<T>::type parameter_t;

  public:

    static constexpr size_t SIZE = 0;

    typedef T value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T* iterator;
    typedef const T* const_iterator;
    typedef etl::reverse_iterator<iterator> reverse_iterator;
    typedef etl::reverse_iterator<const_iterator> const_reverse_iterator;
# 683 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    [[nodiscard]]
    constexpr
    reference at(size_t)
    {
      return *data();
    }





    [[nodiscard]]
    constexpr
    const_reference at(size_t) const
    {
      return *data();
    }






    [[nodiscard]]
    constexpr
    reference operator[](size_t)
    {
      return *data();
    }






    [[nodiscard]]
    constexpr const_reference operator[](size_t) const
    {
      return *data();
    }




    [[nodiscard]]
    constexpr
    reference front()
    {
      return *data();
    }




    [[nodiscard]]
    constexpr const_reference front() const
    {
      return *data();
    }




    [[nodiscard]]
    constexpr
    reference back()
    {
      return *data();
    }




    [[nodiscard]]
    constexpr const_reference back() const
    {
      return *data();
    }




    [[nodiscard]]
    constexpr
    pointer data()
    {
      return (T*)0;
    }




    [[nodiscard]]
    constexpr const_pointer data() const
    {
      return (const T*)0;
    }
# 788 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    [[nodiscard]]
    constexpr
    iterator begin()
    {
      return iterator();
    }




    [[nodiscard]]
    constexpr const_iterator begin() const
    {
      return const_iterator();
    }




    [[nodiscard]]
    constexpr const_iterator cbegin() const
    {
      return const_iterator();
    }




    [[nodiscard]]
    constexpr
    iterator end()
    {
      return iterator();
    }




    [[nodiscard]]
    constexpr const_iterator end() const
    {
      return const_iterator();
    }




    [[nodiscard]]
    constexpr const_iterator cend() const
    {
      return const_iterator();
    }




    [[nodiscard]]
    constexpr
    reverse_iterator rbegin()
    {
      return reverse_iterator(end());
    }




    [[nodiscard]]
    constexpr const_reverse_iterator rbegin() const
    {
      return const_reverse_iterator(end());
    }




    [[nodiscard]]
    constexpr const_reverse_iterator crbegin() const
    {
      return const_reverse_iterator(end());
    }




    [[nodiscard]]
      constexpr
      reverse_iterator rend()
    {
      return reverse_iterator(begin());
    }




    [[nodiscard]]
    constexpr const_reverse_iterator rend() const
    {
      return const_reverse_iterator(begin());
    }




    [[nodiscard]]
    constexpr const_reverse_iterator crend() const
    {
      return const_reverse_iterator(begin());
    }
# 904 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    [[nodiscard]]
    constexpr bool empty() const
    {
      return true;
    }




    [[nodiscard]]
    constexpr size_t size() const
    {
      return 0;
    }




    [[nodiscard]]
    constexpr size_t max_size() const
    {
      return 0;
    }
# 936 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    constexpr void fill(parameter_t)
    {
    }





    constexpr void swap(array&)
    {
    }
# 955 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    template <typename TIterator>
    iterator assign(TIterator, const TIterator)
    {
      return iterator();
    }
# 968 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
    template <typename TIterator>
    iterator assign(TIterator, const TIterator, parameter_t)
    {
      return iterator();
    }






    inline iterator insert_at(size_t, parameter_t)
    {
      return iterator();
    }






    iterator insert(const_iterator, parameter_t)
    {
      return iterator();
    }







    template <typename TIterator>
    inline iterator insert_at(size_t, TIterator, const TIterator)
    {
      return iterator();
    }







    template <typename TIterator>
    iterator insert(const_iterator, TIterator, const TIterator)
    {
      return iterator();
    }






    inline iterator erase_at(size_t)
    {
      return iterator();
    }






    iterator erase(const_iterator)
    {
      return iterator();
    }







    iterator erase_range(size_t, size_t)
    {
      return iterator();
    }







    iterator erase(const_iterator, const_iterator)
    {
      return iterator();
    }






    inline iterator erase_at(size_t, parameter_t)
    {
      return iterator();
    }






    iterator erase(const_iterator, parameter_t)
    {
      return iterator();
    }







    iterator erase_range(size_t, size_t, parameter_t)
    {
      return iterator();
    }






    iterator erase(const_iterator, const_iterator, parameter_t)
    {
      return iterator();
    }
  };





  template <typename... T>
  array(T...) -> array<typename etl::common_type<T...>::type, sizeof...(T)>;






  template <typename T, typename... TValues>
  constexpr auto make_array(TValues&&... values) -> etl::array<T, sizeof...(TValues)>
  {
    return { etl::forward<T>(values)... };
  }







  template <typename T, const size_t SIZE>
  void swap(etl::array<T, SIZE> &lhs, etl::array<T, SIZE> &rhs)
  {
    lhs.swap(rhs);
  }







  template <typename T, size_t SIZE>
  bool operator ==(const etl::array<T, SIZE>& lhs, const etl::array<T, SIZE>& rhs)
  {
    return etl::equal(lhs.cbegin(), lhs.cend(), rhs.cbegin());
  }







  template <typename T, size_t SIZE>
  bool operator !=(const etl::array<T, SIZE>& lhs, const etl::array<T, SIZE>& rhs)
  {
    return !(lhs == rhs);
  }







  template <typename T, size_t SIZE>
  bool operator <(const etl::array<T, SIZE>& lhs, const etl::array<T, SIZE>& rhs)
  {
    return etl::lexicographical_compare(lhs.cbegin(),
                                        lhs.cend(),
                                        rhs.cbegin(),
                                        rhs.cend());
  }







  template <typename T, size_t SIZE>
  bool operator <=(const etl::array<T, SIZE>& lhs, const etl::array<T, SIZE>& rhs)
  {
    return !(lhs > rhs);
  }






  template <typename T, size_t SIZE>

  bool operator >(const etl::array<T, SIZE>& lhs, const etl::array<T, SIZE>& rhs)
  {
    return (rhs < lhs);
  }







  template <typename T, size_t SIZE>
  bool operator >=(const etl::array<T, SIZE>& lhs, const etl::array<T, SIZE>& rhs)
  {
    return !(lhs < rhs);
  }
# 1215 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
  template <size_t Index, typename T, size_t Size>
  inline T& get(array<T, Size>& a)
  {
    static_assert(Index < Size, "Index out of bounds");
    return a[Index];
  }
# 1230 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/array.h"
  template <size_t Index, typename T, size_t Size>
  inline const T& get(const array<T, Size>& a)
  {
    static_assert(Index < Size, "Index out of bounds");
    return a[Index];
  }
}
# 40 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 41 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2



# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
#define ETL_MEMORY_INCLUDED 



# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h" 2




# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/placement_new.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/placement_new.h"
#define ETL_PLACEMENT_NEW_INCLUDED 
# 44 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/placement_new.h"
#define ETL_USING_STD_NEW 0
# 59 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/placement_new.h"
  inline void* operator new(size_t, void* p) { return p; }
  inline void* operator new[](size_t, void* p) { return p; }

  inline void operator delete(void*, void*) {}
  inline void operator delete[](void*, void*) {}
# 42 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h" 2



# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/assert.h" 1 3






# 6 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/assert.h" 3
extern "C" {




#undef assert




#define assert(__e) ((__e) ? (void)0 : __assert_func (__FILE__, __LINE__, __ASSERT_FUNC, #__e))
# 39 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/assert.h" 3
void __assert (const char *, int, const char *)
     __attribute__ ((__noreturn__));
void __assert_func (const char *, int, const char *, const char *)
     __attribute__ ((__noreturn__));






}
# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h" 2
# 55 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"

# 55 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
namespace etl
{




  template <typename T>
  constexpr T* to_address(T* p)
  {
    return p;
  }






  template <typename Iterator>
  constexpr typename Iterator::pointer to_address(const Iterator& itr)
  {
    return etl::to_address(itr.operator->());
  }
# 114 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TOutputIterator, typename T>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_fill(TOutputIterator o_begin, TOutputIterator o_end, const T& value)
  {
    etl::fill(o_begin, o_end, value);

    return o_end;
  }






  template <typename TOutputIterator, typename T>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_fill(TOutputIterator o_begin, TOutputIterator o_end, const T& value)
  {
    typedef typename etl::iterator_traits<TOutputIterator>::value_type value_type;

    while (o_begin != o_end)
    {
      ::new (static_cast<void*>(etl::to_address(o_begin))) value_type(value);
      ++o_begin;
    }

    return o_end;
  }







  template <typename TOutputIterator, typename T, typename TCounter>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_fill(TOutputIterator o_begin, TOutputIterator o_end, const T& value, TCounter& count)
  {
    count += int32_t(etl::distance(o_begin, o_end));

    etl::fill(o_begin, o_end, value);

    return o_end;
  }







  template <typename TOutputIterator, typename T, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_fill(TOutputIterator o_begin, TOutputIterator o_end, const T& value, TCounter& count)
  {
    count += int32_t(etl::distance(o_begin, o_end));

    etl::uninitialized_fill(o_begin, o_end, value);

    return o_end;
  }
# 209 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TOutputIterator, typename TSize, typename T>
  TOutputIterator uninitialized_fill_n(TOutputIterator o_begin, TSize n, const T& value)
  {
    return etl::uninitialized_fill(o_begin, o_begin + n, value);
  }







  template <typename TOutputIterator, typename TSize, typename T, typename TCounter>
  TOutputIterator uninitialized_fill_n(TOutputIterator o_begin, TSize n, const T& value, TCounter& count)
  {
    count += n;

    return etl::uninitialized_fill(o_begin, o_begin + n, value);
  }
# 261 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TInputIterator, typename TOutputIterator>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_copy(TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin)
  {
    return etl::copy(i_begin, i_end, o_begin);
  }






  template <typename TInputIterator, typename TOutputIterator>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_copy(TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin)
  {
    typedef typename etl::iterator_traits<TOutputIterator>::value_type value_type;

    TOutputIterator o_end = o_begin;

    while (i_begin != i_end)
    {
      ::new (static_cast<void*>(etl::to_address(o_end))) value_type(*i_begin);
      ++i_begin;
      ++o_end;
    }

    return o_end;
  }







  template <typename TInputIterator, typename TOutputIterator, typename TCounter>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_copy(TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TCounter& count)
  {
    TOutputIterator o_end = etl::copy(i_begin, i_end, o_begin);
    count += int32_t(etl::distance(i_begin, i_end));

    return o_end;
  }







  template <typename TInputIterator, typename TOutputIterator, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_copy(TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TCounter& count)
  {
    TOutputIterator o_end = etl::uninitialized_copy(i_begin, i_end, o_begin);

    count += int32_t(etl::distance(i_begin, i_end));

    return o_end;
  }
# 356 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TInputIterator, typename TSize, typename TOutputIterator>
  TOutputIterator uninitialized_copy_n(TInputIterator i_begin, TSize n, TOutputIterator o_begin)
  {
    return etl::uninitialized_copy(i_begin, i_begin + n, o_begin);
  }







  template <typename TInputIterator, typename TSize, typename TOutputIterator, typename TCounter>
  TOutputIterator uninitialized_copy_n(TInputIterator i_begin, TSize n, TOutputIterator o_begin, TCounter& count)
  {
    count += n;

    return etl::uninitialized_copy(i_begin, i_begin + n, o_begin);
  }
# 409 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TInputIterator, typename TOutputIterator>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_move(TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin)
  {
    return etl::move(i_begin, i_end, o_begin);
  }






  template <typename TInputIterator, typename TOutputIterator>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_move(TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin)
  {
    typedef typename etl::iterator_traits<TOutputIterator>::value_type value_type;

    TOutputIterator o_end = o_begin;

    while (i_begin != i_end)
    {
      ::new (static_cast<void*>(etl::to_address(o_end))) value_type(etl::move(*i_begin));
      ++i_begin;
      ++o_end;
    }

    return o_end;
  }







  template <typename TInputIterator, typename TOutputIterator, typename TCounter>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_move(TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TCounter& count)
  {
    TOutputIterator o_end = etl::move(i_begin, i_end, o_begin);
    count += int32_t(etl::distance(i_begin, i_end));

    return o_end;
  }







  template <typename TInputIterator, typename TOutputIterator, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_move(TInputIterator i_begin, TInputIterator i_end, TOutputIterator o_begin, TCounter& count)
  {
    TOutputIterator o_end = etl::uninitialized_move(i_begin, i_end, o_begin);

    count += int32_t(etl::distance(i_begin, i_end));

    return o_end;
  }
# 534 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TInputIterator, typename TSize, typename TOutputIterator>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_move_n(TInputIterator i_begin, TSize n, TOutputIterator o_begin)
  {
    return etl::move(i_begin, i_begin + n, o_begin);
  }






  template <typename TInputIterator, typename TSize, typename TOutputIterator>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_move_n(TInputIterator i_begin, TSize n, TOutputIterator o_begin)
  {
    typedef typename etl::iterator_traits<TOutputIterator>::value_type value_type;

    TOutputIterator o_end = o_begin;

    while (n-- != 0)
    {
      ::new (static_cast<void*>(etl::to_address(o_end))) value_type(etl::move(*i_begin));
      ++i_begin;
      ++o_end;
    }

    return o_end;
  }







  template <typename TInputIterator, typename TSize, typename TOutputIterator, typename TCounter>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_move_n(TInputIterator i_begin, TSize n, TOutputIterator o_begin, TCounter& count)
  {
    TOutputIterator o_end = etl::move(i_begin, i_begin + n, o_begin);
    count += TCounter(n);

    return o_end;
  }







  template <typename TInputIterator, typename TSize, typename TOutputIterator, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_move_n(TInputIterator i_begin, TSize n, TOutputIterator o_begin, TCounter& count)
  {
    TOutputIterator o_end = etl::uninitialized_move(i_begin, i_begin + n, o_begin);

    count += TCounter(n);

    return o_end;
  }
# 668 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TOutputIterator>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, void>::type
    uninitialized_default_construct(TOutputIterator , TOutputIterator )
  {

  }






  template <typename TOutputIterator>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, void>::type
    uninitialized_default_construct(TOutputIterator o_begin, TOutputIterator o_end)
  {

    typedef typename etl::iterator_traits<TOutputIterator>::value_type value_type;

    while (o_begin != o_end)
    {
      ::new (static_cast<void*>(etl::to_address(o_begin))) value_type;
      ++o_begin;
    }
  }







  template <typename TOutputIterator, typename TCounter>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, void>::type
    uninitialized_default_construct(TOutputIterator o_begin, TOutputIterator o_end, TCounter& count)
  {
    count = int32_t(etl::distance(o_begin, o_end));
  }







  template <typename TOutputIterator, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, void>::type
    uninitialized_default_construct(TOutputIterator o_begin, TOutputIterator o_end, TCounter& count)
  {
    count += int32_t(etl::distance(o_begin, o_end));

    etl::uninitialized_default_construct(o_begin, o_end);
  }
# 754 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TOutputIterator, typename TSize>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_default_construct_n(TOutputIterator o_begin, TSize n)
  {
    TOutputIterator o_end = o_begin + n;
    return o_end;
  }






  template <typename TOutputIterator, typename TSize>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_default_construct_n(TOutputIterator o_begin, TSize n)
  {
    TOutputIterator o_end = o_begin + n;

    etl::uninitialized_default_construct(o_begin, o_end);

    return o_end;
  }







  template <typename TOutputIterator, typename TSize, typename TCounter>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_default_construct_n(TOutputIterator o_begin, TSize n, TCounter& count)
  {
    TOutputIterator o_end = o_begin + n;

    count += n;

    return o_end;
  }







  template <typename TOutputIterator, typename TSize, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, TOutputIterator>::type
    uninitialized_default_construct_n(TOutputIterator o_begin, TSize n, TCounter& count)
  {
    TOutputIterator o_end = o_begin + n;

    etl::uninitialized_default_construct(o_begin, o_end);

    count += n;

    return o_end;
  }
# 846 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TOutputIterator>
  typename etl::enable_if<etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, void>::type
    uninitialized_value_construct(TOutputIterator o_begin, TOutputIterator o_end)
  {
    typedef typename etl::iterator_traits<TOutputIterator>::value_type value_type;

    etl::fill(o_begin, o_end, value_type());
  }






  template <typename TOutputIterator>
  typename etl::enable_if<!etl::is_trivially_constructible<typename etl::iterator_traits<TOutputIterator>::value_type>::value, void>::type
    uninitialized_value_construct(TOutputIterator o_begin, TOutputIterator o_end)
  {
    typedef typename etl::iterator_traits<TOutputIterator>::value_type value_type;

    while (o_begin != o_end)
    {
      ::new (static_cast<void*>(etl::to_address(o_begin))) value_type();
      ++o_begin;
    }
  }







  template <typename TOutputIterator, typename TCounter>
  void uninitialized_value_construct(TOutputIterator o_begin, TOutputIterator o_end, TCounter& count)
  {
    count += int32_t(etl::distance(o_begin, o_end));

    etl::uninitialized_value_construct(o_begin, o_end);
  }
# 919 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TOutputIterator, typename TSize>
  TOutputIterator uninitialized_value_construct_n(TOutputIterator o_begin, TSize n)
  {
    TOutputIterator o_end = o_begin + n;

    etl::uninitialized_value_construct(o_begin, o_end);

    return o_end;
  }







  template <typename TOutputIterator, typename TSize, typename TCounter>
  TOutputIterator uninitialized_value_construct_n(TOutputIterator o_begin, TSize n, TCounter& count)
  {
    TOutputIterator o_end = o_begin + n;

    etl::uninitialized_value_construct(o_begin, o_end);

    count += n;

    return o_end;
  }
# 965 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T, typename... TArgs>
  T* construct_at(T* p, TArgs&&... args)
  {
    return ::new (const_cast<void*>(static_cast<const volatile void*>(p))) T(etl::forward<TArgs>(args)...);
  }
# 1025 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  typename etl::enable_if<etl::is_trivially_destructible<T>::value, void>::type
    destroy_at(T* )
  {
  }






  template <typename T>
  typename etl::enable_if<!etl::is_trivially_destructible<T>::value, void>::type
    destroy_at(T* p)
  {
    p->~T();
  }







  template <typename T, typename TCounter>
  typename etl::enable_if<etl::is_trivially_destructible<T>::value, void>::type
    destroy_at(T* , TCounter& count)
  {
    --count;
  }







  template <typename T, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_destructible<T>::value, void>::type
    destroy_at(T* p, TCounter& count)
  {
    p->~T();
    --count;
  }
# 1102 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TIterator>
  typename etl::enable_if<etl::is_trivially_destructible<typename etl::iterator_traits<TIterator>::value_type>::value, void>::type
    destroy(TIterator , TIterator )
  {
  }






  template <typename TIterator>
  typename etl::enable_if<!etl::is_trivially_destructible<typename etl::iterator_traits<TIterator>::value_type>::value, void>::type
    destroy(TIterator i_begin, TIterator i_end)
  {
    while (i_begin != i_end)
    {
      etl::destroy_at(etl::to_address(i_begin));
      ++i_begin;
    }
  }







  template <typename TIterator, typename TCounter>
  typename etl::enable_if<etl::is_trivially_destructible<typename etl::iterator_traits<TIterator>::value_type>::value, void>::type
    destroy(TIterator i_begin, TIterator i_end, TCounter& count)
  {
    count -= int32_t(etl::distance(i_begin, i_end));
  }







  template <typename TIterator, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_destructible<typename etl::iterator_traits<TIterator>::value_type>::value, void>::type
    destroy(TIterator i_begin, TIterator i_end, TCounter& count)
  {
    count -= int32_t(etl::distance(i_begin, i_end));

    while (i_begin != i_end)
    {
      etl::destroy_at(etl::to_address(i_begin));
      ++i_begin;
    }
  }
# 1188 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TIterator, typename TSize>
  typename etl::enable_if<etl::is_trivially_destructible<typename etl::iterator_traits<TIterator>::value_type>::value, TIterator>::type
    destroy_n(TIterator i_begin, TSize n)
  {
    return i_begin + n;
  }






  template <typename TIterator, typename TSize>
  typename etl::enable_if<!etl::is_trivially_destructible<typename etl::iterator_traits<TIterator>::value_type>::value, TIterator>::type
    destroy_n(TIterator i_begin, TSize n)
  {
    while (n > 0)
    {
      etl::destroy_at(etl::to_address(i_begin));
      ++i_begin;
      --n;
    }

    return i_begin;
  }







  template <typename TIterator, typename TSize, typename TCounter>
  typename etl::enable_if<etl::is_trivially_destructible<typename etl::iterator_traits<TIterator>::value_type>::value, TIterator>::type
    destroy_n(TIterator i_begin, TSize n, TCounter& count)
  {
    count -= n;
    return i_begin + n;
  }







  template <typename TIterator, typename TSize, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_destructible<typename etl::iterator_traits<TIterator>::value_type>::value, TIterator>::type
    destroy_n(TIterator i_begin, TSize n, TCounter& count)
  {
    count -= n;

    while (n > 0)
    {
      etl::destroy_at(etl::to_address(i_begin));
      ++i_begin;
      --n;
    }

    return i_begin;
  }
# 1257 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  struct default_delete
  {

    constexpr default_delete()
    {
    }


    template <typename U>
    default_delete(const default_delete<U>&)
    {
    }


    void operator()(T * p) const
    {
      delete p;
    }
  };







  template <typename T>
  struct default_delete<T[]>
  {

    constexpr default_delete()
    {
    }


    template <typename U>
    default_delete(const default_delete<U>&)
    {
    }


    template <class U>
    void operator()(U* p) const
    {
      delete[] p;
    }
  };







  template <typename T, typename TDeleter = etl::default_delete<T> >
  class unique_ptr
  {
  public:

    typedef T element_type;
    typedef T* pointer;
    typedef T& reference;


    constexpr unique_ptr()
      : p(nullptr)
    {
    }


    constexpr explicit unique_ptr(pointer p_)
      : p(p_)
    {
    }



    unique_ptr(unique_ptr&& other)
    {
      if (&other != this)
      {
        p = other.release();
        deleter = etl::move(other.deleter);
      }
    }
# 1356 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
    unique_ptr(pointer p_, typename etl::conditional<etl::is_reference<TDeleter>::value,
                                                     TDeleter,
                                                     typename etl::add_lvalue_reference<const TDeleter>::type>::type deleter_)
      : p(p_)
      , deleter(deleter_)
    {
    }



    unique_ptr(pointer p_, typename etl::remove_reference<TDeleter>::type&& deleter_)
      : p(p_)
      , deleter(etl::move(deleter_))
    {
    }

    template <typename U, typename E>
    unique_ptr(unique_ptr<U, E>&& u)
      : p(u.release())
      , deleter(etl::forward<E>(u.get_deleter()))
    {
    }



    ~unique_ptr()
    {
      if (p != nullptr)
      {
        deleter(p);
      }
    }


    constexpr pointer get() const
    {
      return p;
    }


    TDeleter& get_deleter()
    {
      return deleter;
    }


    const TDeleter& get_deleter() const
    {
      return deleter;
    }


    pointer release()
    {
      pointer value = p;
      p = nullptr;

      return value;
    }


    void reset(pointer p_ = pointer())
    {
      if (p_ == nullptr || p_ != p)
      {
        pointer value = p;
        p = p_;

        if (value != nullptr)
        {
          deleter(value);
        }
      }
    }


    void swap(unique_ptr& value)
    {
      using etl::swap;

      swap(p, value.p);
    }


    constexpr operator bool() const
    {
      return (p != nullptr);
    }


    unique_ptr& operator =(etl::nullptr_t)
    {
      if (p)
      {
        reset(nullptr);
      }

      return *this;
    }



    unique_ptr& operator =(unique_ptr&& other)
    {
      if (&other != this)
      {
        reset(other.release());
        deleter = etl::move(other.deleter);
      }

      return *this;
    }
# 1483 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
    constexpr reference operator *() const
    {
      return *get();
    }


    constexpr pointer operator ->() const
    {
      return get();
    }


    constexpr reference operator [](size_t i) const
    {
      return p[i];
    }

  private:


    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator =(const unique_ptr&) = delete;

    pointer p;
    TDeleter deleter;
  };







  template<typename T, typename TDeleter>
  class unique_ptr<T[], TDeleter>
  {
  public:

    typedef T element_type;
    typedef T* pointer;
    typedef T& reference;


    constexpr unique_ptr()
      : p(nullptr)
    {
    }


    constexpr explicit unique_ptr(pointer p_)
      : p(p_)
    {
    }



    unique_ptr(unique_ptr&& other)
    {
      if (&other != this)
      {
        p = other.release();
        deleter = etl::move(other.deleter);
      }
    }
# 1560 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
    unique_ptr(pointer p_,
               typename etl::conditional<etl::is_reference<TDeleter>::value,
                                         TDeleter,
                                         typename etl::add_lvalue_reference<const TDeleter>::type>::type deleter_)
      : p(p_)
      , deleter(deleter_)
    {
    }



    unique_ptr(pointer p_, typename etl::remove_reference<TDeleter>::type&& deleter_)
      : p(p_)
      , deleter(etl::move(deleter_))
    {
    }

    template <typename U, typename E>
    unique_ptr(unique_ptr<U, E>&& u)
      : p(u.release())
      , deleter(etl::forward<E>(u.get_deleter()))
    {
    }



    ~unique_ptr()
    {
      if (p != nullptr)
      {
        deleter(p);
      }
    }


    constexpr pointer get() const
    {
      return p;
    }


    TDeleter& get_deleter()
    {
      return deleter;
    }


    const TDeleter& get_deleter() const
    {
      return deleter;
    }


    pointer release()
    {
      pointer value = p;
      p = nullptr;
      return value;
    }


    void reset(pointer p_)
    {
      if (p_ != p)
      {
        pointer value = p;
        p = p_;

        if (value != nullptr)
        {
          deleter(value);
        }
      }
    }

    void reset(etl::nullptr_t = nullptr)
    {
      reset(pointer());
    }


    void swap(unique_ptr& v)
    {
      using etl::swap;

      swap(p, v.p);
    }


    constexpr operator bool() const
    {
      return (p != nullptr);
    }


    unique_ptr& operator =(etl::nullptr_t)
    {
      reset(nullptr);

      return *this;
    }



    unique_ptr& operator =(unique_ptr&& other)
    {
      if (&other != this)
      {
        reset(other.release());
        deleter = etl::move(other.deleter);
      }

      return *this;
    }
# 1689 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
    constexpr reference operator *() const
    {
      return *p;
    }


    constexpr pointer operator ->() const
    {
      return p;
    }


    constexpr reference operator [](size_t i) const
    {
      return p[i];
    }

  private:


    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator =(const unique_ptr&) = delete;

    pointer p;
    TDeleter deleter;
  };
}




template<typename T1, typename TD1, typename T2, typename TD2>
bool operator ==(const etl::unique_ptr<T1, TD1>&lhs, const etl::unique_ptr<T2, TD2>& rhs)
{
  return lhs.get() == rhs.get();
}


template<typename T1, typename TD1, typename T2, typename TD2>
bool operator <(const etl::unique_ptr<T1, TD1>&lhs, const etl::unique_ptr<T2, TD2>& rhs)
{
  return reinterpret_cast<char*>(lhs.get()) < reinterpret_cast<char*>(rhs.get());
}


template<typename T1, typename TD1, typename T2, typename TD2>
bool operator <=(const etl::unique_ptr<T1, TD1>&lhs, const etl::unique_ptr<T2, TD2>& rhs)
{
  return !(rhs < lhs);
}


template<typename T1, typename TD1, typename T2, typename TD2>
bool operator >(const etl::unique_ptr<T1, TD1>&lhs, const etl::unique_ptr<T2, TD2>& rhs)
{
  return (rhs < lhs);
}


template<typename T1, typename TD1, typename T2, typename TD2>
bool operator >=(const etl::unique_ptr<T1, TD1>&lhs, const etl::unique_ptr<T2, TD2>& rhs)
{
  return !(lhs < rhs);
}

namespace etl
{




  template <typename T>
  typename etl::enable_if<etl::is_trivially_constructible<T>::value, void>::type
   create_default_at(T* )
  {
  }





  template <typename T, typename TCounter>
  typename etl::enable_if<etl::is_trivially_constructible<T>::value, void>::type
   create_default_at(T* , TCounter& count)
  {
    ++count;
  }





  template <typename T>
  typename etl::enable_if<!etl::is_trivially_constructible<T>::value, void>::type
   create_default_at(T* p)
  {
    ::new (p) T;
  }





  template <typename T, typename TCounter>
  typename etl::enable_if<!etl::is_trivially_constructible<T>::value, void>::type
   create_default_at(T* p, TCounter& count)
  {
    ::new (p) T;
    ++count;
  }





  template <typename T>
  void create_value_at(T* p)
  {
    ::new (p) T();
  }





  template <typename T, typename TCounter>
  void create_value_at(T* p, TCounter& count)
  {
    ::new (p) T();
    ++count;
  }





  template <typename T>
  void create_copy_at(T* p, const T& value)
  {
    ::new (p) T(value);
  }






  template <typename T>
  void create_copy_at(T* p, T&& value)
  {
    ::new (p) T(etl::move(value));
  }






  template <typename T, typename TCounter>
   void create_copy_at(T* p, const T& value, TCounter& count)
  {
    ::new (p) T(value);
    ++count;
  }





  template <typename T>
   T& make_default_at(T* p)
  {
    ::new (p) T();
    return *reinterpret_cast<T*>(p);
  }





  template <typename T, typename TCounter>
   T& make_default_at(T* p, TCounter& count)
  {
    ::new (p) T();
    ++count;
    return *reinterpret_cast<T*>(p);
  }





  template <typename T>
   T& make_copy_at(T* p, const T& other)
  {
    ::new (p) T(other);
    return *reinterpret_cast<T*>(p);
  }






  template <typename T>
  T& make_copy_at(T* p, T&& other)
  {
    ::new (p) T(etl::move(other));
    return *reinterpret_cast<T*>(p);
  }






  template <typename T, typename TCounter>
   T& make_copy_at(T* p, const T& other, TCounter& count)
  {
    ::new (p) T(other);
    ++count;
    return *reinterpret_cast<T*>(p);
  }





  template <typename T, typename TParameter>
   T& make_value_at(T* p, const TParameter& value)
  {
    ::new (p) T(value);
    return *reinterpret_cast<T*>(p);
  }






  template <typename T, typename TParameter>
  T& make_value_at(T* p, TParameter&& value)
  {
    ::new (p) T(etl::move(value));
    return *reinterpret_cast<T*>(p);
  }






  template <typename T, typename TParameter, typename TCounter>
   T& make_value_at(T* p, const TParameter& value, TCounter& count)
  {
    ::new (p) T(value);
    ++count;
    return *reinterpret_cast<T*>(p);
  }






  template <typename T>
  struct create_copy
  {
    void create_copy_at(void* p)
    {
      new (p) T(static_cast<const T&>(*this));
    }

    template <typename TCounter>
    void create_copy_at(void* p, TCounter& count)
    {
      new (p) T(static_cast<const T&>(*this));
      ++count;
    }

    T& make_copy_at(void* p)
    {
      new (p) T(static_cast<const T&>(*this));
      return *reinterpret_cast<T*>(p);
    }

    template <typename TCounter>
    T& make_copy_at(void* p, TCounter& count)
    {
      new (p) T(static_cast<const T&>(*this));
      ++count;
      return *reinterpret_cast<T*>(p);
    }
  };







  inline void memory_clear(volatile char* p, size_t n)
  {
    while (n--)
    {
      *p++ = 0;
    }
  }







  template <typename T>
  void memory_clear(volatile T &object)
  {
    memory_clear(reinterpret_cast<volatile char*>(&object), sizeof(T));
  }
# 2017 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  void memory_clear_range(volatile T* begin, size_t n)
  {
    memory_clear(reinterpret_cast<volatile char*>(begin), n * sizeof(T));
  }
# 2030 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  void memory_clear_range(volatile T* begin, volatile T* end)
  {
    const size_t n = static_cast<size_t>(etl::distance(begin, end));

    memory_clear_range(begin, n);
  }
# 2045 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  inline void memory_set(volatile char* p, size_t n, char value)
  {
    while (n--)
    {
      *p++ = value;
    }
  }
# 2060 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  void memory_set(volatile T &object, const char value)
  {
    memory_set(reinterpret_cast<volatile char*>(&object), sizeof(T), value);
  }
# 2074 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  void memory_set_range(volatile T* begin, size_t n, const char value)
  {
    memory_set(reinterpret_cast<volatile char*>(begin), n * sizeof(T), value);
  }
# 2088 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  void memory_set_range(volatile T* begin, volatile T* end, const char value)
  {
    const size_t n = static_cast<size_t>(etl::distance(begin, end));

    memory_set_range(begin, n, value);
  }
# 2103 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  struct wipe_on_destruct
  {
    ~wipe_on_destruct()
    {
      memory_clear(static_cast<volatile T&>(*this));
    }
  };





  template <size_t VObject_Size, size_t VN_Objects, size_t VAlignment>
  class uninitialized_buffer
  {
  public:

    static constexpr size_t Object_Size = VObject_Size;
    static constexpr size_t N_Objects = VN_Objects;
    static constexpr size_t Alignment = VAlignment;


    template <typename T>
    operator T& ()
    {
      static_assert((etl::is_same<T*, void*>::value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
      return *reinterpret_cast<T*>(raw);
    }


    template <typename T>
    operator const T& () const
    {
      static_assert((etl::is_same<T*, void*>::value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
      return *reinterpret_cast<const T*>(raw);
    }


    template <typename T>
    operator T* ()
    {
      static_assert((etl::is_same<T*, void*>::value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
      return reinterpret_cast<T*>(raw);
    }


    template <typename T>
    operator const T* () const
    {
      static_assert((etl::is_same<T*, void*>::value || ((Alignment % etl::alignment_of<T>::value) == 0)), "Incompatible alignment");
      return reinterpret_cast<const T*>(raw);
    }


    alignas(VAlignment) char raw[Object_Size * N_Objects];







  };

  template <size_t VObject_Size, size_t VN_Objects, size_t VAlignment>
  constexpr size_t uninitialized_buffer<VObject_Size, VN_Objects, VAlignment>::Object_Size;

  template <size_t VObject_Size, size_t VN_Objects, size_t VAlignment>
  constexpr size_t uninitialized_buffer<VObject_Size, VN_Objects, VAlignment>::N_Objects;

  template <size_t VObject_Size, size_t VN_Objects, size_t VAlignment>
  constexpr size_t uninitialized_buffer<VObject_Size, VN_Objects, VAlignment>::Alignment;





  template <typename T, size_t VN_Objects>
  class uninitialized_buffer_of
  {
  public:

    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T* iterator;
    typedef const T* const_iterator;

    static constexpr size_t Object_Size = sizeof(T);
    static constexpr size_t N_Objects = VN_Objects;
    static constexpr size_t Alignment = etl::alignment_of<T>::value;


    T& operator [](int i)
    {
      return reinterpret_cast<T*>(this->raw)[i];
    }


    const T& operator [](int i) const
    {
      return reinterpret_cast<const T*>(this->raw)[i];
    }


    operator T& ()
    {
      return *reinterpret_cast<T*>(raw);
    }


    operator const T& () const
    {
      return *reinterpret_cast<const T*>(raw);
    }


    operator T* ()

    {
      return reinterpret_cast<T*>(raw);
    }


    operator const T* () const
    {
      return reinterpret_cast<const T*>(raw);
    }

    T* begin()
    {
      return reinterpret_cast<T*>(raw);
    }

    const T* begin() const
    {
      return reinterpret_cast<const T*>(raw);
    }

    T* end()
    {
      return reinterpret_cast<T*>(raw + (sizeof(T) * N_Objects));
    }

    const T* end() const
    {
      return reinterpret_cast<const T*>(raw + (sizeof(T) * N_Objects));
    }


    alignas(Alignment) char raw[sizeof(T) * N_Objects];







  };

  template <typename T, size_t VN_Objects>
  constexpr size_t uninitialized_buffer_of<T, VN_Objects>::Object_Size;

  template <typename T, size_t VN_Objects>
  constexpr size_t uninitialized_buffer_of<T, VN_Objects>::N_Objects;

  template <typename T, size_t VN_Objects>
  constexpr size_t uninitialized_buffer_of<T, VN_Objects>::Alignment;


  template <typename T, size_t N_Objects>
  using uninitialized_buffer_of_t = typename uninitialized_buffer_of<T, N_Objects>::buffer;
# 2288 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  T* mem_copy(const T* sb, const T* se, T* db)
  {
    static_assert(etl::is_trivially_copyable<T>::value, "Cannot mem_copy a non trivially copyable type");


    __builtin_memcpy(reinterpret_cast<void*>(db),
                     reinterpret_cast<const void*>(sb),
                     sizeof(T) * static_cast<size_t>(se - sb));






    return db;
  }
# 2313 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  T* mem_copy(const T* sb, size_t n, T* db)
  {
    static_assert(etl::is_trivially_copyable<T>::value, "Cannot mem_copy a non trivially copyable type");


    __builtin_memcpy(reinterpret_cast<void*>(db),
                     reinterpret_cast<const void*>(sb),
                     sizeof(T) * n);






    return db;
  }
# 2338 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  T* mem_move(const T* sb, const T* se, T* db)
  {
    static_assert(etl::is_trivially_copyable<T>::value, "Cannot mem_move a non trivially copyable type");


    __builtin_memmove(reinterpret_cast<void*>(db),
                      reinterpret_cast<const void*>(sb),
                      sizeof(T) * static_cast<size_t>(se - sb));






    return db;
  }
# 2363 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  T* mem_move(const T* sb, size_t n, T* db)
  {
    static_assert(etl::is_trivially_copyable<T>::value, "Cannot mem_move a non trivially copyable type");


    __builtin_memmove(reinterpret_cast<void*>(db),
                      reinterpret_cast<const void*>(sb),
                      sizeof(T) * n);






    return db;
  }
# 2390 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  [[nodiscard]]
  int mem_compare(const T* sb, const T* se, const T* db)
  {
    static_assert(etl::is_trivially_copyable<T>::value, "Cannot mem_compare a non trivially copyable type");


    return __builtin_memcmp(reinterpret_cast<const void*>(db),
                            reinterpret_cast<const void*>(sb),
                            sizeof(T) * static_cast<size_t>(se - sb));





  }
# 2416 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename T>
  [[nodiscard]]
  int mem_compare(const T* sb, size_t n, const T* db)
  {
    static_assert(etl::is_trivially_copyable<T>::value, "Cannot mem_compare a non trivially copyable type");


    return __builtin_memcmp(reinterpret_cast<const void*>(db),
                            reinterpret_cast<const void*>(sb),
                            sizeof(T) * n);





  }
# 2440 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TPointer, typename T>
  typename etl::enable_if<etl::is_pointer<TPointer>::value &&
                          !etl::is_const<TPointer>::value &&
                          etl::is_integral<T>::value &&
                          sizeof(T) == 1, TPointer>::type
    mem_set(TPointer db, const TPointer de, T value)
  {
    static_assert(etl::is_trivially_copyable<typename etl::iterator_traits<TPointer>::value_type>::value, "Cannot mem_set a non trivially copyable type");


    __builtin_memset(reinterpret_cast<void*>(db),
                     static_cast<char>(value),
                     sizeof(typename etl::iterator_traits<TPointer>::value_type) * static_cast<size_t>(de - db));






    return db;
  }
# 2469 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TPointer, typename T>
  typename etl::enable_if<etl::is_pointer<TPointer>::value &&
                          !etl::is_const<TPointer>::value &&
                          etl::is_integral<T>::value &&
                          sizeof(T) == 1, TPointer>::type
    mem_set(TPointer db, size_t n, T value)
  {
    static_assert(etl::is_trivially_copyable<typename etl::iterator_traits<TPointer>::value_type>::value, "Cannot mem_set a non trivially copyable type");


    __builtin_memset(reinterpret_cast<void*>(db),
                     static_cast<char>(value),
                     sizeof(typename etl::iterator_traits<TPointer>::value_type) * n);






    return db;
  }
# 2498 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TPointer, typename T>
  [[nodiscard]]
    typename etl::enable_if<etl::is_pointer<TPointer>::value &&
                            !etl::is_const<typename etl::remove_pointer<TPointer>::type>::value &&
                            etl::is_integral<T>::value &&
                            sizeof(T) == 1, char*>::type
    mem_char(TPointer sb, TPointer se, T value)
  {

    void* result = __builtin_memchr(reinterpret_cast<void*>(sb),
                                    static_cast<char>(value),
                                    sizeof(typename etl::iterator_traits<TPointer>::value_type) * static_cast<size_t>(se - sb));

    return (result == 0U) ? reinterpret_cast<char*>(se) : reinterpret_cast<char*>(result);







  }
# 2528 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TPointer, typename T>
  [[nodiscard]]
    typename etl::enable_if<etl::is_pointer<TPointer>::value &&
                            etl::is_const<typename etl::remove_pointer<TPointer>::type>::value &&
                            etl::is_integral<T>::value &&
                            sizeof(T) == 1, const char*>::type
    mem_char(TPointer sb, TPointer se, T value)
  {

    const void* result = __builtin_memchr(reinterpret_cast<const void*>(sb),
                                          static_cast<char>(value),
                                          sizeof(typename etl::iterator_traits<TPointer>::value_type) * static_cast<size_t>(se - sb));

    return (result == 0U) ? reinterpret_cast<const char*>(se) : reinterpret_cast<const char*>(result);







  }
# 2558 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TPointer, typename T>
  [[nodiscard]]
    typename etl::enable_if<etl::is_pointer<TPointer>::value &&
                            !etl::is_const<typename etl::remove_pointer<TPointer>::type>::value &&
                            etl::is_integral<T>::value &&
                            sizeof(T) == 1, char*>::type
    mem_char(TPointer sb, size_t n, T value)
  {

    void* result = __builtin_memchr(reinterpret_cast<void*>(sb),
                                    static_cast<char>(value),
                                    sizeof(typename etl::iterator_traits<TPointer>::value_type) * n);

    return (result == 0U) ? reinterpret_cast<char*>(sb + n) : reinterpret_cast<char*>(result);







  }
# 2588 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TPointer, typename T>
  [[nodiscard]]
    typename etl::enable_if<etl::is_pointer<TPointer>::value &&
                            etl::is_const<typename etl::remove_pointer<TPointer>::type>::value &&
                            etl::is_integral<T>::value &&
                            sizeof(T) == 1, const char*>::type
    mem_char(TPointer sb, size_t n, T value)
  {

    const void* result = __builtin_memchr(reinterpret_cast<const void*>(sb),
                                          static_cast<char>(value),
                                          sizeof(typename etl::iterator_traits<TPointer>::value_type) * n);

    return (result == 0U) ? reinterpret_cast<const char*>(sb + n) : reinterpret_cast<const char*>(result);
# 2611 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  }





  template <typename TObject>
  TObject& construct_object_at(void* p, TObject&& other)
  {




    return *etl::construct_at(reinterpret_cast<typename etl::remove_reference<TObject>::type*>(p), etl::forward<TObject>(other));
  }




  template <typename TObject, typename... TArgs>
  TObject& construct_object_at(void* p, TArgs&&... args)
  {




    return *etl::construct_at(reinterpret_cast<TObject*>(p), etl::forward<TArgs>(args)...);
  }
# 2683 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/memory.h"
  template <typename TObject>
  TObject& get_object_at(void* p)
  {




    TObject& v = *reinterpret_cast<TObject*>(p);

    return v;
  }





  template <typename TObject>
  void destroy_object_at(void* p)
  {




    TObject& v = get_object_at<TObject>(p);
    v.~TObject();
  }
}
# 45 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/binary.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/binary.h"
#define ETL_BINARY_INCLUDED 






# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 40 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/binary.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
#define ETL_LIMITS_INCLUDED 


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 2







# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/limits.h" 1 3 4
# 44 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 2

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/float.h" 1 3 4
# 29 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/float.h" 3 4
#define _FLOAT_H___ 


#undef FLT_RADIX
#define FLT_RADIX __FLT_RADIX__


#undef FLT_MANT_DIG
#undef DBL_MANT_DIG
#undef LDBL_MANT_DIG
#define FLT_MANT_DIG __FLT_MANT_DIG__
#define DBL_MANT_DIG __DBL_MANT_DIG__
#define LDBL_MANT_DIG __LDBL_MANT_DIG__
# 50 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/float.h" 3 4
#undef FLT_DIG
#undef DBL_DIG
#undef LDBL_DIG
#define FLT_DIG __FLT_DIG__
#define DBL_DIG __DBL_DIG__
#define LDBL_DIG __LDBL_DIG__


#undef FLT_MIN_EXP
#undef DBL_MIN_EXP
#undef LDBL_MIN_EXP
#define FLT_MIN_EXP __FLT_MIN_EXP__
#define DBL_MIN_EXP __DBL_MIN_EXP__
#define LDBL_MIN_EXP __LDBL_MIN_EXP__






#undef FLT_MIN_10_EXP
#undef DBL_MIN_10_EXP
#undef LDBL_MIN_10_EXP
#define FLT_MIN_10_EXP __FLT_MIN_10_EXP__
#define DBL_MIN_10_EXP __DBL_MIN_10_EXP__
#define LDBL_MIN_10_EXP __LDBL_MIN_10_EXP__


#undef FLT_MAX_EXP
#undef DBL_MAX_EXP
#undef LDBL_MAX_EXP
#define FLT_MAX_EXP __FLT_MAX_EXP__
#define DBL_MAX_EXP __DBL_MAX_EXP__
#define LDBL_MAX_EXP __LDBL_MAX_EXP__






#undef FLT_MAX_10_EXP
#undef DBL_MAX_10_EXP
#undef LDBL_MAX_10_EXP
#define FLT_MAX_10_EXP __FLT_MAX_10_EXP__
#define DBL_MAX_10_EXP __DBL_MAX_10_EXP__
#define LDBL_MAX_10_EXP __LDBL_MAX_10_EXP__





#undef FLT_MAX
#undef DBL_MAX
#undef LDBL_MAX
#define FLT_MAX __FLT_MAX__
#define DBL_MAX __DBL_MAX__
#define LDBL_MAX __LDBL_MAX__



#undef FLT_EPSILON
#undef DBL_EPSILON
#undef LDBL_EPSILON
#define FLT_EPSILON __FLT_EPSILON__
#define DBL_EPSILON __DBL_EPSILON__
#define LDBL_EPSILON __LDBL_EPSILON__


#undef FLT_MIN
#undef DBL_MIN
#undef LDBL_MIN
#define FLT_MIN __FLT_MIN__
#define DBL_MIN __DBL_MIN__
#define LDBL_MIN __LDBL_MIN__



#undef FLT_ROUNDS
#define FLT_ROUNDS 1
# 193 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/float.h" 3 4
#undef FLT_EVAL_METHOD



#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
# 208 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/float.h" 3 4
#undef DECIMAL_DIG
#define DECIMAL_DIG __DECIMAL_DIG__






#undef FLT_DECIMAL_DIG
#undef DBL_DECIMAL_DIG
#undef LDBL_DECIMAL_DIG
#define FLT_DECIMAL_DIG __FLT_DECIMAL_DIG__
#define DBL_DECIMAL_DIG __DBL_DECIMAL_DIG__
#define LDBL_DECIMAL_DIG __LDBL_DECIMAL_DIG__


#undef FLT_HAS_SUBNORM
#undef DBL_HAS_SUBNORM
#undef LDBL_HAS_SUBNORM
#define FLT_HAS_SUBNORM __FLT_HAS_DENORM__
#define DBL_HAS_SUBNORM __DBL_HAS_DENORM__
#define LDBL_HAS_SUBNORM __LDBL_HAS_DENORM__


#undef FLT_TRUE_MIN
#undef DBL_TRUE_MIN
#undef LDBL_TRUE_MIN
#define FLT_TRUE_MIN __FLT_DENORM_MIN__
#define DBL_TRUE_MIN __DBL_DENORM_MIN__
#define LDBL_TRUE_MIN __LDBL_DENORM_MIN__
# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 2
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 1 3


#define _MATH_H_ 



# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/ieeefp.h" 1 3
# 8 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 2 3



# 10 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
extern "C" {


#define _M_LN2 0.693147180559945309417





#define HUGE_VAL (__builtin_huge_val())



#define HUGE_VALF (__builtin_huge_valf())



#define HUGE_VALL (__builtin_huge_vall())



#define INFINITY (__builtin_inff())



#define NAN (__builtin_nanf(""))
# 86 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
extern double atan (double);
extern double cos (double);
extern double sin (double);
extern double tan (double);
extern double tanh (double);
extern double frexp (double, int *);
extern double modf (double, double *);
extern double ceil (double);
extern double fabs (double);
extern double floor (double);






extern double acos (double);
extern double asin (double);
extern double atan2 (double, double);
extern double cosh (double);
extern double sinh (double);
extern double exp (double);
extern double ldexp (double, int);
extern double log (double);
extern double log10 (double);
extern double pow (double, double);
extern double sqrt (double);
extern double fmod (double, double);
# 160 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
    typedef float float_t;
    typedef double double_t;
# 190 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
#define FP_NAN 0
#define FP_INFINITE 1
#define FP_ZERO 2
#define FP_SUBNORMAL 3
#define FP_NORMAL 4


#define FP_ILOGB0 (-__INT_MAX__)


#define FP_ILOGBNAN __INT_MAX__



#define MATH_ERRNO 1


#define MATH_ERREXCEPT 2





#define _MATH_ERRHANDLING_ERRNO MATH_ERRNO


#define _MATH_ERRHANDLING_ERREXCEPT MATH_ERREXCEPT



#define math_errhandling (_MATH_ERRHANDLING_ERRNO | _MATH_ERRHANDLING_ERREXCEPT)


extern int __isinff (float);
extern int __isinfd (double);
extern int __isnanf (float);
extern int __isnand (double);
extern int __fpclassifyf (float);
extern int __fpclassifyd (double);
extern int __signbitf (float);
extern int __signbitd (double);
# 240 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
#define fpclassify(__x) (__builtin_fpclassify (FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, __x))



#define isfinite(__x) (__builtin_isfinite (__x))


#define isinf(__x) (__builtin_isinf_sign (__x))


#define isnan(__x) (__builtin_isnan (__x))

#define isnormal(__x) (__builtin_isnormal (__x))
# 273 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
#define signbit(__x) ((sizeof(__x) == sizeof(float)) ? __builtin_signbitf(__x) : (sizeof(__x) == sizeof(double)) ? __builtin_signbit (__x) : __builtin_signbitl(__x))
# 289 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
#define isgreater(__x,__y) (__builtin_isgreater (__x, __y))
#define isgreaterequal(__x,__y) (__builtin_isgreaterequal (__x, __y))
#define isless(__x,__y) (__builtin_isless (__x, __y))
#define islessequal(__x,__y) (__builtin_islessequal (__x, __y))
#define islessgreater(__x,__y) (__builtin_islessgreater (__x, __y))
#define isunordered(__x,__y) (__builtin_isunordered (__x, __y))
# 319 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
extern double infinity (void);
extern double nan (const char *);
extern double copysign (double, double);
extern double logb (double);
extern int ilogb (double);

extern double asinh (double);
extern double cbrt (double);
extern double nextafter (double, double);
extern double rint (double);
extern double scalbn (double, int);

extern double exp2 (double);
extern double scalbln (double, long int);
extern double tgamma (double);
extern double nearbyint (double);
extern long int lrint (double);
extern long long int llrint (double);
extern double round (double);
extern long int lround (double);
extern long long int llround (double);
extern double trunc (double);
extern double remquo (double, double, int *);
extern double fdim (double, double);
extern double fmax (double, double);
extern double fmin (double, double);
extern double fma (double, double, double);


extern double log1p (double);
extern double expm1 (double);



extern double acosh (double);
extern double atanh (double);
extern double remainder (double, double);
extern double gamma (double);
extern double lgamma (double);
extern double erf (double);
extern double erfc (double);
extern double log2 (double);





extern double hypot (double, double);






extern float atanf (float);
extern float cosf (float);
extern float sinf (float);
extern float tanf (float);
extern float tanhf (float);
extern float frexpf (float, int *);
extern float modff (float, float *);
extern float ceilf (float);
extern float fabsf (float);
extern float floorf (float);


extern float acosf (float);
extern float asinf (float);
extern float atan2f (float, float);
extern float coshf (float);
extern float sinhf (float);
extern float expf (float);
extern float ldexpf (float, int);
extern float logf (float);
extern float log10f (float);
extern float powf (float, float);
extern float sqrtf (float);
extern float fmodf (float, float);




extern float exp2f (float);
extern float scalblnf (float, long int);
extern float tgammaf (float);
extern float nearbyintf (float);
extern long int lrintf (float);
extern long long int llrintf (float);
extern float roundf (float);
extern long int lroundf (float);
extern long long int llroundf (float);
extern float truncf (float);
extern float remquof (float, float, int *);
extern float fdimf (float, float);
extern float fmaxf (float, float);
extern float fminf (float, float);
extern float fmaf (float, float, float);

extern float infinityf (void);
extern float nanf (const char *);
extern float copysignf (float, float);
extern float logbf (float);
extern int ilogbf (float);

extern float asinhf (float);
extern float cbrtf (float);
extern float nextafterf (float, float);
extern float rintf (float);
extern float scalbnf (float, int);
extern float log1pf (float);
extern float expm1f (float);


extern float acoshf (float);
extern float atanhf (float);
extern float remainderf (float, float);
extern float gammaf (float);
extern float lgammaf (float);
extern float erff (float);
extern float erfcf (float);
extern float log2f (float);
extern float hypotf (float, float);
# 453 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
extern long double atanl (long double);
extern long double cosl (long double);
extern long double sinl (long double);
extern long double tanl (long double);
extern long double tanhl (long double);
extern long double frexpl (long double, int *);
extern long double modfl (long double, long double *);
extern long double ceill (long double);
extern long double fabsl (long double);
extern long double floorl (long double);
extern long double log1pl (long double);
extern long double expm1l (long double);




extern long double acosl (long double);
extern long double asinl (long double);
extern long double atan2l (long double, long double);
extern long double coshl (long double);
extern long double sinhl (long double);
extern long double expl (long double);
extern long double ldexpl (long double, int);
extern long double logl (long double);
extern long double log10l (long double);
extern long double powl (long double, long double);
extern long double sqrtl (long double);
extern long double fmodl (long double, long double);
extern long double hypotl (long double, long double);


extern long double copysignl (long double, long double);
extern long double nanl (const char *);
extern int ilogbl (long double);
extern long double asinhl (long double);
extern long double cbrtl (long double);
extern long double nextafterl (long double, long double);
extern float nexttowardf (float, long double);
extern double nexttoward (double, long double);
extern long double nexttowardl (long double, long double);
extern long double logbl (long double);
extern long double log2l (long double);
extern long double rintl (long double);
extern long double scalbnl (long double, int);
extern long double exp2l (long double);
extern long double scalblnl (long double, long);
extern long double tgammal (long double);
extern long double nearbyintl (long double);
extern long int lrintl (long double);
extern long long int llrintl (long double);
extern long double roundl (long double);
extern long lroundl (long double);
extern long long int llroundl (long double);
extern long double truncl (long double);
extern long double remquol (long double, long double, int *);
extern long double fdiml (long double, long double);
extern long double fmaxl (long double, long double);
extern long double fminl (long double, long double);
extern long double fmal (long double, long double, long double);

extern long double acoshl (long double);
extern long double atanhl (long double);
extern long double remainderl (long double, long double);
extern long double lgammal (long double);
extern long double erfl (long double);
extern long double erfcl (long double);
# 639 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/math.h" 3
}
# 47 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
             
             
# 56 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
#define ETL_PUSHED_MIN_MAX 
# 49 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 2







#define ETL_LOG10_OF_2(x) (((x) * 301) / 1000)
# 82 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_useless_cast_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_useless_cast_push.h"
 
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_useless_cast_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuseless-cast"
# 83 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 2
#define ETL_NANF NAN
#define ETL_NAN static_cast<double>(NAN)
#define ETL_NANL static_cast<long double>(NAN)
#define ETL_HAS_NAN true
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 88 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 2
# 103 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
namespace etl
{
  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3,
  };

  enum float_denorm_style
  {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
  };

  namespace private_limits
  {


    template <typename T = void>
    class integral_limits_common
    {
    public:

      static constexpr bool is_specialized = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int max_digits10 = 0;
      static constexpr int radix = 2;
      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;
      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr bool has_denorm_loss = false;
      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool traps = false;
      static constexpr bool tinyness_before = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr float_round_style round_style = round_toward_zero;
    };

    template <typename T>
    constexpr bool integral_limits_common<T>::is_specialized;

    template <typename T>
    constexpr bool integral_limits_common<T>::is_integer;

    template <typename T>
    constexpr bool integral_limits_common<T>::is_exact;

    template <typename T>
    constexpr int integral_limits_common<T>::max_digits10;

    template <typename T>
    constexpr int integral_limits_common<T>::radix;

    template <typename T>
    constexpr int integral_limits_common<T>::min_exponent;

    template <typename T>
    constexpr int integral_limits_common<T>::min_exponent10;

    template <typename T>
    constexpr int integral_limits_common<T>::max_exponent;

    template <typename T>
    constexpr int integral_limits_common<T>::max_exponent10;

    template <typename T>
    constexpr bool integral_limits_common<T>::has_infinity;

    template <typename T>
    constexpr bool integral_limits_common<T>::has_quiet_NaN;

    template <typename T>
    constexpr bool integral_limits_common<T>::has_signaling_NaN;

    template <typename T>
    constexpr bool integral_limits_common<T>::has_denorm_loss;

    template <typename T>
    constexpr bool integral_limits_common<T>::is_iec559;

    template <typename T>
    constexpr bool integral_limits_common<T>::is_bounded;

    template <typename T>
    constexpr bool integral_limits_common<T>::traps;

    template <typename T>
    constexpr bool integral_limits_common<T>::tinyness_before;

    template <typename T>
    constexpr float_denorm_style integral_limits_common<T>::has_denorm;

    template <typename T>
    constexpr float_round_style integral_limits_common<T>::round_style;



    template <typename T = void>
    struct integral_limits_bool
    {
      static constexpr int digits = 1;
      static constexpr int digits10 = 0;
      static constexpr bool is_signed = false;
      static constexpr bool is_modulo = false;
    };

    template <typename T>
    constexpr int integral_limits_bool<T>::digits;

    template <typename T>
    constexpr int integral_limits_bool<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_bool<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_bool<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_char
    {
      static constexpr int digits = (8 
# 236 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(char)) - (etl::is_signed<char>::value ? 1 : 0);
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = etl::is_signed<char>::value;
      static constexpr bool is_modulo = etl::is_unsigned<char>::value;
    };

    template <typename T>
    constexpr int integral_limits_char<T>::digits;

    template <typename T>
    constexpr int integral_limits_char<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_char<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_char<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_unsigned_char
    {
      static constexpr int digits = (8 
# 259 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(unsigned char));
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = false;
      static constexpr bool is_modulo = true;
    };

    template <typename T>
    constexpr int integral_limits_unsigned_char<T>::digits;

    template <typename T>
    constexpr int integral_limits_unsigned_char<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_unsigned_char<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_unsigned_char<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_signed_char
    {
      static constexpr int digits = (8 
# 282 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(char)) - 1;
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = true;
      static constexpr bool is_modulo = false;
    };

    template <typename T>
    constexpr int integral_limits_signed_char<T>::digits;

    template <typename T>
    constexpr int integral_limits_signed_char<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_signed_char<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_signed_char<T>::is_modulo;




    template <typename T = void>
    struct integral_limits_char8_t
    {
      static constexpr int digits = (8 
# 306 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(char8_t)) - (etl::is_signed<char8_t>::value ? 1 : 0);
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = etl::is_signed<char8_t>::value;
      static constexpr bool is_modulo = false;
    };

    template <typename T>
    constexpr int integral_limits_char8_t<T>::digits;

    template <typename T>
    constexpr int integral_limits_char8_t<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_char8_t<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_char8_t<T>::is_modulo;





    template <typename T = void>
    struct integral_limits_char16_t
    {
      static constexpr int digits = (8 
# 331 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(char16_t));
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = false;
      static constexpr bool is_modulo = true;
    };

    template <typename T>
    constexpr int integral_limits_char16_t<T>::digits;

    template <typename T>
    constexpr int integral_limits_char16_t<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_char16_t<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_char16_t<T>::is_modulo;





    template <typename T = void>
    struct integral_limits_char32_t
    {
      static constexpr int digits = (8 
# 356 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(char32_t));
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = false;
      static constexpr bool is_modulo = true;
    };

    template <typename T>
    constexpr int integral_limits_char32_t<T>::digits;

    template <typename T>
    constexpr int integral_limits_char32_t<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_char32_t<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_char32_t<T>::is_modulo;




    template <typename T = void>
    struct integral_limits_wchar_t
    {
      static constexpr int digits = (8 
# 380 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(wchar_t)) - (etl::is_signed<wchar_t>::value ? 1 : 0);
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = etl::is_signed<wchar_t>::value;
      static constexpr bool is_modulo = etl::is_unsigned<wchar_t>::value;
    };

    template <typename T>
    constexpr int integral_limits_wchar_t<T>::digits;

    template <typename T>
    constexpr int integral_limits_wchar_t<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_wchar_t<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_wchar_t<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_short
    {
      static constexpr int digits = (8 
# 403 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(short)) - 1;
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = true;
      static constexpr bool is_modulo = false;
    };

    template <typename T>
    constexpr int integral_limits_short<T>::digits;

    template <typename T>
    constexpr int integral_limits_short<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_short<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_short<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_unsigned_short
    {
      static constexpr int digits = (8 
# 426 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(unsigned short));
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = false;
      static constexpr bool is_modulo = true;
    };

    template <typename T>
    constexpr int integral_limits_unsigned_short<T>::digits;

    template <typename T>
    constexpr int integral_limits_unsigned_short<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_unsigned_short<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_unsigned_short<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_int
    {
      static constexpr int digits = (8 
# 449 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(int)) - 1;
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = true;
      static constexpr bool is_modulo = false;
    };

    template <typename T>
    constexpr int integral_limits_int<T>::digits;

    template <typename T>
    constexpr int integral_limits_int<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_int<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_int<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_unsigned_int
    {
      static constexpr int digits = (8 
# 472 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(unsigned int));
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = false;
      static constexpr bool is_modulo = true;
    };

    template <typename T>
    constexpr int integral_limits_unsigned_int<T>::digits;

    template <typename T>
    constexpr int integral_limits_unsigned_int<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_unsigned_int<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_unsigned_int<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_long
    {
      static constexpr int digits = (8 
# 495 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(long)) - 1;
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = true;
      static constexpr bool is_modulo = false;
    };

    template <typename T>
    constexpr int integral_limits_long<T>::digits;

    template <typename T>
    constexpr int integral_limits_long<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_long<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_long<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_unsigned_long
    {
      static constexpr int digits = (8 
# 518 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(unsigned long));
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = false;
      static constexpr bool is_modulo = true;
    };

    template <typename T>
    constexpr int integral_limits_unsigned_long<T>::digits;

    template <typename T>
    constexpr int integral_limits_unsigned_long<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_unsigned_long<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_unsigned_long<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_long_long
    {
      static constexpr int digits = (8 
# 541 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(long long)) - 1;
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = true;
      static constexpr bool is_modulo = false;
    };

    template <typename T>
    constexpr int integral_limits_long_long<T>::digits;

    template <typename T>
    constexpr int integral_limits_long_long<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_long_long<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_long_long<T>::is_modulo;



    template <typename T = void>
    struct integral_limits_unsigned_long_long
    {
      static constexpr int digits = (8 
# 564 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    * sizeof(unsigned long long));
      static constexpr int digits10 = (((digits) * 301) / 1000);
      static constexpr bool is_signed = false;
      static constexpr bool is_modulo = true;
    };

    template <typename T>
    constexpr int integral_limits_unsigned_long_long<T>::digits;

    template <typename T>
    constexpr int integral_limits_unsigned_long_long<T>::digits10;

    template <typename T>
    constexpr bool integral_limits_unsigned_long_long<T>::is_signed;

    template <typename T>
    constexpr bool integral_limits_unsigned_long_long<T>::is_modulo;



    template <typename T = void>
    class floating_point_limits_common
    {
    public:

      static constexpr bool is_specialized = true;
      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;
      static constexpr bool has_infinity = true;
      static constexpr bool has_quiet_NaN = true;
      static constexpr bool has_signaling_NaN = true;
      static constexpr bool has_denorm_loss = false;
      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;
      static constexpr bool traps = false;
      static constexpr bool tinyness_before = false;
      static constexpr float_denorm_style has_denorm = denorm_indeterminate;
      static constexpr float_round_style round_style = round_indeterminate;
    };

    template <typename T>
    constexpr bool floating_point_limits_common<T>::is_specialized;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::is_signed;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::is_integer;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::is_exact;

    template <typename T>
    constexpr int floating_point_limits_common<T>::radix;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::has_infinity;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::has_quiet_NaN;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::has_signaling_NaN;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::has_denorm_loss;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::is_iec559;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::is_bounded;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::is_modulo;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::traps;

    template <typename T>
    constexpr bool floating_point_limits_common<T>::tinyness_before;

    template <typename T>
    constexpr float_denorm_style floating_point_limits_common<T>::has_denorm;

    template <typename T>
    constexpr float_round_style floating_point_limits_common<T>::round_style;



    template <typename T = void>
    struct floating_point_limits_float
    {
      static constexpr int digits = 24
# 660 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                          ;
      static constexpr int digits10 = 6
# 661 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                     ;
      static constexpr int max_digits10 = (((24
# 662 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                              ) * 301) / 1000) + 2;

      static constexpr int min_exponent = (-125)
# 664 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                         ;
      static constexpr int min_exponent10 = (-37)
# 665 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ;
      static constexpr int max_exponent = 128
# 666 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                         ;
      static constexpr int max_exponent10 = 38
# 667 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ;
    };

    template <typename T>
    constexpr int floating_point_limits_float<T>::digits;

    template <typename T>
    constexpr int floating_point_limits_float<T>::digits10;

    template <typename T>
    constexpr int floating_point_limits_float<T>::max_digits10;

    template <typename T>
    constexpr int floating_point_limits_float<T>::min_exponent;

    template <typename T>
    constexpr int floating_point_limits_float<T>::min_exponent10;

    template <typename T>
    constexpr int floating_point_limits_float<T>::max_exponent;

    template <typename T>
    constexpr int floating_point_limits_float<T>::max_exponent10;



    template <typename T = void>
    struct floating_point_limits_double
    {
      static constexpr int digits = 53
# 696 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                          ;
      static constexpr int digits10 = 15
# 697 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                     ;
      static constexpr int max_digits10 = (((53
# 698 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                              ) * 301) / 1000) + 2;

      static constexpr int min_exponent = (-1021)
# 700 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                         ;
      static constexpr int min_exponent10 = (-307)
# 701 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ;
      static constexpr int max_exponent = 1024
# 702 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                         ;
      static constexpr int max_exponent10 = 308
# 703 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ;
    };

    template <typename T>
    constexpr int floating_point_limits_double<T>::digits;

    template <typename T>
    constexpr int floating_point_limits_double<T>::digits10;

    template <typename T>
    constexpr int floating_point_limits_double<T>::max_digits10;

    template <typename T>
    constexpr int floating_point_limits_double<T>::min_exponent;

    template <typename T>
    constexpr int floating_point_limits_double<T>::min_exponent10;

    template <typename T>
    constexpr int floating_point_limits_double<T>::max_exponent;

    template <typename T>
    constexpr int floating_point_limits_double<T>::max_exponent10;



    template <typename T = void>
    struct floating_point_limits_long_double
    {
      static constexpr int digits = 113
# 732 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                           ;
      static constexpr int digits10 = 33
# 733 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                      ;
      static constexpr int max_digits10 = (((113
# 734 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                              ) * 301) / 1000) + 2;

      static constexpr int min_exponent = (-16381)
# 736 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                          ;
      static constexpr int min_exponent10 = (-4931)
# 737 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                             ;
      static constexpr int max_exponent = 16384
# 738 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                          ;
      static constexpr int max_exponent10 = 4932
# 739 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                             ;
    };

    template <typename T>
    constexpr int floating_point_limits_long_double<T>::digits;

    template <typename T>
    constexpr int floating_point_limits_long_double<T>::digits10;

    template <typename T>
    constexpr int floating_point_limits_long_double<T>::max_digits10;

    template <typename T>
    constexpr int floating_point_limits_long_double<T>::min_exponent;

    template <typename T>
    constexpr int floating_point_limits_long_double<T>::min_exponent10;

    template <typename T>
    constexpr int floating_point_limits_long_double<T>::max_exponent;

    template <typename T>
    constexpr int floating_point_limits_long_double<T>::max_exponent10;
  }



  template <typename T>
  class numeric_limits;

  template <typename T>
  class numeric_limits<const T> : public numeric_limits<T> { };

  template <typename T>
  class numeric_limits<volatile T> : public numeric_limits<T> { };

  template <typename T>
  class numeric_limits<const volatile T> : public numeric_limits<T> { };



  template<>
  class numeric_limits<bool> : public private_limits::integral_limits_common<>,
                               public private_limits::integral_limits_bool<>
  {
  public:

    static constexpr bool min() { return false; }
    static constexpr bool max() { return true; }
    static constexpr bool lowest() { return false; }
    static constexpr bool epsilon() { return false; }
    static constexpr bool round_error() { return false; }
    static constexpr bool denorm_min() { return false; }
    static constexpr bool infinity() { return false; }
    static constexpr bool quiet_NaN() { return false; }
    static constexpr bool signaling_NaN() { return false; }
  };



  template<>
  class numeric_limits<char> : public private_limits::integral_limits_common<>,
                               public private_limits::integral_limits_char<>
  {
  public:

    static constexpr char min() { return char(
# 805 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                 0
# 805 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                         ); }
    static constexpr char max() { return char(
# 806 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                 (0x7f * 2 + 1)
# 806 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                         ); }
    static constexpr char lowest() { return char(
# 807 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                    0
# 807 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ); }
    static constexpr char epsilon() { return 0; }
    static constexpr char round_error() { return 0; }
    static constexpr char denorm_min() { return 0; }
    static constexpr char infinity() { return 0; }
    static constexpr char quiet_NaN() { return 0; }
    static constexpr char signaling_NaN() { return 0; }
  };



  template<>
  class numeric_limits<unsigned char> : public private_limits::integral_limits_common<>,
                                        public private_limits::integral_limits_unsigned_char<>
  {
  public:

    static constexpr unsigned char min() { return 0U; }
    static constexpr unsigned char max() { return 
# 825 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                     (0x7f * 2 + 1)
# 825 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                              ; }
    static constexpr unsigned char lowest() { return 0U; }
    static constexpr unsigned char epsilon() { return 0U; }
    static constexpr unsigned char round_error() { return 0U; }
    static constexpr unsigned char denorm_min() { return 0U; }
    static constexpr unsigned char infinity() { return 0U; }
    static constexpr unsigned char quiet_NaN() { return 0U; }
    static constexpr unsigned char signaling_NaN() { return 0U; }
  };



  template<>
  class numeric_limits<signed char> : public private_limits::integral_limits_common<>,
                                      public private_limits::integral_limits_signed_char<>
  {
  public:

    static constexpr signed char min() { return 
# 843 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                   (-0x7f - 1)
# 843 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ; }
    static constexpr signed char max() { return 0x7f
# 844 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ; }
    static constexpr signed char lowest() { return 
# 845 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                      (-0x7f - 1)
# 845 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                               ; }
    static constexpr signed char epsilon() { return 0; }
    static constexpr signed char round_error() { return 0; }
    static constexpr signed char denorm_min() { return 0; }
    static constexpr signed char infinity() { return 0; }
    static constexpr signed char quiet_NaN() { return 0; }
    static constexpr signed char signaling_NaN() { return 0; }
  };




  template<>
  class numeric_limits<char8_t> : public private_limits::integral_limits_common<>,
                                  public private_limits::integral_limits_char8_t<>
  {
  public:

    static constexpr char8_t min() { return char8_t(
# 863 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                       0
# 863 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                               ); }
    static constexpr char8_t max() { return char8_t(
# 864 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                       (0x7f * 2 + 1)
# 864 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                               ); }
    static constexpr char8_t lowest() { return char8_t(
# 865 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                          0
# 865 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                                  ); }
    static constexpr char8_t epsilon() { return 0; }
    static constexpr char8_t round_error() { return 0; }
    static constexpr char8_t denorm_min() { return 0; }
    static constexpr char8_t infinity() { return 0; }
    static constexpr char8_t quiet_NaN() { return 0; }
    static constexpr char8_t signaling_NaN() { return 0; }
  };





  template<>
  class numeric_limits<char16_t> : public private_limits::integral_limits_common<>,
                                   public private_limits::integral_limits_char16_t<>
  {
  public:

    static constexpr char16_t min() { return 0U; }
    static constexpr char16_t max() { return 0xffff
# 885 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                                ; }
    static constexpr char16_t lowest() { return 0U; }
    static constexpr char16_t epsilon() { return 0U; }
    static constexpr char16_t round_error() { return 0U; }
    static constexpr char16_t denorm_min() { return 0U; }
    static constexpr char16_t infinity() { return 0U; }
    static constexpr char16_t quiet_NaN() { return 0U; }
    static constexpr char16_t signaling_NaN() { return 0U; }
  };





  template<>
  class numeric_limits<char32_t> : public private_limits::integral_limits_common<>,
                                   public private_limits::integral_limits_char32_t<>
  {
  public:

    static constexpr char32_t min() { return 0U; }
    static constexpr char32_t max() { return 0xffffffffUL
# 906 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                                ; }
    static constexpr char32_t lowest() { return 0U; }
    static constexpr char32_t epsilon() { return 0U; }
    static constexpr char32_t round_error() { return 0U; }
    static constexpr char32_t denorm_min() { return 0U; }
    static constexpr char32_t infinity() { return 0U; }
    static constexpr char32_t quiet_NaN() { return 0U; }
    static constexpr char32_t signaling_NaN() { return 0U; }
  };




  template<>
  class numeric_limits<wchar_t> : public private_limits::integral_limits_common<>,
                                  public private_limits::integral_limits_wchar_t<>
  {
  public:

    static constexpr wchar_t min() { return (-0x7fffffff - 1)
# 925 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                        ; }
    static constexpr wchar_t max() { return 0x7fffffff
# 926 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                        ; }
    static constexpr wchar_t lowest() { return (-0x7fffffff - 1)
# 927 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                           ; }
    static constexpr wchar_t epsilon() { return wchar_t(0); }
    static constexpr wchar_t round_error() { return wchar_t(0); }
    static constexpr wchar_t denorm_min() { return wchar_t(0); }
    static constexpr wchar_t infinity() { return wchar_t(0); }
    static constexpr wchar_t quiet_NaN() { return wchar_t(0); }
    static constexpr wchar_t signaling_NaN() { return wchar_t(0); }
  };



  template<>
  class numeric_limits<short> : public private_limits::integral_limits_common<>,
                                public private_limits::integral_limits_short<>
  {
  public:

    static constexpr short min() { return 
# 944 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                             (-0x7fff - 1)
# 944 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                     ; }
    static constexpr short max() { return 0x7fff
# 945 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                     ; }
    static constexpr short lowest() { return 
# 946 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                (-0x7fff - 1)
# 946 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                        ; }
    static constexpr short epsilon() { return 0; }
    static constexpr short round_error() { return 0; }
    static constexpr short denorm_min() { return 0; }
    static constexpr short infinity() { return 0; }
    static constexpr short quiet_NaN() { return 0; }
    static constexpr short signaling_NaN() { return 0; }
  };



  template<>
  class numeric_limits<unsigned short> : public private_limits::integral_limits_common<>,
                                         public private_limits::integral_limits_unsigned_short<>
  {
  public:

    static constexpr unsigned short min() { return 0U; }
    static constexpr unsigned short max() { return 
# 964 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                      (0x7fff * 2 + 1)
# 964 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                               ; }
    static constexpr unsigned short lowest() { return 0U; }
    static constexpr unsigned short epsilon() { return 0U; }
    static constexpr unsigned short round_error() { return 0U; }
    static constexpr unsigned short denorm_min() { return 0U; }
    static constexpr unsigned short infinity() { return 0U; }
    static constexpr unsigned short quiet_NaN() { return 0U; }
    static constexpr unsigned short signaling_NaN() { return 0U; }
  };



  template<>
  class numeric_limits<int> : public private_limits::integral_limits_common<>,
                              public private_limits::integral_limits_int<>
  {
  public:

    static constexpr int min() { return 
# 982 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                           (-0x7fffffff - 1)
# 982 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                  ; }
    static constexpr int max() { return 0x7fffffff
# 983 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                  ; }
    static constexpr int lowest() { return 
# 984 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                              (-0x7fffffff - 1)
# 984 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                     ; }
    static constexpr int epsilon() { return 0; }
    static constexpr int round_error() { return 0; }
    static constexpr int denorm_min() { return 0; }
    static constexpr int infinity() { return 0; }
    static constexpr int quiet_NaN() { return 0; }
    static constexpr int signaling_NaN() { return 0; }
  };



  template<>
  class numeric_limits<unsigned int> : public private_limits::integral_limits_common<>,
                                       public private_limits::integral_limits_unsigned_int<>
  {
  public:

    static constexpr unsigned int min() { return 0U; }
    static constexpr unsigned int max() { return 
# 1002 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                    (0x7fffffff * 2U + 1U)
# 1002 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ; }
    static constexpr unsigned int lowest() { return 0U; }
    static constexpr unsigned int epsilon() { return 0U; }
    static constexpr unsigned int round_error() { return 0U; }
    static constexpr unsigned int denorm_min() { return 0U; }
    static constexpr unsigned int infinity() { return 0U; }
    static constexpr unsigned int quiet_NaN() { return 0U; }
    static constexpr unsigned int signaling_NaN() { return 0U; }
  };



  template<>
  class numeric_limits<long> : public private_limits::integral_limits_common<>,
                               public private_limits::integral_limits_long<>
  {
  public:

    static constexpr long min() { return 
# 1020 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                            (-0x7fffffffL - 1L)
# 1020 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    ; }
    static constexpr long max() { return 0x7fffffffL
# 1021 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    ; }
    static constexpr long lowest() { return 
# 1022 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                               (-0x7fffffffL - 1L)
# 1022 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                       ; }
    static constexpr long epsilon() { return 0; }
    static constexpr long round_error() { return 0; }
    static constexpr long denorm_min() { return 0; }
    static constexpr long infinity() { return 0; }
    static constexpr long quiet_NaN() { return 0; }
    static constexpr long signaling_NaN() { return 0; }
  };



  template<>
  class numeric_limits<unsigned long> : public private_limits::integral_limits_common<>,
                                        public private_limits::integral_limits_unsigned_long<>
  {
  public:

    static constexpr unsigned long min() { return 0U; }
    static constexpr unsigned long max() { return 
# 1040 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3 4
                                                     (0x7fffffffL * 2UL + 1UL)
# 1040 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                              ; }
    static constexpr unsigned long lowest() { return 0U; }
    static constexpr unsigned long epsilon() { return 0U; }
    static constexpr unsigned long round_error() { return 0U; }
    static constexpr unsigned long denorm_min() { return 0U; }
    static constexpr unsigned long infinity() { return 0U; }
    static constexpr unsigned long quiet_NaN() { return 0U; }
    static constexpr unsigned long signaling_NaN() { return 0U; }
  };



  template<>
  class numeric_limits<long long> : public private_limits::integral_limits_common<>,
                                    public private_limits::integral_limits_long_long<>
  {
  public:

    static constexpr long long min() { return (-9223372036854775807LL - 1LL); }
    static constexpr long long max() { return 9223372036854775807LL; }
    static constexpr long long lowest() { return (-9223372036854775807LL - 1LL); }
    static constexpr long long epsilon() { return 0; }
    static constexpr long long round_error() { return 0; }
    static constexpr long long denorm_min() { return 0; }
    static constexpr long long infinity() { return 0; }
    static constexpr long long quiet_NaN() { return 0; }
    static constexpr long long signaling_NaN() { return 0; }
  };



  template<>
  class numeric_limits<unsigned long long> : public private_limits::integral_limits_common<>,
                                             public private_limits::integral_limits_unsigned_long_long<>
  {
  public:

    static constexpr unsigned long long min() { return 0U; }
    static constexpr unsigned long long max() { return 18446744073709551615ULL; }
    static constexpr unsigned long long lowest() { return 0U; }
    static constexpr unsigned long long epsilon() { return 0U; }
    static constexpr unsigned long long round_error() { return 0U; }
    static constexpr unsigned long long denorm_min() { return 0U; }
    static constexpr unsigned long long infinity() { return 0U; }
    static constexpr unsigned long long quiet_NaN() { return 0U; }
    static constexpr unsigned long long signaling_NaN() { return 0U; }
  };



  template<>
  class numeric_limits<float> : public private_limits::floating_point_limits_common<>,
                                public private_limits::floating_point_limits_float<>
  {
  public:

    static constexpr float min() { return 1.17549435082228750796873653722224568e-38F
# 1096 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    ; }
    static constexpr float max() { return 3.40282346638528859811704183484516925e+38F
# 1097 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                    ; }
    static constexpr float lowest() { return -3.40282346638528859811704183484516925e+38F
# 1098 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                        ; }
    static constexpr float epsilon() { return 1.19209289550781250000000000000000000e-7F
# 1099 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ; }
    static constexpr float denorm_min() { return 1.17549435082228750796873653722224568e-38F
# 1100 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                           ; }
    static constexpr float infinity() { return 
# 1101 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3
                                                  (__builtin_huge_valf())
# 1101 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                           ; }
    static float round_error() { return 0.5f; }
    static float quiet_NaN() { return 
# 1103 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3
                                     (__builtin_nanf(""))
# 1103 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                             ; }
    static float signaling_NaN() { return 
# 1104 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3
                                         (__builtin_nanf(""))
# 1104 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                 ; }
  };



  template<>
  class numeric_limits<double> : public private_limits::floating_point_limits_common<>,
                                 public private_limits::floating_point_limits_double<>
  {
  public:

    static constexpr double min() { return double(2.22507385850720138309023271733240406e-308L)
# 1115 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                     ; }
    static constexpr double max() { return double(1.79769313486231570814527423731704357e+308L)
# 1116 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                     ; }
    static constexpr double lowest() { return -double(1.79769313486231570814527423731704357e+308L)
# 1117 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                         ; }
    static constexpr double epsilon() { return double(2.22044604925031308084726333618164062e-16L)
# 1118 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                             ; }
    static constexpr double denorm_min() { return double(2.22507385850720138309023271733240406e-308L)
# 1119 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                            ; }
    static constexpr double infinity() { return 
# 1120 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3
                                                   (__builtin_huge_val())
# 1120 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                           ; }
    static double round_error() { return 0.5; }
    static double quiet_NaN() { return static_cast<double>(
# 1122 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3
                                      (__builtin_nanf(""))
# 1122 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                      ); }
    static double signaling_NaN() { return static_cast<double>(
# 1123 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3
                                          (__builtin_nanf(""))
# 1123 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                          ); }
  };



  template<>
  class numeric_limits<long double> : public private_limits::floating_point_limits_common<>,
                                      public private_limits::floating_point_limits_long_double<>
  {
  public:

    static constexpr long double min() { return 3.36210314311209350626267781732175260e-4932L
# 1134 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                           ; }
    static constexpr long double max() { return 1.18973149535723176508575932662800702e+4932L
# 1135 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                           ; }
    static constexpr long double lowest() { return -1.18973149535723176508575932662800702e+4932L
# 1136 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                               ; }
    static constexpr long double epsilon() { return 1.92592994438723585305597794258492732e-34L
# 1137 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                                   ; }
    static constexpr long double denorm_min() { return 3.36210314311209350626267781732175260e-4932L
# 1138 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                                  ; }
    static constexpr long double infinity() { return 
# 1139 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3
                                                        (__builtin_huge_vall())
# 1139 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                                                 ; }
    static long double round_error() { return 0.5L; }
    static long double quiet_NaN() { return static_cast<long double>(
# 1141 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3
                                           (__builtin_nanf(""))
# 1141 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                           ); }
    static long double signaling_NaN() { return static_cast<long double>(
# 1142 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 3
                                               (__builtin_nanf(""))
# 1142 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
                                               ); }
  };
}
# 1186 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
             
             
# 52 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
#undef ETL_PUSHED_MIN_MAX
# 1187 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/limits.h" 2
# 42 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/binary.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/log.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/log.h"
#define ETL_LOG_INCLUDED 



# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/log.h" 2







namespace etl
{
# 54 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/log.h"
  template <size_t Value, size_t Base>
  struct log
  {
    enum value_type
    {

      value = (Value >= Base) ? 1 + log<Value / Base, Base>::value : 0
    };
  };




  template <size_t Base>
  struct log<1, Base>
  {
    enum value_type
    {
      value = 0
    };
  };




  template <size_t Base>
  struct log<0, Base>
  {
    enum value_type
    {
      value = 0
    };
  };


  template <size_t Value, size_t Base>
  inline constexpr size_t log_v = log<Value, Base>::value;






  template <size_t Value>
  struct log2
  {
    enum value_type
    {
      value = log<Value, 2>::value
    };
  };


  template <size_t Value>
  inline constexpr size_t log2_v = log2<Value>::value;






  template <size_t Value>
  struct log10
  {
    enum value_type
    {
      value = log<Value, 10>::value
    };
  };


  template <size_t Value>
  inline constexpr size_t log10_v = log10<Value>::value;

}
# 44 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/binary.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/power.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/power.h"
#define ETL_POW_INCLUDED 




# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/power.h" 2






namespace etl
{
  namespace private_power
  {



    typedef uint64_t type;

  }






  template <size_t Value, size_t Power>
  struct power
  {
    static constexpr private_power::type value = Value * power<Value, Power - 1>::value;
  };

  template <size_t Value, size_t Power>
  constexpr private_power::type power<Value, Power>::value;






  template <size_t Value>
  struct power<Value, 0>
  {
    static constexpr private_power::type value = 1;
  };

  template <size_t Value>
  constexpr private_power::type power<Value, 0>::value;


  template <size_t Value, size_t Power>
  inline constexpr size_t power_v = power<Value, Power>::value;






  template <size_t Value>
  struct power_of_2_round_up
  {
    enum value_type
    {
      value = 1 << (etl::log2<Value - 1>::value + 1)
    };
  };






  template <>
  struct power_of_2_round_up<0>
  {
    enum value_type
    {
      value = 2
    };
  };


  template <size_t Value>
  inline constexpr size_t power_of_2_round_up_v = power_of_2_round_up<Value>::value;






  template <size_t Value>
  struct power_of_2_round_down
  {
    enum value_type
    {
      value = 1 << (etl::log2<Value - 1>::value)
    };
  };






  template <>
  struct power_of_2_round_down<0>
  {
    enum value_type
    {
      value = 2
    };
  };






  template <>
  struct power_of_2_round_down<1>
  {
    enum value_type
    {
      value = 2
    };
  };






  template <>
  struct power_of_2_round_down<2>
  {
    enum value_type
    {
      value = 2
    };
  };


  template <size_t Value>
  inline constexpr size_t power_of_2_round_down_v = power_of_2_round_down<Value>::value;






  template <size_t Value>
  struct is_power_of_2
  {
    static constexpr bool value = (Value & (Value - 1)) == 0;
  };






  template <>
  struct is_power_of_2<0>
  {
    static constexpr bool value = false;
  };






  template <>
  struct is_power_of_2<1>
  {
    static constexpr bool value = false;
  };

  template <size_t Value>
  constexpr bool is_power_of_2<Value>::value;


  template <size_t Value>
  inline constexpr size_t is_power_of_2_v = is_power_of_2<Value>::value;

}
# 45 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/binary.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/smallest.h" 1
# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/binary.h" 2
# 54 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/binary.h"
namespace etl
{




  class binary_exception : public etl::exception
  {
  public:

    binary_exception(string_type reason_, string_type file_name_, numeric_type line_number_)
      : exception(reason_, file_name_, line_number_)
    {
    }
  };





  class binary_out_of_range : public etl::binary_exception
  {
  public:

    binary_out_of_range(string_type file_name_, numeric_type line_number_)
      : etl::binary_exception(("50""A"), file_name_, line_number_)
    {
    }
  };






  template <size_t NBits>
  struct max_value_for_nbits
  {
    typedef typename etl::smallest_uint_for_bits<NBits>::type value_type;
    static constexpr value_type value = (value_type(1) << (NBits - 1)) | max_value_for_nbits<NBits - 1>::value;
  };


  template <>
  struct max_value_for_nbits<0>
  {
    typedef etl::smallest_uint_for_bits<0>::type value_type;
    static constexpr value_type value = 0;
  };

  template <size_t NBits>
  constexpr typename max_value_for_nbits<NBits>::value_type max_value_for_nbits<NBits>::value;


  template <size_t NBits>
  inline constexpr typename etl::max_value_for_nbits<NBits>::value_type max_value_for_nbits_v = max_value_for_nbits<NBits>::value;






  template <typename T>
  constexpr T rotate_left(T value)
  {



    static_assert(etl::is_integral<T>::value, "Not an integral type");

    constexpr size_t SHIFT = etl::integral_limits<typename etl::make_unsigned<T>::type>::bits - 1U;

    return (value << 1U) | (value >> SHIFT);

  }





  template <typename T>
  constexpr T rotate_left(T value, size_t distance)
  {



    static_assert(etl::is_integral<T>::value, "Not an integral type");

    constexpr size_t BITS = etl::integral_limits<typename etl::make_unsigned<T>::type>::bits;
    distance %= BITS;
    const size_t SHIFT = BITS - distance;

    if (SHIFT == BITS)
    {
      return value;
    }
    else
    {
      return (value << distance) | (value >> SHIFT);
    }

  }





  template <typename T>
  constexpr T rotate_right(T value)
  {



    static_assert(etl::is_integral<T>::value, "Not an integral type");

    constexpr size_t SHIFT = etl::integral_limits<typename etl::make_unsigned<T>::type>::bits - 1U;

    return (value >> 1U) | (value << SHIFT);

  }





  template <typename T>
  constexpr T rotate_right(T value, size_t distance)
  {



    static_assert(etl::is_integral<T>::value, "Not an integral type");

    constexpr size_t BITS = etl::integral_limits<typename etl::make_unsigned<T>::type>::bits;
    distance %= BITS;
    const size_t SHIFT = BITS - distance;

    if (SHIFT == BITS)
    {
      return value;
    }
    else
    {
      return (value >> distance) | (value << SHIFT);
    }

  }






  template <typename T>
  constexpr T rotate(T value, typename etl::make_signed<size_t>::type distance)
  {
    static_assert(etl::is_integral<T>::value, "Not an integral type");

    T result = T();

    if (distance > 0)
    {
      result = rotate_left(value, size_t(distance));
    }
    else
    {
      result = rotate_right(value, size_t(-distance));
    }

    return result;
  }





  template <typename T>
  constexpr T binary_to_gray(T value)
  {
    static_assert(etl::is_integral<T>::value, "Not an integral type");

    return (value >> 1U) ^ value;
  }





  template <typename TReturn, size_t NBits, typename TValue>
  constexpr TReturn fold_bits(TValue value)
  {
    static_assert(integral_limits<TReturn>::bits >= NBits, "Return type too small to hold result");

    constexpr TValue mask = etl::power<2, NBits>::value - 1U;
    constexpr size_t shift = NBits;


    TReturn folded_value = 0;


    while (value >= etl::max_value_for_nbits<NBits>::value)
    {
      folded_value ^= value & mask;
      value >>= shift;
    }


    folded_value ^= value & mask;

    return folded_value;
  }






  template <typename TReturn, size_t NBits, typename TValue>
  constexpr TReturn sign_extend(TValue value)
  {
    static_assert(etl::is_integral<TValue>::value, "TValue not an integral type");
    static_assert(etl::is_integral<TReturn>::value, "TReturn not an integral type");
    static_assert(NBits <= etl::integral_limits<TReturn>::bits, "NBits too large for return type");

    struct S
    {
      signed value : NBits;
    } s = {0};

    return (s.value = value);
  }







  template <typename TReturn, size_t NBits, size_t SHIFT, typename TValue>
  constexpr TReturn sign_extend(TValue value)
  {
    static_assert(etl::is_integral<TValue>::value, "TValue not an integral type");
    static_assert(etl::is_integral<TReturn>::value, "TReturn not an integral type");
    static_assert(NBits <= etl::integral_limits<TReturn>::bits, "NBits too large for return type");
    static_assert(SHIFT <= etl::integral_limits<TReturn>::bits, "SHIFT too large");

    struct S
    {
      signed value : NBits;
    } s = {0};

    return (s.value = (value >> SHIFT));
  }






  template <typename TReturn, typename TValue>
  constexpr TReturn sign_extend(TValue value, size_t NBits)
  {
    static_assert(etl::is_integral<TValue>::value, "TValue not an integral type");
    static_assert(etl::is_integral<TReturn>::value, "TReturn not an integral type");

    static_cast<void>(sizeof((NBits <= etl::integral_limits<TReturn>::bits)));

    TReturn mask = TReturn(1) << (NBits - 1);
    value = value & TValue((TValue(1) << NBits) - 1);

    return TReturn((value ^ mask) - mask);
  }







  template <typename TReturn, typename TValue>
  constexpr TReturn sign_extend(TValue value, size_t NBits, size_t SHIFT)
  {
    static_assert(etl::is_integral<TValue>::value, "TValue not an integral type");
    static_assert(etl::is_integral<TReturn>::value, "TReturn not an integral type");

    static_cast<void>(sizeof((NBits <= etl::integral_limits<TReturn>::bits)));

    TReturn mask = TReturn(1) << (NBits - 1);
    value = (value >> SHIFT) & TValue((TValue(1) << NBits) - 1);

    return TReturn((value ^ mask) - mask);
  }






  template <size_t POSITION>
  struct bit
  {
    typedef typename etl::smallest_uint_for_bits<POSITION + 1U>::type value_type;
    static constexpr value_type value = value_type(1) << POSITION;
  };

  template <size_t POSITION>
  constexpr typename bit<POSITION>::value_type bit<POSITION>::value;


  template <size_t POSITION>
  using bit_t = typename etl::bit<POSITION>::value_type;



  template <size_t POSITION>
  inline constexpr bit_t<POSITION> bit_v = etl::bit<POSITION>::value;






  template <typename TResult, typename TValue>
  constexpr TResult binary_fill(TValue value)
  {
    static_assert(sizeof(TResult) >= sizeof(TValue), "Result must be at least as large as the fill value");

    typedef typename etl::make_unsigned<TResult>::type unsigned_r_t;
    typedef typename etl::make_unsigned<TValue>::type unsigned_v_t;

    return TResult(unsigned_v_t(value) * (unsigned_r_t(~unsigned_r_t(0U)) / unsigned_v_t(~unsigned_v_t(0U))));
  }





  template <typename TResult, typename TValue, TValue Value>
  constexpr TResult binary_fill()
  {
    static_assert(sizeof(TResult) >= sizeof(TValue), "Result must be at least as large as the fill value");

    typedef typename etl::make_unsigned<TResult>::type unsigned_r_t;
    typedef typename etl::make_unsigned<TValue>::type unsigned_v_t;

    return TResult(unsigned_v_t(Value) * (unsigned_r_t(~unsigned_r_t(0U)) / unsigned_v_t(~unsigned_v_t(0U))));
  }






  template <typename TValue>
  constexpr bool has_zero_byte(TValue value)
  {
    typedef typename etl::make_unsigned<TValue>::type unsigned_t;
    constexpr const unsigned_t mask = etl::binary_fill<unsigned_t, uint8_t>(0x7FU);
    const unsigned_t temp = unsigned_t(~((((unsigned_t(value) & mask) + mask) | unsigned_t(value)) | mask));

    return (temp != 0U);
  }





  template <typename TValue, TValue Value>
  constexpr bool has_zero_byte()
  {
    typedef typename etl::make_unsigned<TValue>::type unsigned_t;
    constexpr const unsigned_t mask = etl::binary_fill<unsigned_t, uint8_t>(0x7FU);
    const unsigned_t temp = unsigned_t(~((((unsigned_t(Value) & mask) + mask) | unsigned_t(Value)) | mask));

    return (temp != 0U);
  }





  template <typename TValue>
  constexpr bool has_byte_n(TValue value, uint8_t n)
  {
    return etl::has_zero_byte(TValue(value ^ etl::binary_fill<TValue, uint8_t>(n)));
  }





  template <typename TValue, TValue Value>
  constexpr bool has_byte_n(TValue value)
  {
    return etl::has_zero_byte(TValue(value ^ etl::binary_fill<TValue, uint8_t>(Value)));
  }
# 458 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/binary.h"
  template <typename T>
  constexpr T binary_merge(T first, T second, T mask)
  {
    return second ^ ((second ^ first) & mask);
  }







  template <typename T, T MASK>
  constexpr T binary_merge(T first, T second)
  {
    return second ^ ((second ^ first) & MASK);
  }





  template <typename T, T Value>
  struct reverse_bits_const;






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), T>::type
    reverse_bits(T value)
  {
    value = ((value & 0xAAU) >> 1U) | ((value & 0x55U) << 1U);
    value = ((value & 0xCCU) >> 2U) | ((value & 0x33U) << 2U);
    value = (value >> 4U) | ((value & 0x0FU) << 4U);

    return value;
  }


  template <uint8_t Value>
  struct reverse_bits_const<uint8_t, Value>
  {
  private:

    static constexpr uint8_t value1 = uint8_t(((Value & 0xAAU) >> 1U) | ((Value & 0x55U) << 1U));
    static constexpr uint8_t value2 = uint8_t(((value1 & 0xCCU) >> 2U) | ((value1 & 0x33U) << 2U));

  public:

    static constexpr uint8_t value = uint8_t((value2 >> 4U) | ((value2 & 0x0FU) << 4U));
  };

  template <uint8_t Value>
  constexpr uint8_t reverse_bits_const<uint8_t, Value>::value;


  template <int8_t Value>
  struct reverse_bits_const<int8_t, Value>
  {
  private:

    static constexpr int8_t value1 = int8_t(((Value & 0xAAU) >> 1U) | ((Value & 0x55U) << 1U));
    static constexpr int8_t value2 = int8_t(((value1 & 0xCCU) >> 2U) | ((value1 & 0x33U) << 2U));

  public:

    static constexpr int8_t value = int8_t((value2 >> 4U) | ((value2 & 0x0FU) << 4U));
  };

  template <int8_t Value>
  constexpr int8_t reverse_bits_const<int8_t, Value>::value;






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), T>::type
    reverse_bits(T value)
  {
    value = ((value & 0xAAAAU) >> 1U) | ((value & 0x5555U) << 1U);
    value = ((value & 0xCCCCU) >> 2U) | ((value & 0x3333U) << 2U);
    value = ((value & 0xF0F0U) >> 4U) | ((value & 0x0F0FU) << 4U);
    value = (value >> 8U) | ((value & 0xFFU) << 8U);

    return value;
  }


  template <uint16_t Value>
  struct reverse_bits_const<uint16_t, Value>
  {
  private:

    static constexpr uint16_t value1 = uint16_t(((Value & 0xAAAAU) >> 1U) | ((Value & 0x5555U) << 1U));
    static constexpr uint16_t value2 = uint16_t(((value1 & 0xCCCCU) >> 2U) | ((value1 & 0x3333U) << 2U));
    static constexpr uint16_t value3 = uint16_t(((value2 & 0xF0F0U) >> 4U) | ((value2 & 0x0F0FU) << 4U));

  public:

    static constexpr uint16_t value = uint16_t((value3 >> 8U) | ((value3 & 0xFFU) << 8U));
  };

  template <uint16_t Value>
  constexpr uint16_t reverse_bits_const<uint16_t, Value>::value;


  template <int16_t Value>
  struct reverse_bits_const<int16_t, Value>
  {
  private:

    static constexpr int16_t value1 = int16_t(((Value & 0xAAAAU) >> 1U) | ((Value & 0x5555U) << 1U));
    static constexpr int16_t value2 = int16_t(((value1 & 0xCCCCU) >> 2U) | ((value1 & 0x3333U) << 2U));
    static constexpr int16_t value3 = int16_t(((value2 & 0xF0F0U) >> 4U) | ((value2 & 0x0F0FU) << 4U));

  public:

    static constexpr int16_t value = int16_t((value3 >> 8U) | ((value3 & 0xFFU) << 8U));
  };

  template <int16_t Value>
  constexpr int16_t reverse_bits_const<int16_t, Value>::value;





  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), T>::type
    reverse_bits(T value)
  {
    value = ((value & 0xAAAAAAAAUL) >> 1U) | ((value & 0x55555555UL) << 1U);
    value = ((value & 0xCCCCCCCCUL) >> 2U) | ((value & 0x33333333UL) << 2U);
    value = ((value & 0xF0F0F0F0UL) >> 4U) | ((value & 0x0F0F0F0FUL) << 4U);
    value = ((value & 0xFF00FF00UL) >> 8U) | ((value & 0x00FF00FFUL) << 8U);
    value = (value >> 16U) | ((value & 0xFFFFU) << 16U);

    return value;
  }


  template <uint32_t Value>
  struct reverse_bits_const<uint32_t, Value>
  {
  private:

    static constexpr uint32_t value1 = uint32_t(((Value & 0xAAAAAAAAUL) >> 1U) | ((Value & 0x55555555UL) << 1U));
    static constexpr uint32_t value2 = uint32_t(((value1 & 0xCCCCCCCCUL) >> 2U) | ((value1 & 0x33333333UL) << 2U));
    static constexpr uint32_t value3 = uint32_t(((value2 & 0xF0F0F0F0UL) >> 4U) | ((value2 & 0x0F0F0F0FUL) << 4U));
    static constexpr uint32_t value4 = uint32_t(((value3 & 0xFF00FF00UL) >> 8U) | ((value3 & 0x00FF00FFUL) << 8U));

  public:

    static constexpr uint32_t value = uint32_t((value4 >> 16U) | ((value4 & 0xFFFFU) << 16U));
  };

  template <uint32_t Value>
  constexpr uint32_t reverse_bits_const<uint32_t, Value>::value;


  template <int32_t Value>
  struct reverse_bits_const<int32_t, Value>
  {
  private:

    static constexpr int32_t value1 = int32_t(((Value & 0xAAAAAAAAUL) >> 1U) | ((Value & 0x55555555UL) << 1U));
    static constexpr int32_t value2 = int32_t(((value1 & 0xCCCCCCCCUL) >> 2U) | ((value1 & 0x33333333UL) << 2U));
    static constexpr int32_t value3 = int32_t(((value2 & 0xF0F0F0F0UL) >> 4U) | ((value2 & 0x0F0F0F0FUL) << 4U));
    static constexpr int32_t value4 = int32_t(((value3 & 0xFF00FF00UL) >> 8U) | ((value3 & 0x00FF00FFUL) << 8U));

  public:

    static constexpr int32_t value = int32_t((value4 >> 16U) | ((value4 & 0xFFFFUL) << 16U));
  };

  template <int32_t Value>
  constexpr int32_t reverse_bits_const<int32_t, Value>::value;






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 64U), T>::type
    reverse_bits(T value)
  {
    value = ((value & 0xAAAAAAAAAAAAAAAAULL) >> 1U) | ((value & 0x5555555555555555ULL) << 1U);
    value = ((value & 0xCCCCCCCCCCCCCCCCULL) >> 2U) | ((value & 0x3333333333333333ULL) << 2U);
    value = ((value & 0xF0F0F0F0F0F0F0F0ULL) >> 4U) | ((value & 0x0F0F0F0F0F0F0F0FULL) << 4U);
    value = ((value & 0xFF00FF00FF00FF00ULL) >> 8U) | ((value & 0x00FF00FF00FF00FFULL) << 8U);
    value = ((value & 0xFFFF0000FFFF0000ULL) >> 16U) | ((value & 0x0000FFFF0000FFFFULL) << 16U);
    value = (value >> 32U) | ((value & 0xFFFFFFFFULL) << 32U);

    return value;
  }


  template <uint64_t Value>
  struct reverse_bits_const<uint64_t, Value>
  {
  private:

    static constexpr uint64_t value1 = uint64_t(((Value & 0xAAAAAAAAAAAAAAAAULL) >> 1U) | ((Value & 0x5555555555555555ULL) << 1U));
    static constexpr uint64_t value2 = uint64_t(((value1 & 0xCCCCCCCCCCCCCCCCULL) >> 2U) | ((value1 & 0x3333333333333333ULL) << 2U));
    static constexpr uint64_t value3 = uint64_t(((value2 & 0xF0F0F0F0F0F0F0F0ULL) >> 4U) | ((value2 & 0x0F0F0F0F0F0F0F0FULL) << 4U));
    static constexpr uint64_t value4 = uint64_t(((value3 & 0xFF00FF00FF00FF00ULL) >> 8U) | ((value3 & 0x00FF00FF00FF00FFULL) << 8U));
    static constexpr uint64_t value5 = uint64_t(((value4 & 0xFFFF0000FFFF0000ULL) >> 16U) | ((value4 & 0x0000FFFF0000FFFFULL) << 16U));

  public:

    static constexpr uint64_t value = uint64_t((value5 >> 32U) | ((value5 & 0xFFFFFFFFULL) << 32U));
  };

  template <uint64_t Value>
  constexpr uint64_t reverse_bits_const<uint64_t, Value>::value;


  template <int64_t Value>
  struct reverse_bits_const<int64_t, Value>
  {
  private:

    static constexpr int64_t value1 = int64_t(((Value & 0xAAAAAAAAAAAAAAAAULL) >> 1U) | ((Value & 0x5555555555555555ULL) << 1U));
    static constexpr int64_t value2 = int64_t(((value1 & 0xCCCCCCCCCCCCCCCCULL) >> 2U) | ((value1 & 0x3333333333333333ULL) << 2U));
    static constexpr int64_t value3 = int64_t(((value2 & 0xF0F0F0F0F0F0F0F0ULL) >> 4U) | ((value2 & 0x0F0F0F0F0F0F0F0FULL) << 4U));
    static constexpr int64_t value4 = int64_t(((value3 & 0xFF00FF00FF00FF00ULL) >> 8U) | ((value3 & 0x00FF00FF00FF00FFULL) << 8U));
    static constexpr int64_t value5 = int64_t(((value4 & 0xFFFF0000FFFF0000ULL) >> 16U) | ((value4 & 0x0000FFFF0000FFFFULL) << 16U));

  public:

    static constexpr int64_t value = int64_t((value5 >> 32U) | ((value5 & 0xFFFFFFFFULL) << 32U));
  };

  template <int64_t Value>
  constexpr int64_t reverse_bits_const<int64_t, Value>::value;






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_signed<T>::value, T>::type
    reverse_bits(T value)
  {
    typedef typename etl::make_unsigned<T>::type unsigned_t;

    return static_cast<T>(reverse_bits(static_cast<unsigned_t>(value)));
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), T>::type
    reverse_bytes(T value)
  {
    return value;
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), T>::type
    reverse_bytes(T value)
  {



    return (value >> 8U) | (value << 8U);

  }





  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), T>::type
    reverse_bytes(T value)
  {



    value = ((value & 0xFF00FF00UL) >> 8U) | ((value & 0x00FF00FFUL) << 8U);
    value = (value >> 16U) | (value << 16U);

    return value;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 64U), T>::type
    reverse_bytes(T value)
  {



    value = ((value & 0xFF00FF00FF00FF00ULL) >> 8U) | ((value & 0x00FF00FF00FF00FFULL) << 8U);
    value = ((value & 0xFFFF0000FFFF0000ULL) >> 16U) | ((value & 0x0000FFFF0000FFFFULL) << 16U);
    value = (value >> 32U) | (value << 32U);

    return value;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_signed<T>::value, T>::type
    reverse_bytes(T value)
  {
    typedef typename etl::make_unsigned<T>::type unsigned_t;

    return static_cast<T>(reverse_bytes(static_cast<unsigned_t>(value)));
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), T>::type
    gray_to_binary(T value)
  {
    value ^= (value >> 4U);
    value ^= (value >> 2U);
    value ^= (value >> 1U);

    return value;
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), T>::type
    gray_to_binary(T value)
  {
    value ^= (value >> 8U);
    value ^= (value >> 4U);
    value ^= (value >> 2U);
    value ^= (value >> 1U);

    return value;
  }





  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), T>::type
    gray_to_binary(T value)
  {
    value ^= (value >> 16U);
    value ^= (value >> 8U);
    value ^= (value >> 4U);
    value ^= (value >> 2U);
    value ^= (value >> 1U);

    return value;
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 64U), T>::type
    gray_to_binary(T value)
  {
    value ^= (value >> 32U);
    value ^= (value >> 16U);
    value ^= (value >> 8U);
    value ^= (value >> 4U);
    value ^= (value >> 2U);
    value ^= (value >> 1U);

    return value;
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_signed<T>::value, T>::type
    gray_to_binary(T value)
  {
    typedef typename etl::make_unsigned<T>::type unsigned_t;

    return static_cast<T>(gray_to_binary(static_cast<unsigned_t>(value)));
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), uint_least8_t>::type
    count_bits(T value)
  {



    uint32_t count = 0U;

    count = value - ((value >> 1U) & 0x55U);
    count = ((count >> 2U) & 0x33U) + (count & 0x33U);
    count = ((count >> 4U) + count) & 0x0FU;

    return uint_least8_t(count);

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), uint_least8_t>::type
    count_bits(T value)
  {



    uint32_t count = 0U;

    count = value - ((value >> 1U) & 0x5555U);
    count = ((count >> 2U) & 0x3333U) + (count & 0x3333U);
    count = ((count >> 4U) + count) & 0x0F0FU;
    count = ((count >> 8U) + count) & 0x00FFU;

    return static_cast<uint_least8_t>(count);

  }





  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), uint_least8_t>::type
    count_bits(T value)
  {



    uint32_t count = 0U;

    count = value - ((value >> 1U) & 0x55555555UL);
    count = ((count >> 2U) & 0x33333333UL) + (count & 0x33333333UL);
    count = ((count >> 4U) + count) & 0x0F0F0F0FUL;
    count = ((count >> 8U) + count) & 0x00FF00FFUL;
    count = ((count >> 16U) + count) & 0x0000FFUL;

    return static_cast<uint_least8_t>(count);

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 64U), uint_least8_t>::type
    count_bits(T value)
  {



    uint64_t count = 0U;

    count = value - ((value >> 1U) & 0x5555555555555555ULL);
    count = ((count >> 2U) & 0x3333333333333333ULL) + (count & 0x3333333333333333ULL);
    count = ((count >> 4U) + count) & 0x0F0F0F0F0F0F0F0FULL;
    count = ((count >> 8U) + count) & 0x00FF00FF00FF00FFULL;
    count = ((count >> 16U) + count) & 0x0000FFFF0000FFFFULL;
    count = ((count >> 32U) + count) & 0x00000000FFFFFFFFULL;

    return static_cast<uint_least8_t>(count);

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_signed<T>::value, uint_least8_t>::type
    count_bits(T value)
  {
    typedef typename etl::make_unsigned<T>::type unsigned_t;

    return static_cast<T>(count_bits(static_cast<unsigned_t>(value)));
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), uint_least8_t>::type
    parity(T value)
  {
    value ^= value >> 4U;
    value &= 0x0FU;
    return (0x6996U >> value) & 1U;
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), uint_least8_t>::type
    parity(T value)
  {
    value ^= value >> 8U;
    value ^= value >> 4U;
    value &= 0x0FU;
    return (0x6996U >> value) & 1U;
  }





  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), uint_least8_t>::type
    parity(T value)
  {
    value ^= value >> 16U;
    value ^= value >> 8U;
    value ^= value >> 4U;
    value &= 0x0FU;
    return (0x6996U >> value) & 1U;
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 64U), uint_least8_t>::type
    parity(T value)
  {
    value ^= value >> 32U;
    value ^= value >> 16U;
    value ^= value >> 8U;
    value ^= value >> 4U;
    value &= 0x0FU;
    return (0x69966996UL >> value) & 1U;
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_signed<T>::value, uint_least8_t>::type
    parity(T value)
  {
    typedef typename etl::make_unsigned<T>::type unsigned_t;

    return static_cast<T>(parity(static_cast<unsigned_t>(value)));
  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), uint_least8_t>::type
    count_trailing_zeros(T value)
  {



    uint_least8_t count = 0U;

    if (value & 0x1U)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFU) == 0U)
      {
        value >>= 4U;
        count += 4U;
      }

      if ((value & 0x3U) == 0U)
      {
        value >>= 2U;
        count += 2U;
      }

      if ((value & 0x1U) == 0U)
      {
        value >>= 1U;
        count += 1U;
      }

      count -= (value & 0x1U);
    }

    return count;

  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), uint_least8_t>::type
    count_trailing_zeros(T value)
  {



    uint_least8_t count = 0U;

    if (value & 0x1U)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFFU) == 0U)
      {
        value >>= 8U;
        count += 8U;
      }

      if ((value & 0xFU) == 0U)
      {
        value >>= 4U;
        count += 4U;
      }

      if ((value & 0x3U) == 0U)
      {
        value >>= 2U;
        count += 2U;
      }

      if ((value & 0x1U) == 0U)
      {
        value >>= 1U;
        count += 1U;
      }

      count -= value & 0x1U;
    }

    return count;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), uint_least8_t>::type
    count_trailing_zeros(T value)
  {



    uint_least8_t count = 0U;

    if (value & 0x1UL)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFFFFUL) == 0UL)
      {
        value >>= 16U;
        count += 16U;
      }

      if ((value & 0xFFUL) == 0UL)
      {
        value >>= 8U;
        count += 8U;
      }

      if ((value & 0xFUL) == 0UL)
      {
        value >>= 4U;
        count += 4U;
      }

      if ((value & 0x3UL) == 0UL)
      {
        value >>= 2U;
        count += 2U;
      }

      if ((value & 0x1U) == 0U)
      {
        value >>= 1U;
        count += 1U;
      }

      count -= value & 0x1UL;
    }

    return count;

  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 64U), uint_least8_t>::type
    count_trailing_zeros(T value)
  {



      uint_least8_t count = 0U;

      if (value & 0x1ULL)
      {
        count = 0U;
      }
      else
      {
        count = 1U;

        if ((value & 0xFFFFFFFFULL) == 0ULL)
        {
          value >>= 32U;
          count += 32U;
        }

        if ((value & 0xFFFFULL) == 0ULL)
        {
          value >>= 16U;
          count += 16U;
        }

        if ((value & 0xFFULL) == 0ULL)
        {
          value >>= 8U;
          count += 8U;
        }

        if ((value & 0xFULL) == 0ULL)
        {
          value >>= 4U;
          count += 4U;
        }

        if ((value & 0x3ULL) == 0ULL)
        {
          value >>= 2U;
          count += 2U;
        }

        if ((value & 0x1U) == 0U)
        {
          value >>= 1U;
          count += 1U;
        }

        count -= value & 0x1ULL;
      }

      return count;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_signed<T>::value, uint_least8_t>::type
    count_trailing_zeros(T value)
  {
    typedef typename etl::make_unsigned<T>::type unsigned_t;

    return static_cast<T>(count_trailing_zeros(static_cast<unsigned_t>(value)));
  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), uint_least8_t>::type
    count_trailing_ones(T value)
  {



    uint_least8_t count = 0U;

    if ((value & 0x1U) == 0x0U)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFU) == 0xFU)
      {
        value >>= 4U;
        count += 4U;
      }

      if ((value & 0x3U) == 0x3U)
      {
        value >>= 2U;
        count += 2U;
      }

      if ((value & 0x1U) == 0x1U)
      {
        value >>= 1U;
        count += 1U;
      }

      count -= ((value & 0x1U) == 0x0U);
    }

    return count;

  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), uint_least8_t>::type
    count_trailing_ones(T value)
  {



    uint_least8_t count = 0U;

    if ((value & 0x1U) == 0x0U)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFFU) == 0xFFU)
      {
        value >>= 8U;
        count += 8U;
      }

      if ((value & 0xFU) == 0xFU)
      {
        value >>= 4U;
        count += 4U;
      }

      if ((value & 0x3U) == 0x3U)
      {
        value >>= 2U;
        count += 2U;
      }

      if ((value & 0x1U) == 0x1U)
      {
        value >>= 1U;
        count += 1U;
      }

      count -= ((value & 0x1U) == 0x0U);
    }

    return count;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), uint_least8_t>::type
    count_trailing_ones(T value)
  {



    uint_least8_t count = 0U;

    if ((value & 0x1UL) == 0x0UL)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFFFFUL) == 0xFFFFUL)
      {
        value >>= 16U;
        count += 16U;
      }

      if ((value & 0xFFUL) == 0xFFUL)
      {
        value >>= 8U;
        count += 8U;
      }

      if ((value & 0xFUL) == 0xFUL)
      {
        value >>= 4U;
        count += 4U;
      }

      if ((value & 0x3UL) == 0x3UL)
      {
        value >>= 2U;
        count += 2U;
      }

      if ((value & 0x1UL) == 0x1UL)
      {
        value >>= 1U;
        count += 1U;
      }

      count -= ((value & 0x1UL) == 0x0UL);
    }

    return count;

  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 64U), uint_least8_t>::type
    count_trailing_ones(T value)
  {



    uint_least8_t count = 0U;

    if ((value & 0x1ULL) == 0x0ULL)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFFFFULL) == 0xFFFFULL)
      {
        value >>= 16U;
        count += 16U;
      }

      if ((value & 0xFFULL) == 0xFFULL)
      {
        value >>= 8U;
        count += 8U;
      }

      if ((value & 0xFULL) == 0xFULL)
      {
        value >>= 4U;
        count += 4U;
      }

      if ((value & 0x3ULL) == 0x3ULL)
      {
        value >>= 2U;
        count += 2U;
      }

      if ((value & 0x1ULL) == 0x1ULL)
      {
        value >>= 1U;
        count += 1U;
      }

      count -= ((value & 0x1ULL) == 0x0ULL);
    }

    return count;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value&& etl::is_signed<T>::value, uint_least8_t>::type
    count_trailing_ones(T value)
  {
    typedef typename etl::make_unsigned<T>::type unsigned_t;

    return static_cast<T>(count_trailing_ones(static_cast<unsigned_t>(value)));
  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), uint_least8_t>::type
    count_leading_zeros(T value)
  {



    uint_least8_t count = 0U;

    if (value & 0x80U)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xF0U) == 0U)
      {
        value <<= 4U;
        count += 4U;
      }

      if ((value & 0xC0U) == 0U)
      {
        value <<= 2U;
        count += 2U;
      }

      if ((value & 0x80U) == 0U)
      {
        value <<= 1U;
        count += 1U;
      }

      count -= ((value & 0x80U) == 0x80U);
    }

    return count;

  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), uint_least8_t>::type
    count_leading_zeros(T value)
  {



    uint_least8_t count = 0U;

    if (value & 0x8000U)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFF00U) == 0U)
      {
        value <<= 8U;
        count += 8U;
      }

      if ((value & 0xF000U) == 0U)
      {
        value <<= 4U;
        count += 4U;
      }

      if ((value & 0xC000U) == 0U)
      {
        value <<= 2U;
        count += 2U;
      }

      if ((value & 0x8000U) == 0U)
      {
        value <<= 1U;
        count += 1U;
      }

      count -= ((value & 0x8000U) == 0x8000U);
    }

    return count;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), uint_least8_t>::type
    count_leading_zeros(T value)
  {



    uint_least8_t count = 0U;

    if (value & 0x80000000UL)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFFFF0000UL) == 0U)
      {
        value <<= 16U;
        count += 16U;
      }

      if ((value & 0xFF000000UL) == 0U)
      {
        value <<= 8U;
        count += 8U;
      }

      if ((value & 0xF0000000UL) == 0U)
      {
        value <<= 4U;
        count += 4U;
      }

      if ((value & 0xC0000000UL) == 0U)
      {
        value <<= 2U;
        count += 2U;
      }

      if ((value & 0x80000000UL) == 0U)
      {
        value <<= 1U;
        count += 1U;
      }

      count -= ((value & 0x80000000UL) == 0x80000000UL);
    }

    return count;

  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 64U), uint_least8_t>::type
    count_leading_zeros(T value)
  {



    uint_least8_t count = 0U;

    if (value & 0x8000000000000000ULL)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFFFFFFFFF0000000ULL) == 0U)
      {
        value <<= 32U;
        count += 32U;
      }

      if ((value & 0xFFFF000000000000ULL) == 0U)
      {
        value <<= 16U;
        count += 16U;
      }

      if ((value & 0xFF00000000000000ULL) == 0U)
      {
        value <<= 8U;
        count += 8U;
      }

      if ((value & 0xF000000000000000ULL) == 0U)
      {
        value <<= 4U;
        count += 4U;
      }

      if ((value & 0xC000000000000000ULL) == 0U)
      {
        value <<= 2U;
        count += 2U;
      }

      if ((value & 0x8000000000000000ULL) == 0U)
      {
        value <<= 1U;
        count += 1U;
      }

      count -= ((value & 0x8000000000000000ULL) == 0x8000000000000000ULL);
    }

    return count;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_signed<T>::value, uint_least8_t>::type
    count_leading_zeros(T value)
  {
    typedef typename etl::make_unsigned<T>::type unsigned_t;

    return static_cast<T>(count_trailing_ones(static_cast<unsigned_t>(value)));
  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), uint_least8_t>::type
    count_leading_ones(T value)
  {



    uint_least8_t count = 0U;

    if ((value & 0x80U) == 0U)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xF0U) == 0xF0U)
      {
        value <<= 4U;
        count += 4U;
      }

      if ((value & 0xC0U) == 0xC0U)
      {
        value <<= 2U;
        count += 2U;
      }

      if ((value & 0x80U) == 0x80U)
      {
        value <<= 1U;
        count += 1U;
      }

      count -= ((value & 0x80U) == 0x0U);
    }

    return count;

  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), uint_least8_t>::type
    count_leading_ones(T value)
  {



    uint_least8_t count = 0U;

    if ((value & 0x8000U) == 0U)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFF00U) == 0xFF00U)
      {
        value <<= 8U;
        count += 8U;
      }

      if ((value & 0xF000U) == 0xF000U)
      {
        value <<= 4U;
        count += 4U;
      }

      if ((value & 0xC000U) == 0xC000U)
      {
        value <<= 2U;
        count += 2U;
      }

      if ((value & 0x8000U) == 0x8000U)
      {
        value <<= 1U;
        count += 1U;
      }

      count -= ((value & 0x8000U) == 0U);
    }

    return count;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), uint_least8_t>::type
    count_leading_ones(T value)
  {



    uint_least8_t count = 0U;

    if ((value & 0x80000000UL) == 0UL)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFFFF0000UL) == 0xFFFF0000UL)
      {
        value <<= 8U;
        count += 8U;
      }

      if ((value & 0xFF000000UL) == 0xFF000000UL)
      {
        value <<= 8U;
        count += 8U;
      }

      if ((value & 0xF0000000UL) == 0xF0000000UL)
      {
        value <<= 4U;
        count += 4U;
      }

      if ((value & 0xC0000000UL) == 0xC0000000UL)
      {
        value <<= 2U;
        count += 2U;
      }

      if ((value & 0x80000000UL) == 0x80000000UL)
      {
        value <<= 1U;
        count += 1U;
      }

      count -= ((value & 0x80000000UL) == 0UL);
    }

    return count;

  }







  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 64U), uint_least8_t>::type
    count_leading_ones(T value)
  {



    uint_least8_t count = 0U;

    if ((value & 0x8000000000000000ULL) == 0ULL)
    {
      count = 0U;
    }
    else
    {
      count = 1U;

      if ((value & 0xFFFFFFFF00000000ULL) == 0xFFFFFFFF00000000ULL)
      {
        value <<= 8U;
        count += 8U;
      }

      if ((value & 0xFFFF000000000000ULL) == 0xFFFF000000000000ULL)
      {
        value <<= 8U;
        count += 8U;
      }

      if ((value & 0xFF00000000000000ULL) == 0xFF00000000000000ULL)
      {
        value <<= 8U;
        count += 8U;
      }

      if ((value & 0xF000000000000000ULL) == 0xF000000000000000ULL)
      {
        value <<= 4U;
        count += 4U;
      }

      if ((value & 0xC000000000000000ULL) == 0xC000000000000000ULL)
      {
        value <<= 2U;
        count += 2U;
      }

      if ((value & 0x8000000000000000ULL) == 0x8000000000000000ULL)
      {
        value <<= 1U;
        count += 1U;
      }

      count -= ((value & 0x8000000000000000ULL) == 0ULL);
    }

    return count;

  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_signed<T>::value, uint_least8_t>::type
    count_leading_ones(T value)
  {
    typedef typename etl::make_unsigned<T>::type unsigned_t;

    return static_cast<T>(count_leading_ones(static_cast<unsigned_t>(value)));
  }






  template <typename T>
  constexpr uint_least8_t first_set_bit_position(T value)
  {
    return count_trailing_zeros(value);
  }






  template <typename T>
  constexpr uint_least8_t first_clear_bit_position(T value)
  {
    value = ~value;
    return count_trailing_zeros(value);
  }






  template <typename T>
  constexpr uint_least8_t first_bit_position(bool state, T value)
  {
    if (!state)
    {
      value = ~value;
    }

    return count_trailing_zeros(value);
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value&& etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 8U), uint16_t>::type
    binary_interleave(T first, T second)
  {
   uint16_t f = uint16_t(first);
   uint16_t s = uint16_t(second);

   f = (f | (f << 4U)) & 0x0F0FU;
   f = (f | (f << 2U)) & 0x3333U;
   f = (f | (f << 1U)) & 0x5555U;

   s = (s | (s << 4U)) & 0x0F0FU;
   s = (s | (s << 2U)) & 0x3333U;
   s = (s | (s << 1U)) & 0x5555U;

   return (f | (s << 1U));
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 16U), uint32_t>::type
    binary_interleave(T first, T second)
  {
   uint32_t f = uint32_t(first);
   uint32_t s = uint32_t(second);

   f = (f | (f << 8U)) & 0x00FF00FFUL;
   f = (f | (f << 4U)) & 0x0F0F0F0FUL;
   f = (f | (f << 2U)) & 0x33333333UL;
   f = (f | (f << 1U)) & 0x55555555UL;

   s = (s | (s << 8U)) & 0x00FF00FFUL;
   s = (s | (s << 4U)) & 0x0F0F0F0FUL;
   s = (s | (s << 2U)) & 0x33333333UL;
   s = (s | (s << 1U)) & 0x55555555UL;

   return (f | (s << 1U));
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_unsigned<T>::value && (etl::integral_limits<T>::bits == 32U), uint64_t>::type
    binary_interleave(T first, T second)
  {
   uint64_t f = uint64_t(first);
   uint64_t s = uint64_t(second);

   f = (f | (f << 16U)) & 0x0000FFFF0000FFFFULL;
   f = (f | (f << 8U)) & 0x00FF00FF00FF00FFULL;
   f = (f | (f << 4U)) & 0x0F0F0F0F0F0F0F0FULL;
   f = (f | (f << 2U)) & 0x3333333333333333ULL;
   f = (f | (f << 1U)) & 0x5555555555555555ULL;

   s = (s | (s << 16U)) & 0x0000FFFF0000FFFFULL;
   s = (s | (s << 8U)) & 0x00FF00FF00FF00FFULL;
   s = (s | (s << 4U)) & 0x0F0F0F0F0F0F0F0FULL;
   s = (s | (s << 2U)) & 0x3333333333333333ULL;
   s = (s | (s << 1U)) & 0x5555555555555555ULL;

   return (f | (s << 1U));
  }






  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_integral<T>::value && etl::is_signed<T>::value, T>::type
    binary_interleave(T first, T second)
  {
    return int64_t(binary_interleave(uint16_t(first), uint16_t(second)));
  }





  template <typename T>
  constexpr typename etl::enable_if<etl::is_integral<T>::value, bool>::type
   is_odd(T value)
  {
   return ((static_cast<typename etl::make_unsigned<T>::type>(value) & 1U) != 0U);
  }





  template <typename T>
  constexpr typename etl::enable_if<etl::is_integral<T>::value, bool>::type
    is_even(T value)
  {
    return ((static_cast<typename etl::make_unsigned<T>::type>(value) & 1U) == 0U);
  }


  template <typename T, size_t NBits>
  class lsb_mask
  {
  public:

    static_assert(NBits <= etl::integral_limits<T>::bits, "Mask exceeds type size");

    static constexpr T value = static_cast<T>(etl::max_value_for_nbits<NBits>::value);
  };

  template <typename T, size_t NBits>
  constexpr T lsb_mask<T, NBits>::value;


  template <typename T, size_t NBits>
  constexpr T make_lsb_mask()
  {
    static_assert(NBits <= etl::integral_limits<T>::bits, "Mask exceeds type size");

    return lsb_mask<T, NBits>::value;
  }


  template <typename T>
  constexpr T make_lsb_mask(size_t nbits)
  {
    typedef typename etl::make_unsigned<T>::type type;

    return (nbits == 0U) ? static_cast<T>(0)
      : static_cast<T>(static_cast<type>(~0) >> (etl::integral_limits<type>::bits - nbits));
  }


  template <typename T, size_t NBits>
  class msb_mask
  {
  public:

    static_assert(NBits <= etl::integral_limits<T>::bits, "Mask exceeds type size");

    static constexpr T value = static_cast<T>(etl::reverse_bits_const<T, lsb_mask<T, NBits>::value>::value);
  };

  template <typename T, size_t NBits>
  constexpr T msb_mask<T, NBits>::value;


  template <typename T>
  constexpr T make_msb_mask(size_t nbits)
  {
    typedef typename etl::make_unsigned<T>::type type;

    return (nbits == 0U) ? static_cast<T>(0)
                         : static_cast<T>(static_cast<type>(~0) << (etl::integral_limits<type>::bits - nbits));
  }


  template <typename T, size_t NBits>
  constexpr T make_msb_mask()
  {
    static_assert(NBits <= etl::integral_limits<T>::bits, "Mask exceeds type size");

    return msb_mask<T, NBits>::value;
  }





  template <typename T>
  struct binary_not : public etl::unary_function<T, T>
  {

    [[nodiscard]]
    constexpr
    T operator ()(T value) const
    {
      static_assert(etl::is_integral<T>::value, "Not an integral type");

      return ~value;
    }
  };





  template <typename T>
  struct binary_and : public etl::unary_function<T, T>
  {

    constexpr
    explicit binary_and(T parameter_)
      : parameter(parameter_)
    {
    }


    [[nodiscard]]
    constexpr
    T operator ()(T value) const
    {
      static_assert(etl::is_integral<T>::value, "Not an integral type");

      return value & parameter;
    }

  private:

    T parameter;
  };





  template <typename T>
  struct binary_or : public etl::unary_function<T, T>
  {

    constexpr
    explicit binary_or(T parameter_)
      : parameter(parameter_)
    {
    }


    [[nodiscard]]
    constexpr
    T operator ()(T value) const
    {
      static_assert(etl::is_integral<T>::value, "Not an integral type");

      return value | parameter;
    }

  private:

    T parameter;
  };





  template <typename T>
  struct binary_xor : public etl::unary_function<T, T>
  {

    constexpr
    explicit binary_xor(T parameter_)
      : parameter(parameter_)
    {
    }


    [[nodiscard]]
    constexpr
    T operator ()(T value) const
    {
      static_assert(etl::is_integral<T>::value, "Not an integral type");

      return value ^ parameter;
    }

  private:

    T parameter;
  };





  enum binary_constant
  {
    b00000000 = 0U,
    b00000001 = 1U,
    b00000010 = 2U,
    b00000011 = 3U,
    b00000100 = 4U,
    b00000101 = 5U,
    b00000110 = 6U,
    b00000111 = 7U,
    b00001000 = 8U,
    b00001001 = 9U,
    b00001010 = 10U,
    b00001011 = 11U,
    b00001100 = 12U,
    b00001101 = 13U,
    b00001110 = 14U,
    b00001111 = 15U,
    b00010000 = 16U,
    b00010001 = 17U,
    b00010010 = 18U,
    b00010011 = 19U,
    b00010100 = 20U,
    b00010101 = 21U,
    b00010110 = 22U,
    b00010111 = 23U,
    b00011000 = 24U,
    b00011001 = 25U,
    b00011010 = 26U,
    b00011011 = 27U,
    b00011100 = 28U,
    b00011101 = 29U,
    b00011110 = 30U,
    b00011111 = 31U,
    b00100000 = 32U,
    b00100001 = 33U,
    b00100010 = 34U,
    b00100011 = 35U,
    b00100100 = 36U,
    b00100101 = 37U,
    b00100110 = 38U,
    b00100111 = 39U,
    b00101000 = 40U,
    b00101001 = 41U,
    b00101010 = 42U,
    b00101011 = 43U,
    b00101100 = 44U,
    b00101101 = 45U,
    b00101110 = 46U,
    b00101111 = 47U,
    b00110000 = 48U,
    b00110001 = 49U,
    b00110010 = 50U,
    b00110011 = 51U,
    b00110100 = 52U,
    b00110101 = 53U,
    b00110110 = 54U,
    b00110111 = 55U,
    b00111000 = 56U,
    b00111001 = 57U,
    b00111010 = 58U,
    b00111011 = 59U,
    b00111100 = 60U,
    b00111101 = 61U,
    b00111110 = 62U,
    b00111111 = 63U,
    b01000000 = 64U,
    b01000001 = 65U,
    b01000010 = 66U,
    b01000011 = 67U,
    b01000100 = 68U,
    b01000101 = 69U,
    b01000110 = 70U,
    b01000111 = 71U,
    b01001000 = 72U,
    b01001001 = 73U,
    b01001010 = 74U,
    b01001011 = 75U,
    b01001100 = 76U,
    b01001101 = 77U,
    b01001110 = 78U,
    b01001111 = 79U,
    b01010000 = 80U,
    b01010001 = 81U,
    b01010010 = 82U,
    b01010011 = 83U,
    b01010100 = 84U,
    b01010101 = 85U,
    b01010110 = 86U,
    b01010111 = 87U,
    b01011000 = 88U,
    b01011001 = 89U,
    b01011010 = 90U,
    b01011011 = 91U,
    b01011100 = 92U,
    b01011101 = 93U,
    b01011110 = 94U,
    b01011111 = 95U,
    b01100000 = 96U,
    b01100001 = 97U,
    b01100010 = 98U,
    b01100011 = 99U,
    b01100100 = 100U,
    b01100101 = 101U,
    b01100110 = 102U,
    b01100111 = 103U,
    b01101000 = 104U,
    b01101001 = 105U,
    b01101010 = 106U,
    b01101011 = 107U,
    b01101100 = 108U,
    b01101101 = 109U,
    b01101110 = 110U,
    b01101111 = 111U,
    b01110000 = 112U,
    b01110001 = 113U,
    b01110010 = 114U,
    b01110011 = 115U,
    b01110100 = 116U,
    b01110101 = 117U,
    b01110110 = 118U,
    b01110111 = 119U,
    b01111000 = 120U,
    b01111001 = 121U,
    b01111010 = 122U,
    b01111011 = 123U,
    b01111100 = 124U,
    b01111101 = 125U,
    b01111110 = 126U,
    b01111111 = 127U,
    b10000000 = 128U,
    b10000001 = 129U,
    b10000010 = 130U,
    b10000011 = 131U,
    b10000100 = 132U,
    b10000101 = 133U,
    b10000110 = 134U,
    b10000111 = 135U,
    b10001000 = 136U,
    b10001001 = 137U,
    b10001010 = 138U,
    b10001011 = 139U,
    b10001100 = 140U,
    b10001101 = 141U,
    b10001110 = 142U,
    b10001111 = 143U,
    b10010000 = 144U,
    b10010001 = 145U,
    b10010010 = 146U,
    b10010011 = 147U,
    b10010100 = 148U,
    b10010101 = 149U,
    b10010110 = 150U,
    b10010111 = 151U,
    b10011000 = 152U,
    b10011001 = 153U,
    b10011010 = 154U,
    b10011011 = 155U,
    b10011100 = 156U,
    b10011101 = 157U,
    b10011110 = 158U,
    b10011111 = 159U,
    b10100000 = 160U,
    b10100001 = 161U,
    b10100010 = 162U,
    b10100011 = 163U,
    b10100100 = 164U,
    b10100101 = 165U,
    b10100110 = 166U,
    b10100111 = 167U,
    b10101000 = 168U,
    b10101001 = 169U,
    b10101010 = 170U,
    b10101011 = 171U,
    b10101100 = 172U,
    b10101101 = 173U,
    b10101110 = 174U,
    b10101111 = 175U,
    b10110000 = 176U,
    b10110001 = 177U,
    b10110010 = 178U,
    b10110011 = 179U,
    b10110100 = 180U,
    b10110101 = 181U,
    b10110110 = 182U,
    b10110111 = 183U,
    b10111000 = 184U,
    b10111001 = 185U,
    b10111010 = 186U,
    b10111011 = 187U,
    b10111100 = 188U,
    b10111101 = 189U,
    b10111110 = 190U,
    b10111111 = 191U,
    b11000000 = 192U,
    b11000001 = 193U,
    b11000010 = 194U,
    b11000011 = 195U,
    b11000100 = 196U,
    b11000101 = 197U,
    b11000110 = 198U,
    b11000111 = 199U,
    b11001000 = 200U,
    b11001001 = 201U,
    b11001010 = 202U,
    b11001011 = 203U,
    b11001100 = 204U,
    b11001101 = 205U,
    b11001110 = 206U,
    b11001111 = 207U,
    b11010000 = 208U,
    b11010001 = 209U,
    b11010010 = 210U,
    b11010011 = 211U,
    b11010100 = 212U,
    b11010101 = 213U,
    b11010110 = 214U,
    b11010111 = 215U,
    b11011000 = 216U,
    b11011001 = 217U,
    b11011010 = 218U,
    b11011011 = 219U,
    b11011100 = 220U,
    b11011101 = 221U,
    b11011110 = 222U,
    b11011111 = 223U,
    b11100000 = 224U,
    b11100001 = 225U,
    b11100010 = 226U,
    b11100011 = 227U,
    b11100100 = 228U,
    b11100101 = 229U,
    b11100110 = 230U,
    b11100111 = 231U,
    b11101000 = 232U,
    b11101001 = 233U,
    b11101010 = 234U,
    b11101011 = 235U,
    b11101100 = 236U,
    b11101101 = 237U,
    b11101110 = 238U,
    b11101111 = 239U,
    b11110000 = 240U,
    b11110001 = 241U,
    b11110010 = 242U,
    b11110011 = 243U,
    b11110100 = 244U,
    b11110101 = 245U,
    b11110110 = 246U,
    b11110111 = 247U,
    b11111000 = 248U,
    b11111001 = 249U,
    b11111010 = 250U,
    b11111011 = 251U,
    b11111100 = 252U,
    b11111101 = 253U,
    b11111110 = 254U,
    b11111111 = 255U
  };





  enum bit_constant
  {
    b0 = 0x1UL,
    b1 = 0x2UL,
    b2 = 0x4UL,
    b3 = 0x8UL,
    b4 = 0x10UL,
    b5 = 0x20UL,
    b6 = 0x40UL,
    b7 = 0x80UL,
    b8 = 0x100UL,
    b9 = 0x200UL,
    b10 = 0x400UL,
    b11 = 0x800UL,
    b12 = 0x1000UL,
    b13 = 0x2000UL,
    b14 = 0x4000UL,
    b15 = 0x8000UL,
    b16 = 0x10000UL,
    b17 = 0x20000UL,
    b18 = 0x40000UL,
    b19 = 0x80000UL,
    b20 = 0x100000UL,
    b21 = 0x200000UL,
    b22 = 0x400000UL,
    b23 = 0x800000UL,
    b24 = 0x1000000UL,
    b25 = 0x2000000UL,
    b26 = 0x4000000UL,
    b27 = 0x8000000UL,
    b28 = 0x10000000UL,
    b29 = 0x20000000UL,
    b30 = 0x40000000UL,
    b31 = 0x80000000UL
  };
}
# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/flags.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/flags.h"
#define ETL_FLAGS_INCLUDED 



# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/flags.h" 2





# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 43 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/flags.h" 2


namespace etl
{




  template <typename T, T MASK = etl::integral_limits<T>::max>
  class flags
  {
  public:

    static_assert(etl::is_integral<T>::value && etl::is_unsigned<T>::value, "Unsigned integral values only");

    typedef T value_type;

    static constexpr value_type ALL_SET = etl::integral_limits<value_type>::max & MASK;
    static constexpr value_type ALL_CLEAR = 0;

    static constexpr size_t NBITS = etl::integral_limits<value_type>::bits;




    constexpr flags()
      : data(value_type(0))
    {
    }

    constexpr flags(value_type pattern)
      : data(pattern & MASK)
    {
    }

    constexpr flags(const flags<T, MASK>& pattern)
      : data(pattern.value())
    {
    }




    template <value_type pattern>
    constexpr bool test() const
    {
      return (data & pattern) != value_type(0);
    }


    constexpr bool test(value_type pattern) const
    {
      return (data & pattern) != value_type(0);
    }




    template <value_type pattern, bool value>
    constexpr flags<T, MASK>& set()
    {
      value ? data |= (pattern & MASK) : data &= (~pattern & MASK);

      return *this;
    }


    template <value_type pattern>
    constexpr flags<T, MASK>& set(bool value)
    {
      value ? data |= (pattern & MASK) : data &= (~pattern & MASK);

      return *this;
    }


    template <value_type pattern>
    constexpr flags<T, MASK>& set()
    {
      data |= (pattern & MASK);

      return *this;
    }


    constexpr flags<T, MASK>& set(value_type pattern)
    {
      data |= (pattern & MASK);

      return *this;
    }


    constexpr flags<T, MASK>& set(value_type pattern, bool value)
    {
      value ? data |= (pattern & MASK) : data &= (~pattern & MASK);

      return *this;
    }




    constexpr flags<T, MASK>& clear()
    {
      data = ALL_CLEAR;

      return *this;
    }




    template <value_type pattern>
    constexpr flags<T, MASK>& reset()
    {
      data &= ~pattern;

      return *this;
    }


    constexpr flags<T, MASK>& reset(value_type pattern)
    {
      data &= ~pattern;

      return *this;
    }




    constexpr flags<T, MASK>& flip()
    {
      data = (~data & MASK);

      return *this;
    }


    template <value_type pattern>
    constexpr flags<T, MASK>& flip()
    {
      data ^= pattern & MASK;

      return *this;
    }


    constexpr flags<T, MASK>& flip(value_type pattern)
    {
      data ^= pattern & MASK;

      return *this;
    }




    constexpr bool all() const
    {
      return data == MASK;
    }


    template <value_type pattern>
    constexpr bool all_of() const
    {
      return (data & (pattern & MASK)) == (pattern & MASK);
    }


    constexpr bool all_of(value_type pattern) const
    {
      return (data & (pattern & MASK)) == (pattern & MASK);
    }




    constexpr bool none() const
    {
      return (data & MASK) == ALL_CLEAR;
    }


    template <value_type pattern>
    constexpr bool none_of() const
    {
      return !any_of(pattern);
    }


    constexpr bool none_of(value_type pattern) const
    {
      return !any_of(pattern);
    }




    constexpr bool any() const
    {
      return (data & MASK) != value_type(0);
    }


    template <value_type pattern>
    constexpr bool any_of() const
    {
      return (data & (pattern & MASK)) != value_type(0);
    }


    constexpr bool any_of(value_type pattern) const
    {
      return (data & (pattern & MASK)) != value_type(0);
    }




    constexpr value_type value() const
    {
      return data;
    }




    constexpr flags<T, MASK>& value(value_type pattern)
    {
      data = pattern & MASK;

      return *this;
    }




    constexpr operator value_type() const
    {
      return data;
    }




    constexpr flags<T, MASK>& operator &=(value_type pattern)
    {
      data &= pattern;

      return *this;
    }




    constexpr flags<T, MASK>& operator |=(value_type pattern)
    {
      data |= (pattern & MASK);

      return *this;
    }




    constexpr flags<T, MASK>& operator ^=(value_type pattern)
    {
      data ^= (pattern & MASK);

      return *this;
    }




    constexpr flags<T, MASK>& operator =(flags<T, MASK> other)
    {
      data = other.data;

      return *this;
    }




    constexpr flags<T, MASK>& operator =(value_type pattern)
    {
      data = (pattern & MASK);

      return *this;
    }




    void swap(flags<T, MASK>& other)
    {
      using etl::swap;
      swap(data, other.data);
    }

  private:

    value_type data;
  };

  template <typename T, T MASK>
  constexpr typename flags<T, MASK>::value_type flags<T, MASK>::ALL_SET;

  template <typename T, T MASK>
  constexpr typename flags<T, MASK>::value_type flags<T, MASK>::ALL_CLEAR;

  template <typename T, T MASK>
  constexpr size_t flags<T, MASK>::NBITS;




  template <typename T, T MASK>
  constexpr bool operator == (flags<T, MASK> lhs, flags<T, MASK> rhs)
  {
    return lhs.value() == rhs.value();
  }




  template <typename T, T MASK>
  constexpr bool operator != (flags<T, MASK> lhs, flags<T, MASK> rhs)
  {
    return !(lhs == rhs);
  }




  template <typename T, T MASK>
  void swap(etl::flags<T, MASK>& lhs, etl::flags<T, MASK>& rhs)
  {
    lhs.swap(rhs);
  }
}
# 47 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h"
#define ETL_STRING_UTILITIES_INCLUDED 



# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/enum_type.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/enum_type.h"
#define ETL_ENUM_TYPE_INCLUDED 
# 85 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/enum_type.h"
#define ETL_DECLARE_ENUM_TYPE(TypeName,ValueType) typedef ValueType value_type; ETL_CONSTEXPR TypeName() : value(static_cast<enum_type>(value_type())) {} ETL_CONSTEXPR TypeName(enum_type value_) : value(value_) {} ETL_CONSTEXPR explicit TypeName(value_type value_) : value(static_cast<enum_type>(value_)) {} ETL_CONSTEXPR operator value_type() const {return static_cast<value_type>(value);} ETL_CONSTEXPR value_type get_value() const {return static_cast<value_type>(value);} ETL_CONSTEXPR enum_type get_enum() const {return value;} ETL_CONSTEXPR14 const char* c_str() const { switch (value) {
# 101 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/enum_type.h"
#define ETL_ENUM_TYPE(value,name) case value: return name;






#define ETL_END_ENUM_TYPE default: return "?"; } } private: enum_type value;
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/char_traits.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/char_traits.h"
#define ETL_CHAR_TRAITS_INCLUDED 
# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/char_traits.h"
namespace etl
{
  template<typename T> struct char_traits_types;

  template<> struct char_traits_types<char>
  {
    typedef char char_type;
    typedef int int_type;
    typedef long long off_type;
    typedef size_t pos_type;
    typedef char state_type;
  };

  template<> struct char_traits_types<signed char>
  {
    typedef signed char char_type;
    typedef int int_type;
    typedef long long off_type;
    typedef size_t pos_type;
    typedef signed char state_type;
  };

  template<> struct char_traits_types<unsigned char>
  {
    typedef unsigned char char_type;
    typedef int int_type;
    typedef long long off_type;
    typedef size_t pos_type;
    typedef unsigned char state_type;
  };

  template<> struct char_traits_types<wchar_t>
  {
    typedef wchar_t char_type;
    typedef uint_least16_t int_type;
    typedef long long off_type;
    typedef size_t pos_type;
    typedef char state_type;
  };


  template<> struct char_traits_types<char8_t>
  {
    typedef char8_t char_type;
    typedef unsigned int int_type;
    typedef long long off_type;
    typedef size_t pos_type;
    typedef char state_type;
  };


  template<> struct char_traits_types<char16_t>
  {
    typedef char16_t char_type;
    typedef uint_least16_t int_type;
    typedef long long off_type;
    typedef size_t pos_type;
    typedef char state_type;
  };

  template<> struct char_traits_types<char32_t>
  {
    typedef char32_t char_type;
    typedef uint_least32_t int_type;
    typedef long long off_type;
    typedef size_t pos_type;
    typedef char state_type;
  };




  template<typename T>
  struct char_traits : public char_traits_types<T>
  {
    typedef typename char_traits_types<T>::char_type char_type;
    typedef typename char_traits_types<T>::int_type int_type;
    typedef typename char_traits_types<T>::off_type off_type;
    typedef typename char_traits_types<T>::pos_type pos_type;
    typedef typename char_traits_types<T>::state_type state_type;


    static constexpr bool eq(char_type a, char_type b)
    {
      return a == b;
    }


    static constexpr bool lt(char_type a, char_type b)
    {
      return a < b;
    }


    static constexpr size_t length(const char_type* begin)
    {
      if (begin == nullptr)
      {
        return 0;
      }

      const char_type* end = begin;

      while (*end++ != 0)
      {

      }

      return size_t(end - begin) - 1;
    }


    static constexpr size_t length(const char_type* str, size_t max_length)
    {
      size_t count = 0UL;

      if (str != 0)
      {
        while ((count < max_length) && (*str++ != 0))
        {
          ++count;
        }
      }

      return count;
    }


    static constexpr void assign(char_type& r, const char_type& c)
    {
      r = c;
    }


    static constexpr char_type* assign(char_type* p, size_t n, char_type c)
    {
      if (p != nullptr)
      {
        etl::fill_n(p, n, c);
      }

      return p;
    }


    static constexpr char_type* move(char_type* dst, const char_type* src, size_t count)
    {
      if ((dst < src) || (dst > (src + count)))
      {
        etl::copy_n(src, count, dst);
      }
      else
      {
        etl::copy_n(etl::reverse_iterator<const char_type*>(src + count),
                    count,
                    etl::reverse_iterator<char_type*>(dst + count));
      }

      return dst;
    }


    static constexpr char_type* copy(char_type* dst, const char_type* src, size_t count)
    {
      etl::copy_n(src, count, dst);

      return dst;
    }


    static constexpr int compare(const char_type* s1, const char_type* s2, size_t count)
    {
      for (size_t i = 0UL; i < count; ++i)
      {
        const char_type c1 = *s1++;
        const char_type c2 = *s2++;

        if (c1 < c2)
        {
          return -1;
        }
        else if (c1 > c2)
        {
          return 1;
        }
      }

      return 0;
    }


    static constexpr const char_type* find(const char_type* p, size_t count, const char_type& ch)
    {
      for (size_t i = 0UL; i < count; ++i)
      {
        if (*p == ch)
        {
          return p;
        }

        ++p;
      }

      return 0;
    }


    static constexpr char_type to_char_type(int_type c)
    {
      return static_cast<char_type>(c);
    }


    static constexpr int_type to_int_type(char_type c)
    {
      return static_cast<int_type>(c);
    }


    static constexpr bool eq_int_type(int_type c1, int_type c2)
    {
      return (c1 == c2);
    }


    static constexpr int_type eof()
    {
      return -1;
    }


    static constexpr int_type not_eof(int_type e)
    {
      return (e == eof()) ? eof() - 1 : e;
    }
  };




  template <typename T>
  constexpr size_t strlen(const T* t)
  {
    return etl::char_traits<T>::length(t);
  }




  template <typename T>
  constexpr size_t strlen(const T* t, size_t max_length)
  {
    return etl::char_traits<T>::length(t, max_length);
  }




  template <typename T>
  constexpr int strcmp(const T* t1, const T* t2)
  {
    while ((*t1 != 0) || (*t2 != 0))
    {
      if (*t1 > *t2)
      {
        return 1;
      }

      if (*t1 < *t2)
      {
        return -1;
      }

      ++t1;
      ++t2;
    }

    return 0;
  }




  template <typename T>
  constexpr int strncmp(const T* t1, const T* t2, size_t n)
  {
    while (((*t1 != 0) || (*t2 != 0)) && (n != 0))
    {
      if (*t1 < *t2)
      {
        return -1;
      }
      else if (*t1 > *t2)
      {
        return 1;
      }

      ++t1;
      ++t2;
      --n;
    }

    return 0;
  }




  template <typename T>
  constexpr T* strcpy(T* dst, const T* src)
  {
    T* result = dst;

    while (*src != 0)
    {
      *dst++ = *src++;
    }

    *dst = 0;

    return result;
  }




  template <typename T>
  constexpr T* strncpy(T* dst, const T* src, size_t n)
  {
    T* result = dst;

    while ((*src != 0) && (n != 0))
    {
      *dst++ = *src++;
      --n;
    }

    *dst = 0;

    return result;
  }
}
# 39 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
#define ETL_OPTIONAL_INCLUDED 




# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 2





namespace etl
{



  template <typename T>
  class optional;





  class nullopt_t
  {
  public:


    template<class T>
    operator T*() const
    {
      return 0;
    }

  private:


    void operator&() const = delete;
  };





  const nullopt_t nullopt = {};





  class optional_exception : public exception
  {
  public:

    optional_exception(string_type reason_, string_type file_name_, numeric_type line_number_)
      : exception(reason_, file_name_, line_number_)
    {
    }
  };





  class optional_invalid : public optional_exception
  {
  public:

    optional_invalid(string_type file_name_, numeric_type line_number_)
      : optional_exception("optional:invalid", file_name_, line_number_)
    {
    }
  };




  namespace private_optional
  {
    template <typename T, bool UseFundamentalPath = etl::is_fundamental<T>::value && !etl::is_const<T>::value>
    class optional_impl;




    template <typename T>
    class optional_impl<T, false>
    {
    protected:

      typedef T value_type;
      typedef optional_impl<T, false> this_type;




     
      optional_impl()
        : storage()
      {
      }




     
      optional_impl(etl::nullopt_t)
        : storage()
      {
      }

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_uninitialized_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_uninitialized_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
# 144 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 2



     
      optional_impl(const optional_impl<T>& other)
      {
        if (other.has_value())
        {
          storage.construct(other.value());
        }
      }
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 156 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 2





     
      optional_impl(optional_impl<T>&& other)
      {
        if (other.has_value())
        {
          storage.construct(etl::move(other.value()));
        }
      }




     
      optional_impl(const T& value_)
      {
        storage.construct(value_);
      }




     
      optional_impl(T&& value_)
      {
        storage.construct(etl::move(value_));
      }




      template <typename... TArgs>
     
        optional_impl(etl::in_place_t, TArgs&&... args)
      {
        storage.construct(etl::forward<TArgs>(args)...);
      }





      template <typename U, typename... TArgs >
      optional_impl(etl::in_place_t,
                                        std::initializer_list<U> ilist,
                                        TArgs&&... args)
      {
        storage.construct(ilist, etl::forward<TArgs>(args)...);
      }






     
      ~optional_impl()
      {
        storage.destroy();
      }




     
      optional_impl& operator =(etl::nullopt_t)
      {
        if (has_value())
        {
          storage.destroy();
        }

        return *this;
      }




     
      optional_impl& operator =(const optional_impl<T>& other)
      {
        if (this != &other)
        {
          if (other.has_value())
          {
            storage.construct(other.value());
          }
          else
          {
            storage.destroy();
          }
        }

        return *this;
      }





     
      optional_impl& operator =(optional_impl&& other)
      {
        if (this != &other)
        {
          if (other.has_value())
          {
            storage.construct(etl::move(other.value()));
          }
          else
          {
            storage.destroy();
          }
        }

        return *this;
      }





     
      optional_impl& operator =(const T& value_)
      {
        storage.construct(value_);

        return *this;
      }





     
      optional_impl& operator =(T&& value_)
      {
        storage.construct(etl::move(value_));

        return *this;
      }


  public:




     
      T* operator ->()
      {




        return &storage.u.value;
      }




     
      const T* operator ->() const
      {




        return &storage.u.value;
      }




     
      T& operator *() &
      {




        return storage.u.value;
      }




     
      const T& operator *() const &
      {




        return storage.u.value;
      }





     
      T&& operator *()&&
      {




        return etl::move(storage.u.value);
      }




     
      const T&& operator *() const&&
      {




        return etl::move(storage.u.value);
      }





     
      bool has_value() const
      {
        return storage.valid;
      }




     
      explicit operator bool() const
      {
        return has_value();
      }




     
      T& value() &
      {




        return storage.u.value;
      }




     
      const T& value() const &
      {




        return storage.u.value;
      }




     
      T value_or(const T& default_value) const &
      {
        return has_value() ? value() : default_value;
      }





     
      T&& value()&&
      {




        return etl::move(storage.u.value);
      }




     
      const T&& value() const&&
      {




        return etl::move(storage.u.value);
      }




      template <typename U>
     
      etl::enable_if_t<etl::is_convertible<U, T>::value, T>
        value_or(U&& default_value) const&
      {
        return has_value() ? value() : etl::forward<T>(default_value);
      }




      template <typename U>
     
      etl::enable_if_t<etl::is_convertible<U, T>::value, T>
        value_or(U&& default_value)&&
      {
        return has_value() ? etl::move(value()) : etl::forward<T>(default_value);
      }





     
      void swap(optional_impl& other)
      {
        optional_impl temp(*this);
        *this = other;
        other = temp;
      }




     
      void reset()
      {
        storage.destroy();
      }




     
      T& emplace(const optional_impl<T>& other)
      {




        storage.construct(other.value());

        return storage.u.value;
      }
# 530 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
      template <typename U,
                typename... URest,
                typename etl::enable_if<!etl::is_base_of<optional_impl,
                                                         typename etl::remove_cv<typename etl::remove_reference<U>::type>::type>::value, int>::type = 0>
     
      T& emplace(U&& first, URest&&... rest)
      {
        storage.construct(etl::forward<U>(first), etl::forward<URest>(rest)...);

        return storage.u.value;
      }




     
      T& emplace()
      {
        storage.construct();

        return storage.u.value;
      }
# 650 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
    private:

      struct dummy_t {};




      struct storage_type
      {
        typedef typename etl::remove_const<T>::type* pointer_type;


       
        storage_type()
          : u()
          , valid(false)
        {
        }


       
        void construct(const T& value_)
        {
          destroy();

          etl::construct_at(const_cast<pointer_type>(&u.value), value_);
          valid = true;
        }



       
        void construct(T&& value_)
        {
          destroy();

          etl::construct_at(const_cast<pointer_type>(&u.value), etl::move(value_));
          valid = true;
        }


        template <typename... TArgs>
       
        void construct(TArgs&&... args)
        {
          destroy();

          etl::construct_at(const_cast<pointer_type>(&u.value), etl::forward<TArgs>(args)...);
          valid = true;
        }



       
        void destroy()
        {
          if (valid)
          {
            etl::destroy_at(const_cast<pointer_type>(&u.value));
            valid = false;
          }
        }


        union union_type
        {
         
          union_type()
            : dummy()
          {
          }

         
          ~union_type()
          {
          }

          dummy_t dummy;
          T value;
        } u;

        bool valid;
      };

      storage_type storage;
    };




    template <typename T>
    class optional_impl<T, true>
    {
    protected:

      typedef T value_type;
      typedef optional_impl<T, true> this_type;




      constexpr
      optional_impl()
        : storage()
      {
      }




      constexpr
      optional_impl(etl::nullopt_t)
        : storage()
      {
      }

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_uninitialized_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_uninitialized_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
# 767 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 2



      constexpr
      optional_impl(const optional_impl<T>& other)
      {
        if (other.has_value())
        {
          storage.construct(other.value());
        }
      }
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 779 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 2





      constexpr
      optional_impl(optional_impl&& other)
      {
        if (other.has_value())
        {
          storage.construct(etl::move(other.value()));
        }
      }




      constexpr
      optional_impl(const T& value_)
      {
        storage.construct(value_);
      }




      constexpr
      optional_impl(T&& value_)
      {
        storage.construct(etl::move(value_));
      }




      template <typename... TArgs>
      constexpr
        optional_impl(etl::in_place_t, TArgs&&... args)
      {
        storage.construct(etl::forward<TArgs>(args)...);
      }





      template <typename U, typename... TArgs >
      constexpr optional_impl(etl::in_place_t,
                                    std::initializer_list<U> ilist,
                                    TArgs&&... args)
      {
        storage.construct(ilist, etl::forward<TArgs>(args)...);
      }






      constexpr
      optional_impl& operator =(etl::nullopt_t)
      {
        if (has_value())
        {
          storage.destroy();
        }

        return *this;
      }




      constexpr
      optional_impl& operator =(const optional_impl<T>& other)
      {
        if (this != &other)
        {
          if (other.has_value())
          {
            storage.construct(other.value());
          }
          else
          {
            storage.destroy();
          }
        }

        return *this;
      }





      constexpr
      optional_impl& operator =(optional_impl&& other)
      {
        if (this != &other)
        {
          if (other.has_value())
          {
            storage.construct(etl::move(other.value()));
          }
          else
          {
            storage.destroy();
          }
        }

        return *this;
      }





      constexpr
      optional_impl& operator =(const T& value_)
      {
        storage.construct(value_);

        return *this;
      }





      constexpr
      optional_impl& operator =(T&& value_)
      {
        storage.construct(etl::move(value_));

        return *this;
      }


  public:




      constexpr
      T* operator ->()
      {




        return &storage.value;
      }




      constexpr
      const T* operator ->() const
      {




        return &storage.value;
      }




      constexpr
      T& operator *() &
      {




        return storage.value;
      }




      constexpr
      const T& operator *() const &
      {




        return storage.value;
      }





      constexpr
      T&& operator *()&&
      {




        return etl::move(storage.value);
      }




      constexpr
      const T&& operator *() const&&
      {




        return etl::move(storage.value);
      }





      constexpr
      bool has_value() const
      {
        return storage.valid;
      }




      constexpr
      explicit operator bool() const
      {
        return has_value();
      }




      constexpr
      T& value() &
      {




        return storage.value;
      }




      constexpr
      const T& value() const &
      {




        return storage.value;
      }




      constexpr
      T value_or(const T& default_value) const &
      {
        return has_value() ? value() : default_value;
      }





      constexpr
      T&& value()&&
      {




        return etl::move(storage.value);
      }




      constexpr
      const T&& value() const&&
      {




        return etl::move(storage.value);
      }




      template <typename U>
      constexpr
      etl::enable_if_t<etl::is_convertible<U, T>::value, T>
        value_or(U&& default_value) const&
      {
        return has_value() ? value() : etl::forward<T>(default_value);
      }




      template <typename U>
      constexpr
      etl::enable_if_t<etl::is_convertible<U, T>::value, T>
        value_or(U&& default_value)&&
      {
        return has_value() ? etl::move(value()) : etl::forward<T>(default_value);
      }





      constexpr
      void swap(optional_impl& other)
      {
        optional_impl temp(*this);
        *this = other;
        other = temp;
      }




      constexpr
      void reset()
      {
        storage.destroy();
      }




     
      T& emplace(const optional_impl<T>& other)
      {




        storage.construct(other.value());

        return storage.u.value;
      }






      template <typename... TArgs>
      constexpr
      T& emplace(TArgs&& ... args)
      {
        storage.construct(etl::forward<TArgs>(args)...);

        return storage.value;
      }
# 1248 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
    private:




      struct storage_type
      {

        constexpr
        storage_type()
          : value()
          , valid(false)
        {
        }


        constexpr
        void construct(const T& value_)
        {
          value = value_;
          valid = true;
        }



        constexpr
        void construct(T&& value_)
        {
          value = value_;
          valid = true;
        }


        template <typename... TArgs>
        constexpr
        void construct(TArgs&&... args)
        {
          value = T(etl::forward<TArgs>(args)...);
          valid = true;
        }



        constexpr
        void destroy()
        {
          valid = false;
        }

        T value;
        bool valid;
      };

      storage_type storage;
    };
  }

#define ETL_OPTIONAL_ENABLE_CPP14 typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0
#define ETL_OPTIONAL_ENABLE_CPP20_STL typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0

#define ETL_OPTIONAL_ENABLE_CONSTEXPR_BOOL_RETURN_CPP14 ETL_CONSTEXPR14 typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type
#define ETL_OPTIONAL_ENABLE_CONSTEXPR_BOOL_RETURN_CPP20_STL ETL_CONSTEXPR20_STL typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type
# 1318 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
  template <typename T>
  class optional : public private_optional::optional_impl<T>
  {
  private:

    typedef private_optional::optional_impl<T> impl_t;

  public:

    typedef T value_type;





    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
    optional()
      : impl_t()
    {
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
    optional()
      : impl_t()
    {
    }
# 1360 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
    optional(etl::nullopt_t)
      : impl_t(etl::nullopt)
    {
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
    optional(etl::nullopt_t)
      : impl_t(etl::nullopt)
    {
    }
# 1386 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_uninitialized_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_uninitialized_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
# 1387 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 2




    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
    optional(const optional& other)
      : impl_t(other)
    {
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
    optional(const optional& other)
      : impl_t(other)
    {
    }
# 1416 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 1417 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 2





    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
    optional(optional&& other)
      : impl_t(other)
    {
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
    optional(optional&& other)
      : impl_t(other)
    {
    }






    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
    optional(const T& value_)
      : impl_t(value_)
    {
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
    optional(const T& value_)
      : impl_t(value_)
    {
    }
# 1475 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
    optional(T&& value_)
      : impl_t(etl::move(value_))
    {
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
    optional(T&& value_)
      : impl_t(etl::move(value_))
    {
    }






    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0, typename... Args>
    constexpr
    explicit optional(etl::in_place_t, Args&&... args)
      : impl_t(etl::in_place_t{}, etl::forward<Args>(args)...)
    {
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0, typename... Args>
   
    explicit optional(etl::in_place_t, Args&&... args)
      : impl_t(etl::in_place_t{}, etl::forward<Args>(args)...)
    {
    }





    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0, typename... TArgs>
    constexpr
    explicit optional(etl::in_place_t,
                      std::initializer_list<U> ilist,
                      TArgs&&... args)
      : impl_t(etl::in_place_t{}, ilist, etl::forward<TArgs>(args)...)
    {
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0, typename... TArgs>
   
    explicit optional(etl::in_place_t,
                      std::initializer_list<U> ilist,
                      TArgs&&... args)
      : impl_t(etl::in_place_t{}, ilist, etl::forward<TArgs>(args)...)
    {
    }







    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
    optional& operator =(etl::nullopt_t)
    {
      impl_t::operator=(etl::nullopt);

      return *this;
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
    optional& operator =(etl::nullopt_t)
    {
      impl_t::operator=(etl::nullopt);

      return *this;
    }
# 1581 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
    optional& operator =(const optional& other)
    {
      impl_t::operator=(other);

      return *this;
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
    optional& operator =(const optional& other)
    {
      impl_t::operator=(other);

      return *this;
    }
# 1617 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
      optional& operator =(optional&& other)
    {
      impl_t::operator=(etl::move(other));

      return *this;
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
      optional& operator =(optional&& other)
    {
      impl_t::operator=(etl::move(other));

      return *this;
    }






    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
    optional& operator =(const T& value_)
    {
      impl_t::operator=(value_);

      return *this;
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
    optional& operator =(const T& value_)
    {
      impl_t::operator=(value_);

      return *this;
    }
# 1679 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h"
    template <typename U = T, typename etl::enable_if< etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
    constexpr
      optional& operator =(T&& value_)
    {
      impl_t::operator=(etl::move(value_));

      return *this;
    }




    template <typename U = T, typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<U>::type>::value, int>::type = 0>
   
      optional& operator =(T&& value_)
    {
      impl_t::operator=(etl::move(value_));

      return *this;
    }

  };

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_uninitialized_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_uninitialized_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuninitialized"
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
# 1703 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 2




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    if (lhs.has_value() != rhs.has_value())
    {
      return false;
    }
    else if (!lhs.has_value() && !rhs.has_value())
    {
      return true;
    }
    else
    {
      return lhs.value() == rhs.value();
    }
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    if (lhs.has_value() != rhs.has_value())
    {
      return false;
    }
    else if (!lhs.has_value() && !rhs.has_value())
    {
      return true;
    }
    else
    {
      return lhs.value() == rhs.value();
    }
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    return !(lhs == rhs);
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    return !(lhs == rhs);
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    if (!rhs.has_value())
    {
      return false;
    }
    else if (!lhs.has_value())
    {
      return true;
    }
    else
    {
      return lhs.value() < rhs.value();
    }
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    if (!rhs.has_value())
    {
      return false;
    }
    else if (!lhs.has_value())
    {
      return true;
    }
    else
    {
      return lhs.value() < rhs.value();
    }
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    return !(rhs < lhs);
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    return !(rhs < lhs);
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    return (rhs < lhs);
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    return (rhs < lhs);
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    return !(lhs < rhs);
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(const etl::optional<T>& lhs, const etl::optional<T>& rhs)
  {
    return !(lhs < rhs);
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(const etl::optional<T>& lhs, etl::nullopt_t)
  {
    return !lhs.has_value();
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(const etl::optional<T>& lhs, etl::nullopt_t)
  {
    return !lhs.has_value();
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(etl::nullopt_t, const etl::optional<T>& rhs)
  {
    return !rhs.has_value();
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(etl::nullopt_t, const etl::optional<T>& rhs)
  {
    return !rhs.has_value();
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(const etl::optional<T>& lhs, etl::nullopt_t)
  {
    return !(lhs == etl::nullopt);
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(const etl::optional<T>& lhs, etl::nullopt_t)
  {
    return !(lhs == etl::nullopt);
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(etl::nullopt_t , const etl::optional<T>& rhs)
  {
    return !(etl::nullopt == rhs);
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(etl::nullopt_t, const etl::optional<T>& rhs)
  {
    return !(etl::nullopt == rhs);
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(const etl::optional<T>&, etl::nullopt_t)
  {
    return false;
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(const etl::optional<T>&, etl::nullopt_t)
  {
    return false;
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(etl::nullopt_t, const etl::optional<T>& rhs)
  {
    return rhs.has_value();
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(etl::nullopt_t, const etl::optional<T>& rhs)
  {
    return rhs.has_value();
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(const etl::optional<T>& lhs, etl::nullopt_t)
  {
    return !lhs.has_value();
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(const etl::optional<T>& lhs, etl::nullopt_t)
  {
    return !lhs.has_value();
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(etl::nullopt_t, const etl::optional<T>&)
  {
    return true;
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(etl::nullopt_t, const etl::optional<T>&)
  {
    return true;
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(const etl::optional<T>& lhs, etl::nullopt_t)
  {
    return lhs.has_value();
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(const etl::optional<T>& lhs, etl::nullopt_t)
  {
    return lhs.has_value();
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(etl::nullopt_t, const etl::optional<T>&)
  {
    return false;
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(etl::nullopt_t, const etl::optional<T>&)
  {
    return false;
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(const etl::optional<T>&, etl::nullopt_t)
  {
    return true;
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(const etl::optional<T>&, etl::nullopt_t)
  {
    return true;
  }




  template <typename T>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(etl::nullopt_t, const etl::optional<T>& rhs)
  {
    return !rhs.has_value();
  }




  template <typename T>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(etl::nullopt_t, const etl::optional<T>& rhs)
  {
    return !rhs.has_value();
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() == rhs : false;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() == rhs : false;
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(const etl::optional<T>& lhs, const U& rhs)
  {
    return !(lhs == rhs);
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(const etl::optional<T>& lhs, const U& rhs)
  {
    return !(lhs == rhs);
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? rhs.value() == lhs : false;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator ==(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? rhs.value() == lhs : false;
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(const U& lhs, const etl::optional<T>& rhs)
  {
    return !(lhs == rhs);
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator !=(const U& lhs, const etl::optional<T>& rhs)
  {
    return !(lhs == rhs);
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() < rhs : true;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() < rhs : true;
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? lhs < rhs.value() : false;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? lhs < rhs.value() : false;
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() <= rhs : true;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() <= rhs : true;
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? lhs <= rhs.value() : false;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator <=(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? lhs <= rhs.value() : false;
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() > rhs : false;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() > rhs : false;
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? lhs > rhs.value() : true;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? lhs > rhs.value() : true;
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() >= rhs : false;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(const etl::optional<T>& lhs, const U& rhs)
  {
    return lhs.has_value() ? lhs.value() >= rhs : false;
  }




  template <typename T, typename U>
  constexpr typename etl::enable_if< etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? lhs >= rhs.value() : true;
  }




  template <typename T, typename U>
  typename etl::enable_if<!etl::is_pod<typename etl::remove_cv<T>::type>::value, bool>::type operator >=(const U& lhs, const etl::optional<T>& rhs)
  {
    return rhs.has_value() ? lhs >= rhs.value() : true;
  }

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 2289 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/optional.h" 2




  template <typename T>
  etl::optional<typename etl::decay<T>::type> make_optional(T& value)
  {
    return etl::optional<typename etl::decay<T>::type>(value);
  }





  template <typename T>
  optional(T) -> optional<T>;

}




template <typename T>
 void swap(etl::optional<T>& lhs, etl::optional<T>& rhs)
{
  lhs.swap(rhs);
}

#undef ETL_OPTIONAL_ENABLE_CPP14
#undef ETL_OPTIONAL_ENABLE_CPP20_STL

#undef ETL_OPTIONAL_ENABLE_CONSTEXPR_BOOL_RETURN_CPP14
#undef ETL_OPTIONAL_ENABLE_CONSTEXPR_BOOL_RETURN_CPP20_STL
# 40 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h" 2

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/ctype.h" 1 3

#define _CTYPE_H_ 
# 11 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/ctype.h" 3

# 11 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/ctype.h" 3
extern "C" {

int isalnum (int __c);
int isalpha (int __c);
int iscntrl (int __c);
int isdigit (int __c);
int isgraph (int __c);
int islower (int __c);
int isprint (int __c);
int ispunct (int __c);
int isspace (int __c);
int isupper (int __c);
int isxdigit (int __c);
int tolower (int __c);
int toupper (int __c);


int isblank (int __c);
# 60 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/ctype.h" 3
#define _U 01
#define _L 02
#define _N 04
#define _S 010
#define _P 020
#define _C 040
#define _X 0100
#define _B 0200


extern const char _ctype_[];




#define __locale_ctype_ptr() _ctype_


#define __CTYPE_PTR (__locale_ctype_ptr ())
# 181 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/ctype.h" 3
}
# 42 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h" 2


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
             
             
# 56 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
#define ETL_PUSHED_MIN_MAX 
# 45 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h" 2


# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h"
namespace etl
{



  struct string_pad_direction
  {
    enum enum_type
    {
      LEFT,
      RIGHT,
    };

    typedef int value_type; constexpr string_pad_direction() : value(static_cast<enum_type>(value_type())) {} constexpr string_pad_direction(enum_type value_) : value(value_) {} constexpr explicit string_pad_direction(value_type value_) : value(static_cast<enum_type>(value_)) {} constexpr operator value_type() const {return static_cast<value_type>(value);} constexpr value_type get_value() const {return static_cast<value_type>(value);} constexpr enum_type get_enum() const {return value;} constexpr const char* c_str() const { switch (value) {
    case LEFT: return "left";
    case RIGHT: return "right";
    default: return "?"; } } private: enum_type value;
  };




  template <typename TChar>
  struct whitespace;

  template <>
  struct whitespace<char>
  {
    static constexpr const char* value()
    {
      return " \t\n\r\f\v";
    }
  };


  template <>
  struct whitespace<char8_t>
  {
    static constexpr const char8_t* value()
    {
      return u8" \t\n\r\f\v";
    }
  };


  template <>
  struct whitespace<wchar_t>
  {
    static constexpr const wchar_t* value()
    {
      return L" \t\n\r\f\v";
    }
  };


  template <>
  struct whitespace<char16_t>
  {
    static constexpr const char16_t* value()
    {
      return u" \t\n\r\f\v";
    }
  };

  template <>
  struct whitespace<char32_t>
  {
    static constexpr const char32_t* value()
    {
      return U" \t\n\r\f\v";
    }
  };



  template <typename TChar>
  inline constexpr const TChar* whitespace_v = whitespace<TChar>::value();






  template <typename TIString>
  void trim_from_left(TIString& s, typename TIString::const_pointer trim_characters)
  {
    typename TIString::size_type position = s.find_first_not_of(trim_characters);
    s.erase(0U, position);
  }





  template <typename TIString>
  void trim_whitespace_left(TIString& s)
  {
    trim_from_left(s, whitespace<typename TIString::value_type>::value());
  }





  template <typename TStringView>
  TStringView trim_from_view_left(const TStringView& view, typename TStringView::const_pointer trim_characters)
  {
    typename TStringView::size_type first = view.find_first_not_of(trim_characters);

    typename TStringView::const_pointer pbegin = view.data() + view.size();

    if (first != TStringView::npos)
    {
      pbegin = view.data() + first;
    }

    return TStringView(pbegin, etl::distance(pbegin, view.data() + view.size()));
  }





  template <typename TStringView>
  TStringView trim_view_whitespace_left(TStringView& s)
  {
    return trim_from_view_left(s, whitespace<typename TStringView::value_type>::value());
  }





  template <typename TIString>
  void trim_left(TIString& s, typename TIString::const_pointer delimiters)
  {
    typename TIString::size_type p = s.find_first_of(delimiters);

    if (p == TIString::npos)
    {
      s.clear();
    }
    else
    {
      s.erase(0, p);
    }
  }





  template <typename TStringView>
  TStringView trim_view_left(const TStringView& view, typename TStringView::const_pointer delimiters)
  {
    typename TStringView::size_type first = view.find_first_of(delimiters);

    typename TStringView::const_pointer pbegin = view.data();

    if (first != TStringView::npos)
    {
      pbegin += first;
      return TStringView(pbegin, view.size() - first);
    }
    else
    {
      return TStringView(pbegin, typename TStringView::size_type(0U));
    }
  }





  template <typename TIString>
  void trim_from_right(TIString& s, typename TIString::const_pointer trim_characters)
  {
    s.erase(s.find_last_not_of(trim_characters) + 1);
  }





  template <typename TIString>
  void trim_whitespace_right(TIString& s)
  {
    trim_from_right(s, whitespace<typename TIString::value_type>::value());
  }





  template <typename TStringView>
  TStringView trim_from_view_right(const TStringView& view, typename TStringView::const_pointer trim_characters)
  {
    typename TStringView::size_type last = view.find_last_not_of(trim_characters) + 1;

    typename TStringView::const_pointer pend = view.data();

    if (last != TStringView::npos)
    {
      pend += last;
    }

    return TStringView(view.data(), etl::distance(view.data(), pend));
  }





  template <typename TStringView>
  TStringView trim_view_whitespace_right(TStringView& view)
  {
    return trim_from_view_right(view, whitespace<typename TStringView::value_type>::value());
  }




  template <typename TIString>
  void trim_right(TIString& s, typename TIString::const_pointer delimiters)
  {
    typename TIString::size_type p = s.find_last_of(delimiters);

    if (p == TIString::npos)
    {
      s.clear();
    }
    else
    {
      ++p;

      if (p != s.size())
      {
        s.erase(p);
      }
    }
  }




  template <typename TStringView>
  TStringView trim_view_right(const TStringView& view, typename TStringView::const_pointer delimiters)
  {
    typename TStringView::size_type last = view.find_last_of(delimiters) + 1;

    typename TStringView::const_pointer pend = view.data();

    if (last != TStringView::npos)
    {
      pend += last;
      return TStringView(view.data(), etl::distance(view.data(), pend));
    }
    else
    {
      return TStringView(view.data(), typename TStringView::size_type(0U));
    }
  }





  template <typename TIString>
  void trim_from(TIString& s, typename TIString::const_pointer trim_characters)
  {
    trim_from_left(s, trim_characters);
    trim_from_right(s, trim_characters);
  }





  template <typename TIString>
  void trim_whitespace(TIString& s)
  {
    trim_from(s, whitespace<typename TIString::value_type>::value());
  }





  template <typename TStringView>
  TStringView trim_from_view(const TStringView& view, typename TStringView::const_pointer trim_characters)
  {
    typename TStringView::size_type first = view.find_first_not_of(trim_characters);
    typename TStringView::size_type last = view.find_last_not_of(trim_characters) + 1;

    typename TStringView::const_pointer pbegin = view.data();
    typename TStringView::const_pointer pend = view.data();

    if (first != TStringView::npos)
    {
      pbegin += first;
    }

    if (last != TStringView::npos)
    {
      pend += last;
    }

    return TStringView(pbegin, etl::distance(pbegin, pend));
  }





  template <typename TStringView>
  TStringView trim_view_whitespace(const TStringView& view)
  {
    return trim_from_view(view, whitespace<typename TStringView::value_type>::value());
  }





  template <typename TIString>
  void trim(TIString& s, typename TIString::const_pointer delimiters)
  {
    trim_left(s, delimiters);
    trim_right(s, delimiters);
  }





  template <typename TStringView>
  TStringView trim_view(const TStringView& view, typename TStringView::const_pointer delimiters)
  {
    typename TStringView::size_type first = view.find_first_of(delimiters);
    typename TStringView::size_type last = view.find_last_of(delimiters) + 1;

    typename TStringView::const_pointer pbegin = view.data();
    typename TStringView::const_pointer pend = view.data();

    if (first != TStringView::npos)
    {
      pbegin += first;
    }

    if (last != TStringView::npos)
    {
      pend += last;
    }

    return TStringView(pbegin, etl::distance(pbegin, pend));
  }




  template <typename TIString>
  void left_n(TIString& s, typename TIString::size_type n)
  {
    n = (n > s.size()) ? s.size() : n;

    s.erase(s.begin() + n, s.end());
  }




  template <typename TStringView>
  TStringView left_n_view(const TStringView& view, typename TStringView::size_type n)
  {
    n = (n > view.size()) ? view.size() : n;

    return TStringView(etl::addressof(*view.begin()), n);
  }




  template <typename TIString>
  void right_n(TIString& s, typename TIString::size_type n)
  {
    n = (n > s.size()) ? s.size() : n;

    s.erase(s.begin(), s.end() - n);
  }




  template <typename TStringView>
  TStringView right_n_view(const TStringView& view, typename TStringView::size_type n)
  {
    n = (n > view.size()) ? view.size() : n;

    return TStringView(view.data() + view.size() - n, n);
  }





  template <typename TIString>
  void reverse(TIString& s)
  {
    etl::reverse(s.begin(), s.end());
  }




  template <typename TIString, typename TPair>
  void replace_characters(TIString& s,
                          const TPair* pairsbegin,
                          const TPair* pairsend)
  {
    while (pairsbegin != pairsend)
    {
      etl::replace(s.begin(), s.end(), pairsbegin->first, pairsbegin->second);
      ++pairsbegin;
    }
  }




  template <typename TIString, typename TPair>
  void replace_strings(TIString& s,
                        const TPair* pairsbegin,
                        const TPair* pairsend)
  {
    while (pairsbegin != pairsend)
    {
      const typename TIString::value_type* p_old = pairsbegin->first;
      const typename TIString::value_type* p_new = pairsbegin->second;

      typename TIString::size_type position = 0U;

      do
      {
        position = s.find(p_old, position);
        if (position != TIString::npos)
        {
          s.replace(position, typename TIString::size_type(etl::strlen(p_old)), p_new, typename TIString::size_type(etl::strlen(p_new)));
          position += typename TIString::size_type(etl::strlen(p_new));
        }
      } while (position != TIString::npos);

      ++pairsbegin;
    }
  }




  template <typename TIterator, typename TPointer>
  TIterator find_first_of(TIterator first, TIterator last, TPointer delimiters)
  {
    TIterator itr(first);

    while (itr != last)
    {
      TPointer pd = delimiters;

      while (*pd != 0)
      {
        if (*itr == *pd)
        {
          return itr;
        }

        ++pd;
      }

      ++itr;
    }

    return last;
  }




  template <typename TIString, typename TPointer>
  typename TIString::iterator find_first_of(TIString& s, TPointer delimiters)
  {
    return find_first_of(s.begin(), s.end(), delimiters);
  }




  template <typename TIString, typename TPointer>
  typename TIString::const_iterator find_first_of(const TIString& s, TPointer delimiters)
  {
    return find_first_of(s.begin(), s.end(), delimiters);
  }




  template <typename TIterator, typename TPointer>
  TIterator find_first_not_of(TIterator first, TIterator last, TPointer delimiters)
  {
    TIterator itr(first);

    while (itr != last)
    {
      TPointer pd = delimiters;

      bool found = false;

      while (*pd != 0)
      {
        if (*itr == *pd)
        {
          found = true;
          break;
        }

        ++pd;
      }

      if (!found)
      {
        return itr;
      }

      ++itr;
    }

    return last;
  }




  template <typename TIString, typename TPointer>
  typename TIString::iterator find_first_not_of(TIString& s, TPointer delimiters)
  {
    return find_first_not_of(s.begin(), s.end(), delimiters);
  }




  template <typename TIString, typename TPointer>
  typename TIString::const_iterator find_first_not_of(const TIString& s, TPointer delimiters)
  {
    return find_first_not_of(s.begin(), s.end(), delimiters);
  }




  template <typename TIterator, typename TPointer>
  TIterator find_last_of(TIterator first, TIterator last, TPointer delimiters)
  {
    if (first == last)
    {
      return last;
    }

    TIterator itr(last);
    TIterator end(first);

    do
    {
      --itr;

      TPointer pd = delimiters;

      while (*pd != 0)
      {
        if (*itr == *pd)
        {
          return itr;
        }

        ++pd;
      }
    } while (itr != end);

    return last;
  }




  template <typename TIString, typename TPointer>
  typename TIString::iterator find_last_of(TIString& s, TPointer delimiters)
  {
    return find_last_of(s.begin(), s.end(), delimiters);
  }




  template <typename TIString, typename TPointer>
  typename TIString::const_iterator find_last_of(const TIString& s, TPointer delimiters)
  {
    return find_last_of(s.begin(), s.end(), delimiters);
  }




  template <typename TIterator, typename TPointer>
  TIterator find_last_not_of(TIterator first, TIterator last, TPointer delimiters)
  {
    if (first == last)
    {
      return last;
    }

    TIterator itr(last);
    TIterator end(first);

    do
    {
      --itr;

      TPointer pd = delimiters;

      bool found = false;

      while (*pd != 0)
      {
        if (*itr == *pd)
        {
          found = true;
          break;
        }

        ++pd;
      }

      if (!found)
      {
        return itr;
      }
    } while (itr != end);

    return last;
  }




  template <typename TIString, typename TPointer>
  typename TIString::iterator find_last_not_of(TIString& s, TPointer delimiters)
  {
    return find_last_not_of(s.begin(), s.end(), delimiters);
  }




  template <typename TIString, typename TPointer>
  typename TIString::const_iterator find_last_not_of(const TIString& s, TPointer delimiters)
  {
    return find_last_not_of(s.begin(), s.end(), delimiters);
  }




  template <typename TInput, typename TStringView>
  etl::optional<TStringView> get_token(const TInput& input, typename TInput::const_pointer delimiters, const etl::optional<TStringView>& last_view, bool ignore_empty_tokens)
  {
    typedef typename TInput::const_pointer const_pointer;

    bool token_found = false;
    typename TStringView::size_type position = 0U;
    TStringView view = last_view.value_or(TStringView());
    const_pointer begin_ptr = input.data();

    if (begin_ptr == nullptr)
    {
      return etl::optional<TStringView>();
    }

    const_pointer end_ptr = begin_ptr + input.size();

    while (!token_found)
    {

      if (view.data() != nullptr)
      {
        position = etl::distance(begin_ptr, view.data() + view.size() + 1U);


        if (position > input.size())
        {
          return etl::optional<TStringView>();
        }
      }


      const_pointer first_ptr = begin_ptr + position;
      const_pointer last_ptr = find_first_of(first_ptr, end_ptr, delimiters);

      view = TStringView(first_ptr, etl::distance(first_ptr, last_ptr));

      token_found = ((view.size() != 0U) || !ignore_empty_tokens);
    }

    return etl::optional<TStringView>(view);
  }
# 777 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h"
  template <typename TInput, typename TOutput>
  bool get_token_list(const TInput& input, TOutput& output, typename TInput::const_pointer delimiters, bool ignore_empty_tokens, size_t max_n_tokens = etl::integral_limits<size_t>::max)
  {
    typedef typename TOutput::value_type string_view_t;

    etl::optional<string_view_t> token;

    size_t count = 0;
    while ((count != output.max_size()) &&
           (count != max_n_tokens) &&
           (token = etl::get_token(input, delimiters, token, ignore_empty_tokens)))
    {
      output.push_back(token.value());
      ++count;
    }

    bool all_tokens_found = (token.has_value() == false);

    return all_tokens_found;
  }




  template <typename TIString>
  void pad_left(TIString& s, typename TIString::size_type required_size, typename TIString::value_type pad_char)
  {
    required_size = etl::min(required_size, s.max_size());

    if (required_size > s.size())
    {
      required_size -= s.size();
      s.insert(typename TIString::size_type(0U), required_size, pad_char);
    }
  }




  template <typename TIString>
  void pad_right(TIString& s, typename TIString::size_type required_size, typename TIString::value_type pad_char)
  {
    required_size = etl::min(required_size, s.max_size());

    if (required_size > s.size())
    {
      required_size -= s.size();
      s.insert(s.size(), required_size, pad_char);
    }
  }




  template <typename TIString>
  void pad(TIString& s, typename TIString::size_type required_size, string_pad_direction pad_direction, typename TIString::value_type pad_char)
  {
    switch (int(pad_direction))
    {
      case string_pad_direction::LEFT:
      {
        pad_left(s, required_size, pad_char);
        break;
      }

      case string_pad_direction::RIGHT:
      {
        pad_right(s, required_size, pad_char);
        break;
      }

      default:
      {
        break;
      }
    }
  }




  template <typename TString>
  void to_upper_case(TString& s)
  {
    etl::transform(s.begin(), s.end(), s.begin(), ::toupper);
  }




  template <typename TString>
  void to_lower_case(TString& s)
  {
    etl::transform(s.begin(), s.end(), s.begin(), ::tolower);
  }




  template <typename TString>
  void to_sentence_case(TString& s)
  {
    typename TString::iterator itr = s.begin();

    *itr = typename TString::value_type(::toupper(*itr));
    ++itr;

    etl::transform(itr, s.end(), itr, ::tolower);
  }
# 894 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h"
  struct str_n_copy_result
  {
    size_t count;
    bool truncated;
    bool terminated;
  };

  template <typename T>
  str_n_copy_result str_n_copy(const T* src, size_t n, T* dst)
  {
    if ((src == nullptr) || (dst == nullptr))
    {
      str_n_copy_result result = { 0, false, false };
      return result;
    }

    size_t count = 0;

    while ((count != n) && (*src != 0))
    {
      *dst++ = *src++;
      ++count;
    }


    if (count != n)
    {

      *dst = 0;
      str_n_copy_result result = { count, false, true };
      return result;
    }
    else
    {

      str_n_copy_result result = { count, *src != 0, false };
      return result;
    }
  }
}

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
             
             
# 52 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
#undef ETL_PUSHED_MIN_MAX
# 936 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_utilities.h" 2
# 48 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 50 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2




# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 1 3

#define _WCHAR_H_ 





#define __need_size_t 
#define __need_wchar_t 
#define __need_wint_t 
#define __need_NULL 
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 173 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 252 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_size_t
# 364 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_wchar_t
# 376 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_wint_t
# 414 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef NULL

#define NULL __null
# 425 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_NULL




#undef offsetof
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 13 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 2 3
# 21 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3
#define __need___va_list 
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stdarg.h" 1 3 4
# 34 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stdarg.h" 3 4
#undef __need___va_list
# 23 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 2 3
# 41 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3
#define WEOF ((wint_t)-1)
# 70 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3

# 70 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3
extern "C" {
# 82 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3
struct tm;


#define _MBSTATE_T 
typedef _mbstate_t mbstate_t;


wint_t btowc (int);
int wctob (wint_t);
size_t mbrlen (const char *__restrict, size_t, mbstate_t *__restrict);
size_t mbrtowc (wchar_t *__restrict, const char *__restrict, size_t,
      mbstate_t *__restrict);
size_t _mbrtowc_r (struct _reent *, wchar_t * , const char * ,
   size_t, mbstate_t *);
int mbsinit (const mbstate_t *);




size_t _mbsnrtowcs_r (struct _reent *, wchar_t * , const char ** ,
   size_t, size_t, mbstate_t *);
size_t mbsrtowcs (wchar_t *__restrict, const char **__restrict, size_t,
    mbstate_t *__restrict);
size_t _mbsrtowcs_r (struct _reent *, wchar_t * , const char ** , size_t, mbstate_t *);
size_t wcrtomb (char *__restrict, wchar_t, mbstate_t *__restrict);
size_t _wcrtomb_r (struct _reent *, char * , wchar_t, mbstate_t *);




size_t _wcsnrtombs_r (struct _reent *, char * , const wchar_t ** ,
   size_t, size_t, mbstate_t *);
size_t wcsrtombs (char *__restrict, const wchar_t **__restrict,
    size_t, mbstate_t *__restrict);
size_t _wcsrtombs_r (struct _reent *, char * , const wchar_t ** ,
   size_t, mbstate_t *);



wchar_t *wcscat (wchar_t *__restrict, const wchar_t *__restrict);
wchar_t *wcschr (const wchar_t *, wchar_t);
int wcscmp (const wchar_t *, const wchar_t *);
int wcscoll (const wchar_t *, const wchar_t *);
wchar_t *wcscpy (wchar_t *__restrict, const wchar_t *__restrict);





wchar_t *_wcsdup_r (struct _reent *, const wchar_t * );
size_t wcscspn (const wchar_t *, const wchar_t *);
size_t wcsftime (wchar_t *__restrict, size_t,
    const wchar_t *__restrict, const struct tm *__restrict);




size_t wcslcat (wchar_t *, const wchar_t *, size_t);
size_t wcslcpy (wchar_t *, const wchar_t *, size_t);
size_t wcslen (const wchar_t *);



wchar_t *wcsncat (wchar_t *__restrict,
     const wchar_t *__restrict, size_t);
int wcsncmp (const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy (wchar_t *__restrict,
     const wchar_t *__restrict, size_t);





wchar_t *wcspbrk (const wchar_t *, const wchar_t *);
wchar_t *wcsrchr (const wchar_t *, wchar_t);
size_t wcsspn (const wchar_t *, const wchar_t *);
wchar_t *wcsstr (const wchar_t *__restrict,
     const wchar_t *__restrict);
wchar_t *wcstok (wchar_t *__restrict, const wchar_t *__restrict,
     wchar_t **__restrict);
double wcstod (const wchar_t *__restrict, wchar_t **__restrict);
double _wcstod_r (struct _reent *, const wchar_t *, wchar_t **);

float wcstof (const wchar_t *__restrict, wchar_t **__restrict);

float _wcstof_r (struct _reent *, const wchar_t *, wchar_t **);



size_t wcsxfrm (wchar_t *__restrict, const wchar_t *__restrict,
    size_t);
# 184 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3
wchar_t *wmemchr (const wchar_t *, wchar_t, size_t);
int wmemcmp (const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy (wchar_t *__restrict, const wchar_t *__restrict,
     size_t);
wchar_t *wmemmove (wchar_t *, const wchar_t *, size_t);




wchar_t *wmemset (wchar_t *, wchar_t, size_t);

long wcstol (const wchar_t *__restrict, wchar_t **__restrict, int);

long long wcstoll (const wchar_t *__restrict, wchar_t **__restrict,
      int);

unsigned long wcstoul (const wchar_t *__restrict, wchar_t **__restrict,
       int);

unsigned long long wcstoull (const wchar_t *__restrict,
         wchar_t **__restrict, int);

long _wcstol_r (struct _reent *, const wchar_t *, wchar_t **, int);
long long _wcstoll_r (struct _reent *, const wchar_t *, wchar_t **, int);
unsigned long _wcstoul_r (struct _reent *, const wchar_t *, wchar_t **, int);
unsigned long long _wcstoull_r (struct _reent *, const wchar_t *, wchar_t **, int);

long double wcstold (const wchar_t *, wchar_t **);
# 227 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3
wint_t fgetwc (__FILE *);
wchar_t *fgetws (wchar_t *__restrict, int, __FILE *__restrict);
wint_t fputwc (wchar_t, __FILE *);
int fputws (const wchar_t *__restrict, __FILE *__restrict);

int fwide (__FILE *, int);

wint_t getwc (__FILE *);
wint_t getwchar (void);
wint_t putwc (wchar_t, __FILE *);
wint_t putwchar (wchar_t);
wint_t ungetwc (wint_t wc, __FILE *);

wint_t _fgetwc_r (struct _reent *, __FILE *);
wint_t _fgetwc_unlocked_r (struct _reent *, __FILE *);
wchar_t *_fgetws_r (struct _reent *, wchar_t *, int, __FILE *);
wchar_t *_fgetws_unlocked_r (struct _reent *, wchar_t *, int, __FILE *);
wint_t _fputwc_r (struct _reent *, wchar_t, __FILE *);
wint_t _fputwc_unlocked_r (struct _reent *, wchar_t, __FILE *);
int _fputws_r (struct _reent *, const wchar_t *, __FILE *);
int _fputws_unlocked_r (struct _reent *, const wchar_t *, __FILE *);
int _fwide_r (struct _reent *, __FILE *, int);
wint_t _getwc_r (struct _reent *, __FILE *);
wint_t _getwc_unlocked_r (struct _reent *, __FILE *);
wint_t _getwchar_r (struct _reent *);
wint_t _getwchar_unlocked_r (struct _reent *);
wint_t _putwc_r (struct _reent *, wchar_t, __FILE *);
wint_t _putwc_unlocked_r (struct _reent *, wchar_t, __FILE *);
wint_t _putwchar_r (struct _reent *, wchar_t);
wint_t _putwchar_unlocked_r (struct _reent *, wchar_t);
wint_t _ungetwc_r (struct _reent *, wint_t wc, __FILE *);
# 273 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3
__FILE *_open_wmemstream_r (struct _reent *, wchar_t **, size_t *);
# 284 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3
int fwprintf (__FILE *__restrict, const wchar_t *__restrict, ...);
int swprintf (wchar_t *__restrict, size_t,
   const wchar_t *__restrict, ...);
int vfwprintf (__FILE *__restrict, const wchar_t *__restrict,
   __gnuc_va_list);
int vswprintf (wchar_t *__restrict, size_t,
   const wchar_t *__restrict, __gnuc_va_list);
int vwprintf (const wchar_t *__restrict, __gnuc_va_list);
int wprintf (const wchar_t *__restrict, ...);


int _fwprintf_r (struct _reent *, __FILE *, const wchar_t *, ...);
int _swprintf_r (struct _reent *, wchar_t *, size_t, const wchar_t *, ...);
int _vfwprintf_r (struct _reent *, __FILE *, const wchar_t *, __gnuc_va_list);
int _vswprintf_r (struct _reent *, wchar_t *, size_t, const wchar_t *, __gnuc_va_list);
int _vwprintf_r (struct _reent *, const wchar_t *, __gnuc_va_list);
int _wprintf_r (struct _reent *, const wchar_t *, ...);


int fwscanf (__FILE *__restrict, const wchar_t *__restrict, ...);
int swscanf (const wchar_t *__restrict,
   const wchar_t *__restrict, ...);
int vfwscanf (__FILE *__restrict, const wchar_t *__restrict,
   __gnuc_va_list);
int vswscanf (const wchar_t *__restrict, const wchar_t *__restrict,
   __gnuc_va_list);
int vwscanf (const wchar_t *__restrict, __gnuc_va_list);
int wscanf (const wchar_t *__restrict, ...);


int _fwscanf_r (struct _reent *, __FILE *, const wchar_t *, ...);
int _swscanf_r (struct _reent *, const wchar_t *, const wchar_t *, ...);
int _vfwscanf_r (struct _reent *, __FILE *, const wchar_t *, __gnuc_va_list);
int _vswscanf_r (struct _reent *, const wchar_t *, const wchar_t *, __gnuc_va_list);
int _vwscanf_r (struct _reent *, const wchar_t *, __gnuc_va_list);
int _wscanf_r (struct _reent *, const wchar_t *, ...);

#define getwc(fp) fgetwc(fp)
#define putwc(wc,fp) fputwc((wc), (fp))
#define getwchar() fgetwc(_REENT_STDIN(_REENT))
#define putwchar(wc) fputwc((wc), _REENT_STDOUT(_REENT))
# 333 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/wchar.h" 3
}
# 55 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2
# 65 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
             
             
# 56 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
#define ETL_PUSHED_MIN_MAX 
# 66 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2
# 74 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"

# 74 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
namespace etl
{
  template <typename T, typename TTraits>
  class basic_string_view;
}

namespace etl
{




  class string_exception : public etl::exception
  {
  public:

    string_exception(string_type reason_, string_type file_name_, numeric_type line_number_)
      : exception(reason_, file_name_, line_number_)
    {
    }
  };





  class string_empty : public etl::string_exception
  {
  public:

    string_empty(string_type file_name_, numeric_type line_number_)
      : string_exception(("27""A"), file_name_, line_number_)
    {
    }
  };





  class string_out_of_bounds : public etl::string_exception
  {
  public:

    string_out_of_bounds(string_type file_name_, numeric_type line_number_)
      : string_exception(("27""B"), file_name_, line_number_)
    {
    }
  };





  class string_iterator : public etl::string_exception
  {
  public:

    string_iterator(string_type file_name_, numeric_type line_number_)
      : string_exception(("27""C"), file_name_, line_number_)
    {
    }
  };





  class string_truncation : public etl::string_exception
  {
  public:

    string_truncation(string_type file_name_, numeric_type line_number_)
      : string_exception(("27""D"), file_name_, line_number_)
    {
    }
  };





  namespace private_basic_string
  {

    template <typename T = void>
    class string_base_statics
    {
    public:

      typedef size_t size_type;

      static constexpr uint_least8_t IS_TRUNCATED = etl::bit<0>::value;
      static constexpr uint_least8_t CLEAR_AFTER_USE = etl::bit<1>::value;

      static constexpr size_type npos = etl::integral_limits<size_type>::max;
    };

    template <typename T>
    constexpr uint_least8_t string_base_statics<T>::IS_TRUNCATED;

    template <typename T>
    constexpr uint_least8_t string_base_statics<T>::CLEAR_AFTER_USE;

    template <typename T>
    constexpr typename string_base_statics<T>::size_type string_base_statics<T>::npos;
  }


  class string_base : public private_basic_string::string_base_statics<>
  {
  public:

    typedef size_t size_type;





    size_type size() const
    {
      return current_size;
    }





    size_type length() const
    {
      return current_size;
    }





    bool empty() const
    {
      return (current_size == 0);
    }





    bool full() const
    {
      return current_size == CAPACITY;
    }





    size_type capacity() const
    {
      return CAPACITY;
    }





    size_type max_size() const
    {
      return CAPACITY;
    }





    size_type available() const
    {
      return max_size() - size();
    }





    bool is_truncated() const
    {

      return flags.test<IS_TRUNCATED>();



    }






    [[deprecated]]
    bool truncated() const
    {
      return is_truncated();
    }





    void clear_truncated()
    {
      flags.set<IS_TRUNCATED, false>();
    }






    void set_secure()
    {
      flags.set<CLEAR_AFTER_USE>();
    }





    bool is_secure() const
    {

      return flags.test<CLEAR_AFTER_USE>();



    }

  protected:




    string_base(size_type max_size_)
      : current_size(0)
      , CAPACITY(max_size_)
    {
    }





    void set_truncated(bool status)
    {
      flags.set<IS_TRUNCATED>(status);
    }





    ~string_base()
    {
    }

    size_type current_size;
    const size_type CAPACITY;


    etl::flags<uint_least8_t> flags;

  };






  template <typename T>
  class ibasic_string : public etl::string_base
  {
  public:

    typedef ibasic_string<T> interface_type;

    typedef T value_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T* iterator;
    typedef const T* const_iterator;
    typedef etl::reverse_iterator<iterator> reverse_iterator;
    typedef etl::reverse_iterator<const_iterator> const_reverse_iterator;

    typedef typename etl::iterator_traits<iterator>::difference_type difference_type;





    iterator begin()
    {
      return &p_buffer[0];
    }





    const_iterator begin() const
    {
      return &p_buffer[0];
    }





    iterator end()
    {
      return &p_buffer[current_size];
    }





    const_iterator end() const
    {
      return &p_buffer[current_size];
    }





    const_iterator cbegin() const
    {
      return &p_buffer[0];
    }





    const_iterator cend() const
    {
      return &p_buffer[current_size];
    }





    reverse_iterator rbegin()
    {
      return reverse_iterator(end());
    }





    const_reverse_iterator rbegin() const
    {
      return const_reverse_iterator(end());
    }





    reverse_iterator rend()
    {
      return reverse_iterator(begin());
    }





    const_reverse_iterator rend() const
    {
      return const_reverse_iterator(begin());
    }





    const_reverse_iterator crbegin() const
    {
      return const_reverse_iterator(cend());
    }





    const_reverse_iterator crend() const
    {
      return const_reverse_iterator(cbegin());
    }






    void resize(size_type new_size)
    {
      resize(new_size, 0);
    }






    void resize(size_type new_size, T value)
    {
      if (new_size > CAPACITY)
      {

        set_truncated(true);





      }

      new_size = etl::min(new_size, CAPACITY);


      if (new_size > current_size)
      {
        etl::fill(p_buffer + current_size, p_buffer + new_size, value);
      }

      current_size = new_size;
      p_buffer[new_size] = 0;
      cleanup();
    }




    template <typename TOperation>
    void resize_and_overwrite(size_type new_size, TOperation operation)
    {
      if (new_size > CAPACITY)
      {
        static_cast<void>(0);
      }

      current_size = operation(p_buffer, new_size);
      p_buffer[current_size] = '\0';
      cleanup();
    }






    void uninitialized_resize(size_type new_size)
    {
      new_size = etl::min(new_size, CAPACITY);

      current_size = new_size;
      p_buffer[new_size] = 0;
    }






    void fill(T value)
    {
      etl::fill(begin(), end(), value);
    }






    reference operator [](size_type i)
    {
      return p_buffer[i];
    }






    const_reference operator [](size_type i) const
    {
      return p_buffer[i];
    }







    reference at(size_type i)
    {
      static_cast<void>(sizeof(i < size()));
      return p_buffer[i];
    }







    const_reference at(size_type i) const
    {
      static_cast<void>(sizeof(i < size()));
      return p_buffer[i];
    }





    reference front()
    {
      return p_buffer[0];
    }





    const_reference front() const
    {
      return p_buffer[0];
    }





    reference back()
    {
      return p_buffer[current_size - 1];
    }





    const_reference back() const
    {
      return p_buffer[current_size - 1];
    }





    pointer data()
    {
      return p_buffer;
    }





    constexpr const_pointer data() const
    {
      return p_buffer;
    }





    pointer data_end()
    {
      return p_buffer + current_size;
    }





    const_pointer data_end() const
    {
      return p_buffer + current_size;
    }






    void assign(const etl::ibasic_string<T>& other)
    {
      if (&other != this)
      {
        clear();
        append_impl(begin(), other.begin(), other.end(), other.is_truncated(), other.is_secure());
      }
    }
# 693 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
    void assign(const etl::ibasic_string<T>& other, size_type subposition, size_type sublength)
    {
      if (&other != this)
      {
        clear();

        if (sublength == npos)
        {
          sublength = other.size() - subposition;
        }

        static_cast<void>(sizeof(subposition <= other.size()));

        append_impl(begin(), other.begin() + subposition, other.begin() + subposition + sublength, other.is_truncated(), other.is_secure());
      }
    }
# 717 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
    template <typename TIterator>
    void assign(TIterator first, TIterator last)
    {
      append_impl(begin(), first, last, false, false);
    }






    void assign(const_pointer str)
    {
      append_impl(begin(), str, false, false);
    }







    void assign(const_pointer str, size_type n)
    {
      append_impl(begin(), str, str + n, false, false);
    }




    template <typename TOtherTraits>
    void assign(const etl::basic_string_view<T, TOtherTraits>& view)
    {
      append_impl(begin(), view.begin(), view.end(), false, false);
    }







    void assign(size_type n, T c)
    {
      clear();


      set_truncated(n > CAPACITY);






      n = etl::min(n, CAPACITY);

      etl::fill_n(begin(), n, c);
      current_size = n;
      p_buffer[current_size] = 0;
    }




    void clear()
    {
      initialise();
      cleanup();
    }






    void push_back(T value)
    {
      if (current_size != CAPACITY)
      {
        p_buffer[current_size++] = value;
        p_buffer[current_size] = 0;
      }
      else
      {

        set_truncated(true);





      }
    }





    void pop_back()
    {
      if (current_size != 0)
      {
        p_buffer[--current_size] = 0;
      }
    }





    ibasic_string& append(const ibasic_string& str)
    {
      append_impl(end(), str.begin(), str.end(), str.is_truncated(), str.is_secure());

      return *this;
    }







    ibasic_string& append(const ibasic_string& str, size_type subposition, size_type sublength = npos)
    {
      if (sublength == npos)
      {
        sublength = str.size() - subposition;
      }

      static_cast<void>(sizeof(subposition <= str.size()));

      append_impl(end(), str.begin() + subposition, str.begin() + subposition + sublength, str.is_truncated(), str.is_secure());

      return *this;
    }






    template <class TIterator>
    ibasic_string& append(TIterator first, TIterator last)
    {
      append_impl(end(), first, last, false, false);

      return *this;
    }





    ibasic_string& append(const_pointer str)
    {
      append_impl(end(), str, false, false);

      return *this;
    }






    ibasic_string& append(const_pointer str, size_type n)
    {
      append_impl(end(), str, str + n, false, false);

      return *this;
    }





    template <typename TOtherTraits>
    ibasic_string& append(const etl::basic_string_view<T, TOtherTraits>& view)
    {
      append_impl(end(), view.begin(), view.end(), false, false);

      return *this;
    }






    ibasic_string& append(size_type n, T c)
    {
      size_type free_space = CAPACITY - current_size;


      set_truncated(n > free_space);






      n = etl::min(n, size_t(free_space));

      etl::fill_n(end(), n, c);
      current_size += n;
      p_buffer[current_size] = 0;

      return *this;
    }






    iterator insert(const_iterator position, T value)
    {

      iterator insert_position = to_iterator(position);

      if (current_size < CAPACITY)
      {

        if (position != end())
        {

          ++current_size;
          etl::mem_move(insert_position, end() - 1, insert_position + 1);
          *insert_position = value;
        }
        else
        {

          *insert_position = value;
          ++current_size;
        }
      }
      else
      {

        if (position != end())
        {

          etl::mem_move(insert_position, end() - 1, insert_position + 1);
          *insert_position = value;
        }


        set_truncated(true);





      }

      p_buffer[current_size] = 0;

      return insert_position;
    }







    iterator insert(const_iterator position, size_type n, T value)
    {
      iterator position_ = to_iterator(position);

      if (n == 0)
      {
        return position_;
      }


      iterator insert_position = to_iterator(position);
      const size_type start = etl::distance(cbegin(), position);


      if (start >= CAPACITY)
      {

        set_truncated(true);





        return to_iterator(position);;
      }


      if ((start + n) >= CAPACITY)
      {
        if ((current_size + n) > CAPACITY)
        {

          set_truncated(true);





        }

        current_size = CAPACITY;
        etl::fill(insert_position, end(), value);
      }
      else
      {

        const size_type shift_amount = n;
        const size_type to_position = start + shift_amount;
        const size_type remaining_characters = current_size - start;
        const size_type max_shift_characters = CAPACITY - start - shift_amount;
        const size_type characters_to_shift = etl::min(max_shift_characters, remaining_characters);


        if ((start + shift_amount + remaining_characters) > CAPACITY)
        {
          current_size = CAPACITY;


          set_truncated(true);





        }
        else
        {
          current_size += shift_amount;
        }

        etl::mem_move(insert_position, insert_position + characters_to_shift, begin() + to_position);
        etl::fill(insert_position, insert_position + shift_amount, value);
      }

      p_buffer[current_size] = 0;

      return position_;
    }
# 1071 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
    template <typename TIterator>
    iterator insert(const_iterator position, TIterator first, TIterator last)
    {
      iterator position_ = to_iterator(position);

      if (first == last)
      {
        return position_;
      }

      const size_type start = etl::distance(begin(), position_);
      const size_type n = etl::distance(first, last);


      if (start >= CAPACITY)
      {

        set_truncated(true);





        return position_;
      }


      if ((start + n) >= CAPACITY)
      {
        if (((current_size + n) > CAPACITY))
        {

          set_truncated(true);





        }

        current_size = CAPACITY;

        position_ = copy_characters(first, etl::distance(position_, end()), position_);
      }
      else
      {

        const size_type shift_amount = n;
        const size_type to_position = start + shift_amount;
        const size_type remaining_characters = current_size - start;
        const size_type max_shift_characters = CAPACITY - start - shift_amount;
        const size_type characters_to_shift = etl::min(max_shift_characters, remaining_characters);


        if ((start + shift_amount + remaining_characters) > CAPACITY)
        {
          current_size = CAPACITY;


          set_truncated(true);





        }
        else
        {
          current_size += shift_amount;
        }

        etl::mem_move(position_, position_ + characters_to_shift, begin() + to_position);


        position_ = copy_characters(first, etl::distance(first, last), position_);
      }

      p_buffer[current_size] = 0;

      return position_;
    }







    template <typename TOtherTraits>
    iterator insert(const_iterator position, const etl::basic_string_view<T, TOtherTraits>& view)
    {
      return insert(position, view.begin(), view.end());
    }






    etl::ibasic_string<T>& insert(size_type position, const etl::ibasic_string<T>& str)
    {
      static_cast<void>(sizeof(position <= size()));

      insert(begin() + position, str.cbegin(), str.cend());


      if (str.is_truncated())
      {
        set_truncated(true);




      }


      return *this;
    }






    template <typename TOtherTraits>
    etl::ibasic_string<T>& insert(size_type position, const etl::basic_string_view<T, TOtherTraits>& view)
    {
      static_cast<void>(sizeof(position <= size()));

      insert(begin() + position, view.cbegin(), view.cend());

      return *this;
    }
# 1212 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
    etl::ibasic_string<T>& insert(size_type position, const etl::ibasic_string<T>& str, size_type subposition, size_type sublength)
    {
      static_cast<void>(sizeof(position <= size()));
      static_cast<void>(sizeof(subposition <= str.size()));

      if ((sublength == npos) || (subposition + sublength > str.size()))
      {
        sublength = str.size() - subposition;
      }

      insert(begin() + position, str.cbegin() + subposition, str.cbegin() + subposition + sublength);


      if (str.is_truncated())
      {
        set_truncated(true);




      }


      return *this;
    }
# 1245 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
    template <typename TOtherTraits>
    etl::ibasic_string<T>& insert(size_type position, const etl::basic_string_view<T, TOtherTraits>& view, size_type subposition, size_type sublength)
    {
      static_cast<void>(sizeof(position <= size()));
      static_cast<void>(sizeof(subposition <= view.size()));

      if ((sublength == npos) || (subposition + sublength > view.size()))
      {
        sublength = view.size() - subposition;
      }

      insert(begin() + position, view.cbegin() + subposition, view.cbegin() + subposition + sublength);

      return *this;
    }






    etl::ibasic_string<T>& insert(size_type position, const_pointer s)
    {
      static_cast<void>(sizeof(position <= size()));

      insert(begin() + position, s, s + etl::strlen(s));
      return *this;
    }







    etl::ibasic_string<T>& insert(size_type position, const_pointer s, size_type n)
    {
      static_cast<void>(sizeof(position <= size()));

      insert(begin() + position, s, s + n);
      return *this;
    }







    etl::ibasic_string<T>& insert(size_type position, size_type n, value_type c)
    {
      static_cast<void>(sizeof(position <= size()));

      insert(begin() + position, n, c);
      return *this;
    }







    etl::ibasic_string<T>& erase(size_type position, size_type length_ = npos)
    {

      length_ = etl::min(length_, size() - position);

      erase(begin() + position, begin() + position + length_);

      return *this;
    }






    iterator erase(iterator i_element)
    {
      etl::mem_move(i_element + 1, end(), i_element);
      p_buffer[--current_size] = 0;

      return i_element;
    }






    iterator erase(const_iterator i_element)
    {
      iterator i_element_(to_iterator(i_element));

      etl::mem_move(i_element + 1, end(), i_element_);
      p_buffer[--current_size] = 0;

      return i_element_;
    }
# 1354 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
    iterator erase(const_iterator first, const_iterator last)
    {
      iterator first_ = to_iterator(first);
      iterator last_ = to_iterator(last);

      if (first_ == last_)
      {
        return first_;
      }

      etl::mem_move(last_, end(), first_);
      size_type n_delete = etl::distance(first_, last_);

      current_size -= n_delete;
      p_buffer[current_size] = 0;
      cleanup();

      return first_;
    }




    const_pointer c_str() const
    {
      return p_buffer;
    }







    size_type copy(pointer dest, size_type count, size_type pos = 0) const
    {
      if (pos < size())
      {
        if (count != npos)
        {
          count = etl::min(count, size() - pos);
        }
        else
        {
          count = size() - pos;
        }

        etl::mem_move(p_buffer + pos, count, dest);

        return count;
      }
      else
      {
        return 0U;
      }
    }






    size_type find(const ibasic_string<T>& str, size_type pos = 0) const
    {
      return find_impl(str.begin(), str.end(), str.size(), pos);
    }






    template <typename TOtherTraits>
    size_type find(const etl::basic_string_view<T, TOtherTraits>& view, size_type pos = 0) const
    {
      return find_impl(view.begin(), view.end(), view.size(), pos);
    }






    size_type find(const_pointer s, size_type pos = 0) const
    {
      size_t sz = etl::strlen(s);

      return find_impl(s, s + sz, sz, pos);
    }







    size_type find(const_pointer s, size_type pos, size_type n) const
    {
      size_t sz = etl::strlen(s);

      return find_impl(s, s + n, sz, pos);
    }






    size_type find(T c, size_type position = 0) const
    {
      const_iterator i = etl::find(begin() + position, end(), c);

      if (i != end())
      {
        return etl::distance(begin(), i);
      }
      else
      {
        return npos;
      }
    }






    size_type rfind(const ibasic_string<T>& str, size_type position = npos) const
    {
      return rfind_impl(str.rbegin(), str.rend(), str.size(), position);
    }






    template <typename TOtherTraits>
    size_type rfind(const etl::basic_string_view<T, TOtherTraits>& view, size_type pos = 0) const
    {
      return rfind_impl(view.rbegin(), view.rend(), view.size(), pos);
    }






    size_type rfind(const_pointer s, size_type position = npos) const
    {
      size_type len = etl::strlen(s);

      const_reverse_iterator srbegin(s + len);
      const_reverse_iterator srend(s);

      return rfind_impl(srbegin, srend, len, position);
    }






    size_type rfind(const_pointer s, size_type position, size_type length_) const
    {
      const_reverse_iterator srbegin(s + length_);
      const_reverse_iterator srend(s);

      return rfind_impl(srbegin, srend, length_, position);
    }






    size_type rfind(T c, size_type position = npos) const
    {
      if (position >= size())
      {
        position = size();
      }

      position = size() - position;

      const_reverse_iterator i = etl::find(rbegin() + position, rend(), c);

      if (i != rend())
      {
        return size() - etl::distance(rbegin(), i) - 1;
      }
      else
      {
        return npos;
      }
    }




    bool contains(const etl::ibasic_string<T>& str) const
    {
      return find(str) != npos;
    }




    template <typename TOtherTraits>
    bool contains(const etl::basic_string_view<T, TOtherTraits>& view) const
    {
      return find(view) != npos;
    }




    bool contains(const_pointer s) const
    {
      return find(s) != npos;
    }




    bool contains(value_type c) const
    {
      return find(c) != npos;
    }




    bool starts_with(const etl::ibasic_string<T>& str) const
    {
      return compare(0, str.size(), str) == 0;
    }




    template <typename TOtherTraits>
    bool starts_with(const etl::basic_string_view<T, TOtherTraits>& view) const
    {
      return compare(0, view.size(), view) == 0;
    }




    bool starts_with(const_pointer s) const
    {
      size_t len = etl::strlen(s);

      return compare(0, len, s, len) == 0;
    }




    bool starts_with(value_type c) const
    {
      return !empty() && (front() == c);
    }




    bool ends_with(const etl::ibasic_string<T>& str) const
    {
      if (str.size() > size())
      {
        return false;
      }

      return compare(size() - str.size(), str.size(), str) == 0;
    }




    template <typename TOtherTraits>
    bool ends_with(const etl::basic_string_view<T, TOtherTraits>& view) const
    {
      if (view.size() > size())
      {
        return false;
      }

      return compare(size() - view.size(), view.size(), view) == 0;
    }




    bool ends_with(const_pointer s) const
    {
      size_t len = etl::strlen(s);

      if (len > size())
      {
        return false;
      }

      return compare(size() - len, len, s, len) == 0;
    }




    bool ends_with(value_type c) const
    {
      return !empty() && (back() == c);
    }







    ibasic_string& replace(size_type position, size_type length_, const ibasic_string& str)
    {
      static_cast<void>(sizeof(position <= size()));


      length_ = etl::min(length_, size() - position);

      return replace_impl(begin() + position, begin() + position + length_, str.begin(), str.size(), str.is_truncated());
    }







    template <typename TOtherTraits>
    ibasic_string& replace(size_type position, size_type length_, const etl::basic_string_view<T, TOtherTraits>& view)
    {
      static_cast<void>(sizeof(position <= size()));


      length_ = etl::min(length_, size() - position);

      return replace_impl(begin() + position, begin() + position + length_, view.begin(), view.size(), false);
    }







    ibasic_string& replace(const_iterator first, const_iterator last, const ibasic_string& str)
    {
      return replace_impl(first, last, str.begin(), str.size(), str.is_truncated());
    }







    template <typename TOtherTraits>
    ibasic_string& replace(const_iterator first, const_iterator last, const etl::basic_string_view<T, TOtherTraits>& view)
    {
      return replace_impl(first, last, view.begin(), view.size(), false);
    }




    ibasic_string& replace(size_type position, size_type length_, const ibasic_string& str, size_type subposition, size_type sublength)
    {
      static_cast<void>(sizeof(position <= size()));
      static_cast<void>(sizeof(subposition <= str.size()));


      length_ = etl::min(length_, size() - position);
      sublength = etl::min(sublength, str.size() - subposition);

      return replace_impl(begin() + position, begin() + position + length_, str.begin() + subposition, sublength, str.is_truncated());
    }




    template <typename TOtherTraits>
    ibasic_string& replace(size_type position, size_type length_, const etl::basic_string_view<T, TOtherTraits>& view, size_type subposition, size_type sublength)
    {
      static_cast<void>(sizeof(position <= size()));
      static_cast<void>(sizeof(subposition <= view.size()));


      length_ = etl::min(length_, size() - position);
      sublength = etl::min(sublength, view.size() - subposition);

      return replace_impl(begin() + position, begin() + position + length_, view.begin() + subposition, sublength, false);
    }




    ibasic_string& replace(size_type position, size_type length_, const_pointer s)
    {
      static_cast<void>(sizeof(position <= size()));


      length_ = etl::min(length_, size() - position);

      return replace_impl(begin() + position, begin() + position + length_, s, etl::strlen(s), false);
    }
# 1778 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
    ibasic_string& replace(const_iterator first, const_iterator last, const_pointer s, size_type n)
    {
      return replace_impl(first, last, s, n, false);
    }




    template <typename TIterator>
    typename etl::enable_if<etl::is_same<TIterator, const_pointer>::value, ibasic_string>::type&
      replace(const_iterator first, const_iterator last, TIterator s)
    {
      return replace_impl(first, last, s, etl::strlen(s), false);
    }




    template <size_t Size>
    ibasic_string& replace(const_iterator first, const_iterator last, const value_type (&literal)[Size])
    {
      return replace_impl(first, last, literal, Size, false);
    }




    ibasic_string& replace(size_type position, size_type length_, const_pointer s, size_type n)
    {
      static_cast<void>(sizeof(position <= size()));


      length_ = etl::min(length_, size() - position);

      return replace_impl(begin() + position, begin() + position + length_, s, n, false);
    }




    ibasic_string& replace(size_type position, size_type length_, size_type n, value_type c)
    {
      static_cast<void>(sizeof(position <= size()));


      length_ = etl::min(length_, size() - position);


      erase(position, length_);


      insert(position, n, c);

      return *this;
    }




    ibasic_string& replace(const_iterator first, const_iterator last, size_type n, value_type c)
    {

      iterator first_ = to_iterator(first);
      iterator last_ = to_iterator(last);


      erase(first_, last_);


      insert(first_, n, c);

      return *this;
    }




    template <typename TIterator>
    ibasic_string& replace(const_iterator first, const_iterator last, TIterator first_replace, TIterator last_replace)
    {

      iterator first_ = to_iterator(first);
      iterator last_ = to_iterator(last);


      erase(first_, last_);


      insert(first_, first_replace, last_replace);

      return *this;
    }




    int compare(const ibasic_string& str) const
    {
      return compare(p_buffer,
                     p_buffer + size(),
                     str.p_buffer,
                     str.p_buffer + str.size());
    }




    template <typename TOtherTraits>
    int compare(const etl::basic_string_view<T, TOtherTraits>& view) const
    {
      return compare(p_buffer,
                     p_buffer + size(),
                     view.data(),
                     view.data() + view.size());
    }




    int compare(size_type position, size_type length_, const ibasic_string& str) const
    {
      static_cast<void>(sizeof(position <= size()));


      length_ = etl::min(length_, size() - position);

      return compare(p_buffer + position,
                     p_buffer + position + length_,
                     str.p_buffer,
                     str.p_buffer + str.size());
    }




    template <typename TOtherTraits>
    int compare(size_type position, size_type length_, const etl::basic_string_view<T, TOtherTraits>& view) const
    {
      return compare(p_buffer + position,
                     p_buffer + position + length_,
                     view.data(),
                     view.data() + view.size());
    }




    int compare(size_type position, size_type length_, const ibasic_string& str, size_type subposition, size_type sublength) const
    {
      static_cast<void>(sizeof(position <= size()));
      static_cast<void>(sizeof(subposition <= str.size()));


      length_ = etl::min(length_, size() - position);
      sublength = etl::min(sublength, str.size() - subposition);

      return compare(p_buffer + position,
                     p_buffer + position + length_,
                     str.p_buffer + subposition,
                     str.p_buffer + subposition + sublength);
    }




    template <typename TOtherTraits>
    int compare(size_type position, size_type length_, const etl::basic_string_view<T, TOtherTraits>& view, size_type subposition, size_type sublength) const
    {
      static_cast<void>(sizeof(position <= size()));
      static_cast<void>(sizeof(subposition <= view.size()));


      length_ = etl::min(length_, size() - position);
      sublength = etl::min(sublength, view.size() - subposition);

      return compare(p_buffer + position,
                     p_buffer + position + length_,
                     view.data() + subposition,
                     view.data() + subposition + sublength);
    }




    int compare(const value_type* s) const
    {
      return compare(p_buffer,
                     p_buffer + size(),
                     s,
                     s + etl::strlen(s));
    }




    int compare(size_type position, size_type length_, const_pointer s) const
    {
      return compare(p_buffer + position,
                     p_buffer + position + length_,
                     s,
                     s + etl::strlen(s));
    }




    int compare(size_type position, size_type length_, const_pointer s, size_type n) const
    {
      return compare(p_buffer + position,
                     p_buffer + position + length_,
                     s,
                     s + n);
    }






    size_type find_first_of(const ibasic_string<T>& str, size_type position = 0) const
    {
      return find_first_of(str.c_str(), position, str.size());
    }






    size_type find_first_of(const_pointer s, size_type position = 0) const
    {
      return find_first_of(s, position, etl::strlen(s));
    }






    template <typename TOtherTraits>
    size_type find_first_of(const etl::basic_string_view<T, TOtherTraits>& view, size_type position = 0) const
    {
      return find_first_of(view.data(), position, view.size());
    }







    size_type find_first_of(const_pointer s, size_type position, size_type n) const
    {
      if (position < size())
      {
        for (size_type i = position; i < size(); ++i)
        {
          for (size_type j = 0; j < n; ++j)
          {
            if (p_buffer[i] == s[j])
            {
              return i;
            }
          }
        }
      }

      return npos;
    }






    size_type find_first_of(value_type c, size_type position = 0) const
    {
      if (position < size())
      {
        for (size_type i = position; i < size(); ++i)
        {
          if (p_buffer[i] == c)
          {
            return i;
          }
        }
      }

      return npos;
    }






    size_type find_last_of(const ibasic_string<T>& str, size_type position = npos) const
    {
      return find_last_of(str.c_str(), position, str.size());
    }






    size_type find_last_of(const_pointer s, size_type position = npos) const
    {
      return find_last_of(s, position, etl::strlen(s));
    }






    template <typename TOtherTraits>
    size_type find_last_of(const etl::basic_string_view<T, TOtherTraits>& view, size_type position = npos) const
    {
      return find_last_of(view.data(), position, view.size());
    }







    size_type find_last_of(const_pointer s, size_type position, size_type n) const
    {
      if (empty())
      {
        return npos;
      }

      position = etl::min(position, size() - 1);

      const_reverse_iterator it = rbegin() + size() - position - 1;

      while (it != rend())
      {
        for (size_type j = 0; j < n; ++j)
        {
          if (p_buffer[position] == s[j])
          {
            return position;
          }
        }

        ++it;
        --position;
      }

      return npos;
    }






    size_type find_last_of(value_type c, size_type position = npos) const
    {
      if (empty())
      {
        return npos;
      }

      position = etl::min(position, size() - 1);

      const_reverse_iterator it = rbegin() + size() - position - 1;

      while (it != rend())
      {
        if (p_buffer[position] == c)
        {
          return position;
        }

        ++it;
        --position;
      }

      return npos;
    }






    size_type find_first_not_of(const ibasic_string<T>& str, size_type position = 0) const
    {
      return find_first_not_of(str.c_str(), position, str.size());
    }






    size_type find_first_not_of(const_pointer s, size_type position = 0) const
    {
      return find_first_not_of(s, position, etl::strlen(s));
    }






    template <typename TOtherTraits>
    size_type find_first_not_of(const etl::basic_string_view<T, TOtherTraits>& view, size_type position = 0) const
    {
      return find_first_not_of(view.data(), position, view.size());
    }







    size_type find_first_not_of(const_pointer s, size_type position, size_type n) const
    {
      if (position < size())
      {
        for (size_type i = position; i < size(); ++i)
        {
          bool found = false;

          for (size_type j = 0; j < n; ++j)
          {
            if (p_buffer[i] == s[j])
            {
              found = true;
            }
          }

          if (!found)
          {
            return i;
          }
        }
      }

      return npos;
    }






    size_type find_first_not_of(value_type c, size_type position = 0) const
    {
      if (position < size())
      {
        for (size_type i = position; i < size(); ++i)
        {
          if (*(p_buffer + i) != c)
          {
            return i;
          }
        }
      }

      return npos;
    }






    size_type find_last_not_of(const ibasic_string<T>& str, size_type position = npos) const
    {
      return find_last_not_of(str.c_str(), position, str.size());
    }






    size_type find_last_not_of(const_pointer s, size_type position = npos) const
    {
      return find_last_not_of(s, position, etl::strlen(s));
    }






    template <typename TOtherTraits>
    size_type find_last_not_of(const etl::basic_string_view<T, TOtherTraits>& view, size_type position = npos) const
    {
      return find_last_not_of(view.data(), position, view.size());
    }







    size_type find_last_not_of(const_pointer s, size_type position, size_type n) const
    {
      if (empty())
      {
        return npos;
      }

      position = etl::min(position, size() - 1);

      const_reverse_iterator it = rbegin() + size() - position - 1;

      while (it != rend())
      {
        bool found = false;

        for (size_type j = 0; j < n; ++j)
        {
          if (p_buffer[position] == s[j])
          {
            found = true;
          }
        }

        if (!found)
        {
          return position;
        }

        ++it;
        --position;
      }

      return npos;
    }




    size_type find_last_not_of(value_type c, size_type position = npos) const
    {
      if (empty())
      {
        return npos;
      }

      position = etl::min(position, size() - 1);

      const_reverse_iterator it = rbegin() + size() - position - 1;

      while (it != rend())
      {
        if (p_buffer[position] != c)
        {
          return position;
        }

        ++it;
        --position;
      }

      return npos;
    }




    ibasic_string& operator = (const ibasic_string& rhs)
    {
      if (&rhs != this)
      {
        assign(rhs);
      }

      return *this;
    }




    ibasic_string& operator = (const_pointer rhs)
    {
      assign(rhs);

      return *this;
    }




    template <typename TOtherTraits>
    ibasic_string& operator = (const etl::basic_string_view<T, TOtherTraits>& view)
    {
      assign(view);

      return *this;
    }




    ibasic_string& operator += (const ibasic_string& rhs)
    {
      append(rhs);

      return *this;
    }




    template <typename TOtherTraits>
    ibasic_string& operator += (const etl::basic_string_view<T, TOtherTraits>& rhs)
    {
      append(rhs);

      return *this;
    }




    ibasic_string& operator += (const_pointer rhs)
    {
      append(rhs);

      return *this;
    }




    ibasic_string& operator += (T rhs)
    {
      append(size_type(1), rhs);

      return *this;
    }
# 2433 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
    void initialize_free_space()
    {

      set_truncated(false);

      etl::mem_set(&p_buffer[current_size], &p_buffer[CAPACITY + 1U], char(0));
    }






    void trim_to_terminator()
    {

      set_truncated(p_buffer[CAPACITY] != T(0));


      p_buffer[CAPACITY] = T(0);
      current_size = etl::strlen(p_buffer);
    }

  protected:




    ibasic_string(T* p_buffer_, size_type MAX_SIZE_)
      : string_base(MAX_SIZE_),
        p_buffer(p_buffer_)
    {
    }




    void initialise()
    {
      current_size = 0U;
      p_buffer[0] = 0;

      set_truncated(false);

    }




    void repair_buffer(T* p_buffer_)
    {
      p_buffer = p_buffer_;
    }

  private:






    ibasic_string& replace_impl(const_iterator first, const_iterator last, const_pointer s, size_type length, bool other_truncated)
    {

      if ((first == last) && (s == nullptr || length == 0U))
      {
        return *this;
      }


      if (first > last)
      {
        return *this;
      }


      iterator first_ = to_iterator(first);
      iterator last_ = to_iterator(last);



      const bool source_overlaps = (s != nullptr) &&
                                   (s >= p_buffer) &&
                                   (s < p_buffer + current_size);

      if (source_overlaps)
      {


        erase(first_, last_);

        if (s != nullptr && length != 0U)
        {

          insert(p_buffer + (first_ - p_buffer), s, s + length);
        }

        return *this;
      }


      const size_type remove_index = size_type(first_ - p_buffer);
      const size_type remove_length = size_type(last_ - first_);
      const size_type free_space = CAPACITY - remove_index;

      size_type insert_length = (s == nullptr) ? 0U : length;


      if (insert_length > free_space)
      {
        insert_length = free_space;
      }


      size_type tail_index = remove_index + remove_length;
      size_type tail_length = current_size - tail_index;
      size_type tail_space = free_space - insert_length;


      set_truncated((insert_length != length) || (tail_space < tail_length) || is_truncated() || other_truncated);



      if (tail_space < tail_length)
      {
        tail_length = tail_space;
      }


      if (insert_length == remove_length)
      {

        etl::mem_copy(s, insert_length, &p_buffer[remove_index]);
      }
      else if (insert_length > remove_length)
      {


        etl::mem_move(&p_buffer[tail_index], tail_length, &p_buffer[remove_index + insert_length]);


        etl::mem_copy(s, insert_length, &p_buffer[remove_index]);
      }
      else
      {


        etl::mem_copy(s, insert_length, &p_buffer[remove_index]);


        etl::mem_copy(&p_buffer[tail_index], tail_length, &p_buffer[remove_index + insert_length]);
      }

      current_size = remove_index + insert_length + tail_length;
      p_buffer[current_size] = value_type(0);

      cleanup();

      return *this;
    }




    static int compare(const_pointer first1, const_pointer last1,
                       const_pointer first2, const_pointer last2)
    {
      typedef typename etl::make_unsigned<value_type>::type type;

      difference_type length1 = etl::distance(first1, last1);
      difference_type length2 = etl::distance(first2, last2);
      difference_type compare_length = etl::min(length1, length2);


      while (compare_length != 0)
      {
        if (static_cast<type>(*first1) < static_cast<type>(*first2))
        {

          return -1;
        }
        else if (static_cast<type>(*first1) > static_cast<type>(*first2))
        {

          return 1;
        }

        ++first1;
        ++first2;
        --compare_length;
      }


      if (length1 < length2)
      {

        return -1;
      }

      if (length1 > length2)
      {

        return 1;
      }


      return 0;
    }




    void cleanup()
    {

      if (is_secure())
      {
        etl::memory_clear_range(&p_buffer[current_size], &p_buffer[CAPACITY]);
      }

    }




    ibasic_string(const ibasic_string&);




    T* p_buffer;
# 2672 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  protected:

    ~ibasic_string()
    {

      if (is_secure())
      {
        clear();
      }

    }

  protected:




    iterator to_iterator(const_iterator itr) const
    {
      return const_cast<iterator>(itr);
    }




    bool is_within_buffer(const_pointer ptr) const
    {
      return (ptr >= p_buffer) && (ptr <= (p_buffer + CAPACITY));
    }

  private:





    template <typename TIterator1>
    static
    typename etl::enable_if<etl::is_pointer<typename etl::remove_reference<TIterator1>::type>::value && sizeof(typename etl::remove_pointer<typename etl::remove_cvref<TIterator1>::type>::type) == sizeof(value_type), iterator>::type
      copy_characters(TIterator1 from, size_t n, iterator to)
    {
      etl::mem_move(from, n, to);

      return to + n;
    }





    template <typename TIterator1>
    static
    typename etl::enable_if<!(etl::is_pointer<typename etl::remove_reference<TIterator1>::type>::value && sizeof(typename etl::remove_pointer<typename etl::remove_cvref<TIterator1>::type>::type) == sizeof(value_type)), iterator>::type
      copy_characters(TIterator1 from, size_t n, iterator to)
    {
      size_t count = 0;

      while (count != n)
      {
        *to++ = *from++;
        ++count;
      }

      return to;
    }




    template <typename TIterator>
    void append_impl(iterator position, TIterator first, TIterator last, bool truncated, bool secure)
    {
      difference_type start = etl::distance(p_buffer, position);
      difference_type count = etl::distance(first, last);
      difference_type free_space = etl::distance(position, p_buffer + CAPACITY);






      set_truncated((count > free_space) || this->is_truncated() || truncated);







      if (secure)
      {
        set_secure();
      }



      count = etl::min(count, free_space);
      copy_characters(first, size_t(count), position);
      current_size = size_t(start + count);
      p_buffer[current_size] = 0;

      cleanup();
    }




    void append_impl(iterator position, const_pointer src, bool truncated, bool secure)
    {
      if (src == nullptr)
      {
        clear();
        return;
      }

      difference_type start = etl::distance(p_buffer, position);
      difference_type free_space = etl::distance(position, p_buffer + CAPACITY);

      pointer dst = position;
      size_t length = get_string_length(src);
      size_t count = (length < size_t(free_space)) ? length : size_t(free_space);
      etl::mem_move(src, count, dst);

      truncated |= (src[count] != 0);
      current_size = size_t(start) + count;
      p_buffer[current_size] = 0;


      set_truncated(truncated);






      if (secure)
      {
        set_secure();
      }


      cleanup();
    }




    template <typename TIterator>
    size_type find_impl(TIterator first, TIterator last, size_type sz, size_type pos = 0) const
    {
      if ((pos + sz) > size())
      {
        return npos;
      }

      const_iterator iposition = etl::search(begin() + pos, end(), first, last);

      if (iposition == end())
      {
        return npos;
      }
      else
      {
        return etl::distance(begin(), iposition);
      }
    }




    template <typename TIterator>
    size_type rfind_impl(TIterator rfirst, TIterator rlast, size_type sz, size_type pos = 0) const
    {
      if (sz > size())
      {
        return npos;
      }

      if (pos >= size())
      {
        pos = size();
      }

      pos = size() - pos;

      const_reverse_iterator iposition = etl::search(rbegin() + pos, rend(), rfirst, rlast);

      if (iposition == rend())
      {
        return npos;
      }
      else
      {
        return size() - sz - etl::distance(rbegin(), iposition);
      }
    }




    template <typename U>
    static
    typename etl::enable_if<sizeof(U) == sizeof(char), size_t>::type
      get_string_length(const U* str)
    {
      return ::strlen(reinterpret_cast<const char*>(str));
    }





    template <typename U>
    static
    typename etl::enable_if<sizeof(U) == sizeof(wchar_t), size_t>::type
      get_string_length(const U* str)
    {
      return ::wcslen(reinterpret_cast<const wchar_t*>(str));
    }





    template <typename U>
    static

    typename etl::enable_if<(sizeof(U) != sizeof(char)) && (sizeof(U) != sizeof(wchar_t)), size_t>::type



      get_string_length(const U* str)
    {
      if (str == nullptr)
      {
        return 0;
      }

      const U* end = str;

      while (*end++ != 0)
      {

      }

      return size_t(end - str) - 1;
    }
  };
# 2928 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator ==(const etl::ibasic_string<T>& lhs, const etl::ibasic_string<T>& rhs)
  {
    return (lhs.size() == rhs.size()) && etl::equal(lhs.begin(), lhs.end(), rhs.begin());
  }
# 2941 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator ==(const etl::ibasic_string<T>& lhs, const T* rhs)
  {
    return (lhs.size() == etl::strlen(rhs)) && etl::equal(lhs.begin(), lhs.end(), rhs);
  }
# 2954 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator ==(const T* lhs, const etl::ibasic_string<T>& rhs)
  {
    return (rhs.size() == etl::strlen(lhs)) && etl::equal(rhs.begin(), rhs.end(), lhs);
  }
# 2967 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator !=(const etl::ibasic_string<T>& lhs, const etl::ibasic_string<T>& rhs)
  {
    return !(lhs == rhs);
  }
# 2980 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator !=(const etl::ibasic_string<T>& lhs, const T* rhs)
  {
    return !(lhs == rhs);
  }
# 2993 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator !=(const T* lhs, const etl::ibasic_string<T>& rhs)
  {
    return !(lhs == rhs);
  }
# 3006 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator <(const etl::ibasic_string<T>& lhs, const etl::ibasic_string<T>& rhs)
  {
    return etl::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
  }
# 3019 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator <(const etl::ibasic_string<T>& lhs, const T* rhs)
  {
    return etl::lexicographical_compare(lhs.begin(), lhs.end(), rhs, rhs + etl::strlen(rhs));
  }
# 3032 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator <(const T* lhs, const etl::ibasic_string<T>& rhs)
  {
    return etl::lexicographical_compare(lhs, lhs + etl::strlen(lhs), rhs.begin(), rhs.end());
  }
# 3046 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator >(const etl::ibasic_string<T>& lhs, const etl::ibasic_string<T>& rhs)
  {
    return (rhs < lhs);
  }
# 3059 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator >(const etl::ibasic_string<T>& lhs, const T* rhs)
  {
    return (rhs < lhs);
  }
# 3072 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator >(const T* lhs, const etl::ibasic_string<T>& rhs)
  {
    return (rhs < lhs);
  }
# 3086 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator <=(const etl::ibasic_string<T>& lhs, const etl::ibasic_string<T>& rhs)
  {
    return !(lhs > rhs);
  }
# 3099 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator <=(const etl::ibasic_string<T>& lhs, const T* rhs)
  {
    return !(lhs > rhs);
  }
# 3112 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator <=(const T* lhs, const etl::ibasic_string<T>& rhs)
  {
    return !(lhs > rhs);
  }
# 3126 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator >=(const etl::ibasic_string<T>& lhs, const etl::ibasic_string<T>& rhs)
  {
    return !(lhs < rhs);
  }
# 3139 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator >=(const etl::ibasic_string<T>& lhs, const T* rhs)
  {
    return !(lhs < rhs);
  }
# 3152 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
  template <typename T>
  bool operator >=(const T* lhs, const etl::ibasic_string<T>& rhs)
  {
    return !(lhs < rhs);
  }
# 3174 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h"
}

#undef ETL_USING_WCHAR_T_H

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
             
             
# 52 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
#undef ETL_PUSHED_MIN_MAX
# 3179 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/basic_string.h" 2
# 36 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_view.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_view.h"
#define ETL_STRING_VIEW_INCLUDED 
# 41 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_view.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/hash.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/hash.h"
#define ETL_HASH_INCLUDED 






# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/fnv_1.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/fnv_1.h"
#define ETL_FNV_1_INCLUDED 



# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/fnv_1.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/ihash.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/ihash.h"
#define ETL_IHASH_INCLUDED 
# 44 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/ihash.h"
namespace etl
{




  class hash_exception : public exception
  {
  public:

    hash_exception(string_type reason_, string_type file_name_, numeric_type line_number_)
      : exception(reason_, file_name_, line_number_)
    {}
  };





  class hash_finalised : public hash_exception
  {
  public:

    hash_finalised(string_type file_name_, numeric_type line_number_)
      : hash_exception(("19""A"), file_name_, line_number_)
    {}
  };


  typedef hash_finalised hash_finalized;
}
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/fnv_1.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/frame_check_sequence.h" 1
# 26 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/frame_check_sequence.h"
#define ETL_FRAME_CHECK_SEQUENCE_INCLUDED 



# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 31 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/frame_check_sequence.h" 2





static_assert(1, "This file does not currently support targets with no 8bit type");




namespace etl
{
  namespace private_frame_check_sequence
  {




    template <typename TFrame_Check_Sequence>
    class add_insert_iterator : public etl::iterator<etl::output_iterator_tag, typename TFrame_Check_Sequence::value_type>
    {
    public:


      explicit add_insert_iterator(TFrame_Check_Sequence& fcs)
        : p_fcs(&fcs)
      {
      }


      add_insert_iterator& operator*()
      {
        return *this;
      }


      add_insert_iterator& operator++()
      {
        return *this;
      }


      add_insert_iterator& operator++(int)
      {
        return *this;
      }


      add_insert_iterator& operator =(uint8_t value)
      {
        p_fcs->add(value);
        return *this;
      }

    private:

      TFrame_Check_Sequence* p_fcs;
    };
  }






  template <typename TPolicy>
  class frame_check_sequence
  {
  public:

    typedef TPolicy policy_type;
    typedef typename policy_type::value_type value_type;
    typedef private_frame_check_sequence::add_insert_iterator<frame_check_sequence<TPolicy> > add_insert_iterator;

    static_assert(etl::is_unsigned<value_type>::value, "Signed frame check type not supported");




    constexpr frame_check_sequence()
      : frame_check()
    {
      reset();
    }






    template<typename TIterator>
    constexpr frame_check_sequence(TIterator begin, const TIterator end) : frame_check()
    {
      static_assert(sizeof(typename etl::iterator_traits<TIterator>::value_type) == 1, "Type not supported");

      reset();
      add(begin, end);
    }




    constexpr void reset()
    {
      frame_check = policy.initial();
    }






    template<typename TIterator>
    constexpr void add(TIterator begin, const TIterator end)
    {
      static_assert(sizeof(typename etl::iterator_traits<TIterator>::value_type) == 1, "Type not supported");

      while (begin != end)
      {
        frame_check = policy.add(frame_check, *begin);
        ++begin;
      }
    }




    constexpr void add(uint8_t value_)
    {
      frame_check = policy.add(frame_check, value_);
    }




    constexpr value_type value() const
    {
      return policy.final(frame_check);
    }




    constexpr operator value_type () const
    {
      return policy.final(frame_check);
    }




    constexpr add_insert_iterator input()
    {
      return add_insert_iterator(*this);
    }

  private:

    value_type frame_check;
    policy_type policy;
  };
}
# 39 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/fnv_1.h" 2
# 49 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/fnv_1.h"
namespace etl
{





  struct fnv_1_policy_64
  {
    typedef uint64_t value_type;

    uint64_t initial() const
    {
      return OFFSET_BASIS;
    }

    uint64_t add(uint64_t hash, uint8_t value) const
    {
      hash *= PRIME;
      hash ^= value;
      return hash;
    }

    uint64_t final(uint64_t hash) const
    {
      return hash;
    }

    static constexpr uint64_t OFFSET_BASIS = 0xCBF29CE484222325ull;
    static constexpr uint64_t PRIME = 0x00000100000001b3ull;
  };





  class fnv_1_64 : public etl::frame_check_sequence<fnv_1_policy_64>
  {
  public:




    fnv_1_64()
    {
      this->reset();
    }






    template<typename TIterator>
    fnv_1_64(TIterator begin, const TIterator end)
    {
      this->reset();
      this->add(begin, end);
    }
  };





  struct fnv_1a_policy_64
    {
    typedef uint64_t value_type;

    uint64_t initial() const
      {
      return OFFSET_BASIS;
    }

    uint64_t add(uint64_t hash, uint8_t value) const
    {
      hash ^= value;
      hash *= PRIME;
      return hash;
    }

    uint64_t final(uint64_t hash) const
    {
      return hash;
    }

    static constexpr uint64_t OFFSET_BASIS = 0xCBF29CE484222325ull;
    static constexpr uint64_t PRIME = 0x00000100000001b3ull;
  };





  class fnv_1a_64 : public etl::frame_check_sequence<fnv_1a_policy_64>
  {
  public:




    fnv_1a_64()
    {
      this->reset();
    }






    template<typename TIterator>
    fnv_1a_64(TIterator begin, const TIterator end)
    {
      this->reset();
      this->add(begin, end);
    }
  };






  struct fnv_1_policy_32
    {
    typedef uint32_t value_type;

    uint32_t initial() const
      {
      return OFFSET_BASIS;
    }

    uint32_t add(uint32_t hash, uint8_t value) const
    {
      hash *= PRIME;
      hash ^= value;
      return hash;
    }

    uint32_t final(uint32_t hash) const
    {
      return hash;
    }

    static constexpr uint32_t OFFSET_BASIS = 0x811C9DC5UL;
    static constexpr uint32_t PRIME = 0x01000193UL;
  };





  class fnv_1_32 : public etl::frame_check_sequence<fnv_1_policy_32>
  {
  public:




    fnv_1_32()
    {
      this->reset();
    }






    template<typename TIterator>
    fnv_1_32(TIterator begin, const TIterator end)
    {
      this->reset();
      this->add(begin, end);
    }
  };





  struct fnv_1a_policy_32
    {
    typedef uint32_t value_type;

    uint32_t initial() const
      {
      return OFFSET_BASIS;
    }

    uint32_t add(uint32_t hash, uint8_t value) const
    {
      hash ^= value;
      hash *= PRIME;
      return hash;
    }

    uint32_t final(uint32_t hash) const
    {
      return hash;
    }

    static constexpr uint32_t OFFSET_BASIS = 0x811C9DC5UL;
    static constexpr uint32_t PRIME = 0x01000193UL;
  };





  class fnv_1a_32 : public etl::frame_check_sequence<fnv_1a_policy_32>
  {
  public:




    fnv_1a_32()
    {
      this->reset();
    }






    template<typename TIterator>
    fnv_1a_32(TIterator begin, const TIterator end)
    {
      this->reset();
      this->add(begin, end);
    }
  };
}
# 40 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/hash.h" 2
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 41 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/hash.h" 2

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 1
# 32 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h"
#define ETL_MATH_INCLUDED 
# 45 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/type_traits.h" 1
# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 2

namespace etl
{
# 61 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
# 62 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 2
  template <typename T>
  constexpr
    typename etl::enable_if<etl::is_floating_point<T>::value, bool>::type
    is_nan(T value)
  {
    return (value != value);
  }
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 70 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 2


  template <typename T>
  constexpr
  typename etl::enable_if<etl::is_integral<T>::value, bool>::type
    is_nan(T)
  {
    return false;
  }
# 92 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
# 93 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 2
  template <typename T>
  constexpr
  typename etl::enable_if<etl::is_floating_point<T>::value, bool>::type
    is_infinity(T value)
  {
    return ((value == etl::numeric_limits<T>::infinity()) ||
            (value == -etl::numeric_limits<T>::infinity()));
  }
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 102 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 2


  template <typename T>
  constexpr
  typename etl::enable_if<etl::is_integral<T>::value, bool>::type
    is_infinity(T)
  {
    return false;
  }
# 124 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
# 125 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 2
  template <typename T>
  constexpr
  typename etl::enable_if<etl::is_floating_point<T>::value, bool>::type
    is_zero(T value)
  {
    return value == 0;
  }
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 133 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 2


  template <typename T>
  constexpr
  typename etl::enable_if<etl::is_integral<T>::value, bool>::type
    is_zero(T value)
  {
    return (value == 0);
  }




# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_float_equal_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
# 147 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 2
  template <typename T>
  constexpr
  bool is_exactly_equal(T value1, T value2)
  {
    return value1 == value2;
  }
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 154 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/math.h" 2
}
# 43 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/hash.h" 2


# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 1 3







#define _STDLIB_H_ 

# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/ieeefp.h" 1 3
# 11 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 2 3


#define __need_size_t 
#define __need_wchar_t 
#define __need_NULL 
# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 1 3 4
# 173 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 252 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_size_t
# 364 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_wchar_t
# 414 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef NULL

#define NULL __null
# 425 "/home/shivani/bl602_iot_sdk/toolchain/compiler/lib/gcc/riscv32-unknown-elf/15.1.0/include/stddef.h" 3 4
#undef __need_NULL




#undef offsetof
#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)
# 17 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 2 3



# 1 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/machine/stdlib.h" 1 3

#define _MACHSTDLIB_H_ 
# 21 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 2 3
# 33 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3

# 33 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3
extern "C" {

typedef struct
{
  int quot;
  int rem;
} div_t;

typedef struct
{
  long quot;
  long rem;
} ldiv_t;


typedef struct
{
  long long int quot;
  long long int rem;
} lldiv_t;



#define __compar_fn_t_defined 
typedef int (*__compar_fn_t) (const void *, const void *);


#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

#define RAND_MAX __RAND_MAX

int __locale_mb_cur_max (void);

#define MB_CUR_MAX __locale_mb_cur_max()

void abort (void) __attribute__ ((__noreturn__));
int abs (int);





int atexit (void (*__func)(void));
double atof (const char *__nptr);



int atoi (const char *__nptr);
int _atoi_r (struct _reent *, const char *__nptr);
long atol (const char *__nptr);
long _atol_r (struct _reent *, const char *__nptr);
void * bsearch (const void *__key,
         const void *__base,
         size_t __nmemb,
         size_t __size,
         __compar_fn_t _compar);
void *calloc(size_t, size_t) __attribute__((__malloc__)) __attribute__((__warn_unused_result__))
      __attribute__((__alloc_size__(1, 2))) __attribute__ ((__nothrow__));
div_t div (int __numer, int __denom);
void exit (int __status) __attribute__ ((__noreturn__));
void free (void *) __attribute__ ((__nothrow__));
char * getenv (const char *__string);
char * _getenv_r (struct _reent *, const char *__string);



char * _findenv (const char *, int *);
char * _findenv_r (struct _reent *, const char *, int *);




long labs (long);
ldiv_t ldiv (long __numer, long __denom);
void *malloc(size_t) __attribute__((__malloc__)) __attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(1))) __attribute__ ((__nothrow__));
int mblen (const char *, size_t);
int _mblen_r (struct _reent *, const char *, size_t, _mbstate_t *);
int mbtowc (wchar_t *__restrict, const char *__restrict, size_t);
int _mbtowc_r (struct _reent *, wchar_t *__restrict, const char *__restrict, size_t, _mbstate_t *);
int wctomb (char *, wchar_t);
int _wctomb_r (struct _reent *, char *, wchar_t, _mbstate_t *);
size_t mbstowcs (wchar_t *__restrict, const char *__restrict, size_t);
size_t _mbstowcs_r (struct _reent *, wchar_t *__restrict, const char *__restrict, size_t, _mbstate_t *);
size_t wcstombs (char *__restrict, const wchar_t *__restrict, size_t);
size_t _wcstombs_r (struct _reent *, char *__restrict, const wchar_t *__restrict, size_t, _mbstate_t *);
# 137 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3
char * _mkdtemp_r (struct _reent *, char *);
int _mkostemp_r (struct _reent *, char *, int);
int _mkostemps_r (struct _reent *, char *, int, int);
int _mkstemp_r (struct _reent *, char *);
int _mkstemps_r (struct _reent *, char *, int);
char * _mktemp_r (struct _reent *, char *) __attribute__ ((__deprecated__("the use of `mktemp' is dangerous; use `mkstemp' instead")));
void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t _compar);
int rand (void);
void *realloc(void *, size_t) __attribute__((__warn_unused_result__)) __attribute__((__alloc_size__(2))) __attribute__ ((__nothrow__));
# 159 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3
void srand (unsigned __seed);
double strtod (const char *__restrict __n, char **__restrict __end_PTR);
double _strtod_r (struct _reent *,const char *__restrict __n, char **__restrict __end_PTR);

float strtof (const char *__restrict __n, char **__restrict __end_PTR);







long strtol (const char *__restrict __n, char **__restrict __end_PTR, int __base);
long _strtol_r (struct _reent *,const char *__restrict __n, char **__restrict __end_PTR, int __base);
unsigned long strtoul (const char *__restrict __n, char **__restrict __end_PTR, int __base);
unsigned long _strtoul_r (struct _reent *,const char *__restrict __n, char **__restrict __end_PTR, int __base);
# 191 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3
int system (const char *__string);
# 202 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3
void _Exit (int __status) __attribute__ ((__noreturn__));




int _putenv_r (struct _reent *, char *__string);
void * _reallocf_r (struct _reent *, void *, size_t);



int _setenv_r (struct _reent *, const char *__string, const char *__value, int __overwrite);
# 224 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3
char * __itoa (int, char *, int);
char * __utoa (unsigned, char *, int);
# 263 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3
long long atoll (const char *__nptr);

long long _atoll_r (struct _reent *, const char *__nptr);

long long llabs (long long);
lldiv_t lldiv (long long __numer, long long __denom);
long long strtoll (const char *__restrict __n, char **__restrict __end_PTR, int __base);

long long _strtoll_r (struct _reent *, const char *__restrict __n, char **__restrict __end_PTR, int __base);

unsigned long long strtoull (const char *__restrict __n, char **__restrict __end_PTR, int __base);

unsigned long long _strtoull_r (struct _reent *, const char *__restrict __n, char **__restrict __end_PTR, int __base);
# 284 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3
int _unsetenv_r (struct _reent *, const char *__string);







char * _dtoa_r (struct _reent *, double, int, int, int *, int*, char**);

void * _malloc_r (struct _reent *, size_t) __attribute__ ((__nothrow__));
void * _calloc_r (struct _reent *, size_t, size_t) __attribute__ ((__nothrow__));
void _free_r (struct _reent *, void *) __attribute__ ((__nothrow__));
void * _realloc_r (struct _reent *, void *, size_t) __attribute__ ((__nothrow__));
void _mstats_r (struct _reent *, char *);

int _system_r (struct _reent *, const char *);

void __eprintf (const char *, const char *, unsigned int, const char *);
# 322 "/home/shivani/bl602_iot_sdk/toolchain/compiler/riscv32-unknown-elf/include/stdlib.h" 3
extern long double _strtold_r (struct _reent *, const char *__restrict, char **__restrict);

extern long double strtold (const char *__restrict, char **__restrict);







void * aligned_alloc(size_t, size_t) __attribute__((__malloc__)) __attribute__((__alloc_align__(1)))
     __attribute__((__alloc_size__(2))) __attribute__((__warn_unused_result__));
int at_quick_exit(void (*)(void));
[[noreturn]] void
 quick_exit(int);


}
# 46 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/hash.h" 2




# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_useless_cast_push.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_useless_cast_push.h"
 
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_useless_cast_push.h"
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wuseless-cast"
# 51 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/hash.h" 2

namespace etl
{
  namespace private_hash
  {




    template <typename T>
    typename enable_if<sizeof(T) == sizeof(uint16_t), size_t>::type
    generic_hash(const uint8_t* begin, const uint8_t* end)
    {
      uint32_t h = fnv_1a_32(begin, end);

      return static_cast<size_t>(h ^ (h >> 16U));
    }





    template <typename T>
    typename enable_if<sizeof(T) == sizeof(uint32_t), size_t>::type
    generic_hash(const uint8_t* begin, const uint8_t* end)
    {
      return fnv_1a_32(begin, end);
    }






    template <typename T>
    typename enable_if<sizeof(T) == sizeof(uint64_t), size_t>::type
    generic_hash(const uint8_t* begin, const uint8_t* end)
    {
      return fnv_1a_64(begin, end);
    }





    template<typename T, bool Is_Enum = false>
    struct hash_base
    {
    private:
      hash_base();
      hash_base(const hash_base& other);
      hash_base& operator=(const hash_base& other);


      hash_base(hash_base&& other);
      hash_base& operator=(hash_base&& other);

    };


  }






  template <typename T>
  struct hash : private_hash::hash_base<T, etl::is_enum<T>::value>{};
# 132 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/hash.h"
  template <>
  struct hash <bool>
  {
    static_assert(sizeof(size_t) >= sizeof(bool), "size_t smaller than type");

    size_t operator ()(bool v) const
    {
      return static_cast<size_t>(v);
    }
  };





  template <>
  struct hash<char>
  {
    static_assert(sizeof(size_t) >= sizeof(char), "size_t smaller than type");

    size_t operator ()(char v) const
    {
      return static_cast<size_t>(v);
    }
  };





  template <>
  struct hash<signed char>
  {
    static_assert(sizeof(size_t) >= sizeof(signed char), "size_t smaller than type");

    size_t operator ()(signed char v) const
    {
      return static_cast<size_t>(v);
    }
  };





  template<>
  struct hash<unsigned char>
  {
    static_assert(sizeof(size_t) >= sizeof(unsigned char), "size_t smaller than type");

    size_t operator ()(unsigned char v) const
    {
      return static_cast<size_t>(v);
    }
  };





  template<>
  struct hash<wchar_t>
  {
    size_t operator ()(wchar_t v) const
    {

      if constexpr(sizeof(size_t) >= sizeof(v))
      {
        return static_cast<size_t>(v);
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<short>
  {
    size_t operator ()(short v) const
    {

      if constexpr(sizeof(size_t) >= sizeof(v))
      {
        return static_cast<size_t>(v);
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<unsigned short>
  {
    size_t operator ()(unsigned short v) const
    {

      if constexpr(sizeof(size_t) >= sizeof(v))
      {
        return static_cast<size_t>(v);
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<int>
  {
    size_t operator ()(int v) const
    {

      if constexpr(sizeof(size_t) >= sizeof(v))
      {
        return static_cast<size_t>(v);
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<unsigned int>
  {
    size_t operator ()(unsigned int v) const
    {

      if constexpr(sizeof(size_t) >= sizeof(v))
      {
        return static_cast<size_t>(v);
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<long>
  {
    size_t operator ()(long v) const
    {

      if constexpr(sizeof(size_t) >= sizeof(v))
      {
        return static_cast<size_t>(v);
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<long long>
  {
    size_t operator ()(long long v) const
    {

      if constexpr(sizeof(size_t) >= sizeof(v))
      {
        return static_cast<size_t>(v);
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<unsigned long>
  {
    size_t operator ()(unsigned long v) const
    {

      if constexpr(sizeof(size_t) >= sizeof(v))
      {
        return static_cast<size_t>(v);
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<unsigned long long>
  {
    size_t operator ()(unsigned long long v) const
    {

      if constexpr(sizeof(size_t) >= sizeof(v))
      {
        return static_cast<size_t>(v);
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<float>
  {
    size_t operator ()(float v) const
    {

      if constexpr(sizeof(size_t) == sizeof(v))
      {
        union
        {
          size_t s;
          float v;
        } u;

        if (etl::is_zero(v))
        {
          v = 0.0f;
        }
        u.v = v;

        return u.s;
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<double>
  {
    size_t operator ()(double v) const
    {

      if constexpr(sizeof(size_t) == sizeof(v))
      {
        union
        {
          size_t s;
          double v;
        } u;

        if (etl::is_zero(v))
        {
          v = 0.0;
        }
        u.v = v;

        return u.s;
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template<>
  struct hash<long double>
  {
    size_t operator ()(long double v) const
    {

      if constexpr(sizeof(size_t) == sizeof(v))
      {
        union
        {
          size_t s;
          long double v;
        } u;

        if (etl::is_zero(v))
        {
          v = 0.0L;
        }
        u.v = v;

        return u.s;
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };





  template <typename T>
  struct hash<T*>
  {
    size_t operator ()(const T* v) const
    {

      if (sizeof(size_t) == sizeof(T*))
      {
        union
        {
          size_t s;
          const T* v;
        } u;

        u.v = v;

        return u.s;
      }
      else
      {
        uint8_t* p = reinterpret_cast<uint8_t*>(&v);
        return private_hash::generic_hash<size_t>(p, p + sizeof(v));
      }
    }
  };

  namespace private_hash
  {



    template<typename T>
    struct hash_base<T, true>
    {
      size_t operator()(T v) const
      {
        if (sizeof(size_t) >= sizeof(T))
        {
          return static_cast<size_t>(v);
        }
        else
        {
          return ::etl::hash<unsigned long long>()(static_cast<unsigned long long>(v));
        }
      }
    };
  }
}

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h" 1
# 38 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/diagnostic_pop.h"
#pragma GCC diagnostic pop
# 542 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/hash.h" 2
# 42 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_view.h" 2


# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
             
             
# 56 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
#define ETL_PUSHED_MIN_MAX 
# 45 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_view.h" 2
# 56 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_view.h"
namespace etl
{



  class string_view_exception : public exception
  {
  public:

    string_view_exception(string_type reason_, string_type file_name_, numeric_type line_number_)
      : exception(reason_, file_name_, line_number_)
    {
    }
  };





  class string_view_bounds : public string_view_exception
  {
  public:

    string_view_bounds(string_type file_name_, numeric_type line_number_)
      : string_view_exception(("42""A"), file_name_, line_number_)
    {
    }
  };





  class string_view_uninitialised : public string_view_exception
  {
  public:

    string_view_uninitialised(string_type file_name_, numeric_type line_number_)
      : string_view_exception(("42""B"), file_name_, line_number_)
    {
    }
  };




  template <typename T, typename TTraits = etl::char_traits<T> >
  class basic_string_view
  {
  public:

    typedef T value_type;
    typedef TTraits traits_type;
    typedef size_t size_type;
    typedef T& reference;
    typedef const T& const_reference;
    typedef T* pointer;
    typedef const T* const_pointer;
    typedef const T* iterator;
    typedef const T* const_iterator;
    typedef etl::reverse_iterator<const_iterator> const_reverse_iterator;

    enum
    {
      npos = etl::integral_limits<size_t>::max
    };




    constexpr basic_string_view()
      : mbegin(nullptr)
      , mend(nullptr)
    {
    }




    constexpr basic_string_view(const etl::ibasic_string<T>& str)
      : mbegin(str.begin())
      , mend(str.end())
    {
    }




    constexpr basic_string_view(const T* begin_)
      : mbegin(begin_)
      , mend(begin_ + TTraits::length(begin_))
    {
    }




    constexpr basic_string_view(const T* begin_, const T* end_)
      : mbegin(begin_)
      , mend(end_)
    {
    }




    constexpr basic_string_view(const T* begin_, size_t size_)
      : mbegin(begin_)
      , mend(begin_ + size_)
    {
    }




    constexpr basic_string_view(const basic_string_view& other)
      : mbegin(other.mbegin)
      , mend(other.mend)
    {
    }




    constexpr const_reference front() const
    {
      return *mbegin;
    }




    constexpr const_reference back() const
    {
      return *(mend - 1);
    }




    constexpr const_pointer data() const
    {
      return mbegin;
    }




    constexpr const_iterator begin() const
    {
      return mbegin;
    }




    constexpr const_iterator cbegin() const
    {
      return mbegin;
    }




    constexpr const_iterator end() const
    {
      return mend;
    }




    constexpr const_iterator cend() const
    {
      return mend;
    }




    constexpr const_reverse_iterator rbegin() const
    {
      return const_reverse_iterator(mend);
    }




    constexpr const_reverse_iterator crbegin() const
    {
      return const_reverse_iterator(mend);
    }




    constexpr const_reverse_iterator rend() const
    {
      return const_reverse_iterator(mbegin);
    }




    constexpr const_reverse_iterator crend() const
    {
      return const_reverse_iterator(mbegin);
    }
# 272 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_view.h"
    constexpr bool empty() const
    {
      return (mbegin == mend);
    }




    constexpr size_t size() const
    {
      return static_cast<size_t>(mend - mbegin);
    }




    constexpr size_t length() const
    {
      return size();
    }




    constexpr size_t max_size() const
    {
      return size();
    }




    constexpr etl::basic_string_view<T, TTraits>& operator=(const etl::basic_string_view<T, TTraits>& other)
    {
      mbegin = other.mbegin;
      mend = other.mend;
      return *this;
    }




    constexpr void assign(const_pointer begin_, const_pointer end_)
    {
      mbegin = begin_;
      mend = end_;
    }




    constexpr void assign(const_pointer begin_, size_t size_)
    {
      mbegin = begin_;
      mend = begin_ + size_;
    }




    constexpr const_reference operator[](size_t i) const
    {
      return mbegin[i];
    }




    const_reference at(size_t i) const
    {
      static_cast<void>(sizeof((mbegin != nullptr && mend != nullptr)));
      static_cast<void>(sizeof(i < size()));
      return mbegin[i];
    }




    constexpr void swap(basic_string_view& other)
    {
      using etl::swap;

      swap(mbegin, other.mbegin);
      swap(mend, other.mend);
    }




    constexpr size_type copy(T* destination, size_type count, size_type position = 0) const
    {
      size_t n = 0UL;

      if (position < size())
      {
        n = etl::min(count, size() - position);

        etl::mem_copy(mbegin + position, n, destination);
      }

      return n;
    }




    constexpr basic_string_view substr(size_type position = 0, size_type count = npos) const
    {
      basic_string_view view = basic_string_view();

      if (position < size())
      {
        size_t n = etl::min(count, size() - position);

        view = basic_string_view(mbegin + position, mbegin + position + n);
      }

      return view;
    }




    constexpr void remove_prefix(size_type n)
    {
      mbegin += n;
    }




    constexpr void remove_suffix(size_type n)
    {
      mend -= n;
    }




    constexpr int compare(basic_string_view<T, TTraits> view) const
    {
      return (*this == view) ? 0 : ((*this > view) ? 1 : -1);
    }

    constexpr int compare(size_type position, size_type count, basic_string_view view) const
    {
      return substr(position, count).compare(view);
    }

    constexpr int compare(size_type position1, size_type count1,
                                basic_string_view view,
                                size_type position2, size_type count2) const
    {
      return substr(position1, count1).compare(view.substr(position2, count2));
    }

    constexpr int compare(const T* text) const
    {
      const T* view_itr = mbegin;
      const T* text_itr = text;

      while (view_itr != mend && *text_itr != T(0))
      {
        if (*view_itr < *text_itr)
        {
          return -1;
        }
        else if (*view_itr > *text_itr)
        {
          return 1;
        }
        ++view_itr;
        ++text_itr;
      }

      if ((view_itr == mend) && (*text_itr == T(0)))
      {
        return 0;
      }
      else if (view_itr == mend)
      {
        return -1;
      }
      else
      {
        return 1;
      }
    }

    constexpr int compare(size_type position, size_type count, const T* text) const
    {
      return substr(position, count).compare(text);
    }

    constexpr int compare(size_type position, size_type count1, const T* text, size_type count2) const
    {
      return substr(position, count1).compare(etl::basic_string_view<T, TTraits>(text, count2));
    }




    constexpr bool starts_with(etl::basic_string_view<T, TTraits> view) const
    {
      return (size() >= view.size()) &&
             (compare(0, view.size(), view) == 0);
    }

    constexpr bool starts_with(T c) const
    {
      return !empty() && (front() == c);
    }

    constexpr bool starts_with(const T* text) const
    {
      size_t lengthtext = TTraits::length(text);

      return (size() >= lengthtext) &&
             (compare(0, lengthtext, text) == 0);
    }




    constexpr bool ends_with(etl::basic_string_view<T, TTraits> view) const
    {
      return (size() >= view.size()) &&
             (compare(size() - view.size(), npos, view) == 0);
    }

    constexpr bool ends_with(T c) const
    {
      return !empty() && (back() == c);
    }

    constexpr bool ends_with(const T* text) const
    {
      size_t lengthtext = TTraits::length(text);
      size_t lengthview = size();

      return (lengthview >= lengthtext) &&
             (compare(lengthview - lengthtext, lengthtext, text) == 0);
    }




    constexpr size_type find(etl::basic_string_view<T, TTraits> view, size_type position = 0) const
    {
      if ((size() < view.size()))
      {
        return npos;
      }

      const_iterator iposition = etl::search(begin() + position, end(), view.begin(), view.end());

      if (iposition == end())
      {
        return npos;
      }
      else
      {
        return etl::distance(begin(), iposition);
      }
    }

    constexpr size_type find(T c, size_type position = 0) const
    {
      return find(etl::basic_string_view<T, TTraits>(&c, 1), position);
    }

    constexpr size_type find(const T* text, size_type position, size_type count) const
    {
      return find(etl::basic_string_view<T, TTraits>(text, count), position);
    }

    constexpr size_type find(const T* text, size_type position = 0) const
    {
      return find(etl::basic_string_view<T, TTraits>(text), position);
    }




    constexpr size_type rfind(etl::basic_string_view<T, TTraits> view, size_type position = npos) const
    {
      if ((size() < view.size()))
      {
        return npos;
      }

      position = etl::min(position, size());

      const_iterator iposition = etl::find_end(begin(),
                                               begin() + position,
                                               view.begin(),
                                               view.end());

      if (iposition == end())
      {
        return npos;
      }
      else
      {
        return etl::distance(begin(), iposition);
      }
    }

    constexpr size_type rfind(T c, size_type position = npos) const
    {
      return rfind(etl::basic_string_view<T, TTraits>(&c, 1), position);
    }

    constexpr size_type rfind(const T* text, size_type position, size_type count) const
    {
      return rfind(etl::basic_string_view<T, TTraits>(text, count), position);
    }

    constexpr size_type rfind(const T* text, size_type position = npos) const
    {
      return rfind(etl::basic_string_view<T, TTraits>(text), position);
    }




    constexpr size_type find_first_of(etl::basic_string_view<T, TTraits> view, size_type position = 0) const
    {
      const size_t lengthtext = size();

      if (position < lengthtext)
      {
        for (size_t i = position; i < lengthtext; ++i)
        {
          const size_t lengthview = view.size();

          for (size_t j = 0UL; j < lengthview; ++j)
          {
            if (mbegin[i] == view[j])
            {
              return i;
            }
          }
        }
      }

      return npos;
    }

    constexpr size_type find_first_of(T c, size_type position = 0) const
    {
      return find_first_of(etl::basic_string_view<T, TTraits>(&c, 1), position);
    }

    constexpr size_type find_first_of(const T* text, size_type position, size_type count) const
    {
      return find_first_of(etl::basic_string_view<T, TTraits>(text, count), position);
    }

    constexpr size_type find_first_of(const T* text, size_type position = 0) const
    {
      return find_first_of(etl::basic_string_view<T, TTraits>(text), position);
    }




    constexpr size_type find_last_of(etl::basic_string_view<T, TTraits> view, size_type position = npos) const
    {
      if (empty())
      {
        return npos;
      }

      position = etl::min(position, size() - 1);

      const_reverse_iterator it = rbegin() + size() - position - 1;

      while (it != rend())
      {
        const size_t viewlength = view.size();

        for (size_t j = 0UL; j < viewlength; ++j)
        {
          if (mbegin[position] == view[j])
          {
            return position;
          }
        }

        ++it;
        --position;
      }

      return npos;
    }

    constexpr size_type find_last_of(T c, size_type position = npos) const
    {
      return find_last_of(etl::basic_string_view<T, TTraits>(&c, 1), position);
    }

    constexpr size_type find_last_of(const T* text, size_type position, size_type count) const
    {
      return find_last_of(etl::basic_string_view<T, TTraits>(text, count), position);
    }

    constexpr size_type find_last_of(const T* text, size_type position = npos) const
    {
      return find_last_of(etl::basic_string_view<T, TTraits>(text), position);
    }




    constexpr size_type find_first_not_of(etl::basic_string_view<T, TTraits> view, size_type position = 0) const
    {
      const size_t lengthtext = size();

      if (position < lengthtext)
      {
        for (size_t i = position; i < lengthtext; ++i)
        {
          bool found = false;

          const size_t viewlength = view.size();

          for (size_t j = 0UL; j < viewlength; ++j)
          {
            if (mbegin[i] == view[j])
            {
              found = true;
              break;
            }
          }

          if (!found)
          {
            return i;
          }
        }
      }

      return npos;
    }

    constexpr size_type find_first_not_of(T c, size_type position = 0) const
    {
      return find_first_not_of(etl::basic_string_view<T, TTraits>(&c, 1), position);
    }

    constexpr size_type find_first_not_of(const T* text, size_type position, size_type count) const
    {
      return find_first_not_of(etl::basic_string_view<T, TTraits>(text, count), position);
    }

    constexpr size_type find_first_not_of(const T* text, size_type position = 0) const
    {
      return find_first_not_of(etl::basic_string_view<T, TTraits>(text), position);
    }




    constexpr size_type find_last_not_of(etl::basic_string_view<T, TTraits> view, size_type position = npos) const
    {
      if (empty())
      {
        return npos;
      }

      position = etl::min(position, size() - 1);

      const_reverse_iterator it = rbegin() + size() - position - 1;

      while (it != rend())
      {
        bool found = false;

        const size_t viewlength = view.size();

        for (size_t j = 0UL; j < viewlength; ++j)
        {
          if (mbegin[position] == view[j])
          {
            found = true;
            break;
          }
        }

        if (!found)
        {
          return position;
        }

        ++it;
        --position;
      }

      return npos;
    }

    constexpr size_type find_last_not_of(T c, size_type position = npos) const
    {
      return find_last_not_of(etl::basic_string_view<T, TTraits>(&c, 1), position);
    }

    constexpr size_type find_last_not_of(const T* text, size_type position, size_type count) const
    {
      return find_last_not_of(etl::basic_string_view<T, TTraits>(text, count), position);
    }

    constexpr size_type find_last_not_of(const T* text, size_type position = npos) const
    {
      return find_last_not_of(etl::basic_string_view<T, TTraits>(text), position);
    }




    bool contains(const etl::basic_string_view<T, TTraits>& view) const
    {
      return find(view) != npos;
    }




    bool contains(const_pointer s) const
    {
      return find(s) != npos;
    }




    bool contains(value_type c) const
    {
      return find(c) != npos;
    }




    friend constexpr bool operator == (const etl::basic_string_view<T, TTraits>& lhs, const etl::basic_string_view<T, TTraits>& rhs)
    {
      return (lhs.size() == rhs.size()) &&
              etl::equal(lhs.begin(), lhs.end(), rhs.begin());
    }




    friend constexpr bool operator != (const etl::basic_string_view<T, TTraits>& lhs, const etl::basic_string_view<T, TTraits>& rhs)
    {
      return !(lhs == rhs);
    }




    friend constexpr bool operator < (const etl::basic_string_view<T, TTraits>& lhs, const etl::basic_string_view<T, TTraits>& rhs)
    {
      return etl::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
    }




    friend constexpr bool operator > (const etl::basic_string_view<T, TTraits>& lhs, const etl::basic_string_view<T, TTraits>& rhs)
    {
      return rhs < lhs;
    }




    friend constexpr bool operator <= (const etl::basic_string_view<T, TTraits>& lhs, const etl::basic_string_view<T, TTraits>& rhs)
    {
      return !(lhs > rhs);
    }




    friend constexpr bool operator >= (const etl::basic_string_view<T, TTraits>& lhs, const etl::basic_string_view<T, TTraits>& rhs)
    {
      return !(lhs < rhs);
    }

  private:

    const_pointer mbegin;
    const_pointer mend;
  };

  typedef etl::basic_string_view<char> string_view;
  typedef etl::basic_string_view<wchar_t> wstring_view;
  typedef etl::basic_string_view<char8_t> u8string_view;
  typedef etl::basic_string_view<char16_t> u16string_view;
  typedef etl::basic_string_view<char32_t> u32string_view;




  template<size_t Array_Size>
  constexpr string_view make_string_view(const char(&text)[Array_Size])
  {
    size_t length = etl::char_traits<char>::length(text, Array_Size - 1U);

    return string_view(text, length);
  }


  template<size_t Array_Size>
  constexpr wstring_view make_string_view(const wchar_t(&text)[Array_Size])
  {
    size_t length = etl::char_traits<wchar_t>::length(text, Array_Size - 1U);

    return wstring_view(text, length);
  }


  template<size_t Array_Size>
  constexpr u8string_view make_string_view(const char8_t(&text)[Array_Size])
  {
    size_t length = etl::char_traits<char8_t>::length(text, Array_Size - 1U);

    return u8string_view(text, length);
  }


  template<size_t Array_Size>
  constexpr u16string_view make_string_view(const char16_t(&text)[Array_Size])
  {
    size_t length = etl::char_traits<char16_t>::length(text, Array_Size - 1U);

    return u16string_view(text, length);
  }


  template<size_t Array_Size>
  constexpr u32string_view make_string_view(const char32_t(&text)[Array_Size])
  {
    size_t length = etl::char_traits<char32_t>::length(text, Array_Size - 1U);

    return u32string_view(text, length);
  }





  template <>
  struct hash<etl::string_view>
  {
    size_t operator()(const etl::string_view& text) const
    {
      return etl::private_hash::generic_hash<size_t>(reinterpret_cast<const uint8_t*>(text.data()),
                                                     reinterpret_cast<const uint8_t*>(text.data() + text.size()));
    }
  };

  template <>
  struct hash<etl::wstring_view>
  {
    size_t operator()(const etl::wstring_view& text) const
    {
      return etl::private_hash::generic_hash<size_t>(reinterpret_cast<const uint8_t*>(text.data()),
                                                     reinterpret_cast<const uint8_t*>(text.data() + text.size()));
    }
  };

  template <>
  struct hash<etl::u16string_view>
  {
    size_t operator()(const etl::u16string_view& text) const
    {
      return etl::private_hash::generic_hash<size_t>(reinterpret_cast<const uint8_t*>(text.data()),
                                                     reinterpret_cast<const uint8_t*>(text.data() + text.size()));
    }
  };

  template <>
  struct hash<etl::u32string_view>
  {
    size_t operator()(const etl::u32string_view& text) const
    {
      return etl::private_hash::generic_hash<size_t>(reinterpret_cast<const uint8_t*>(text.data()),
                                                     reinterpret_cast<const uint8_t*>(text.data() + text.size()));
    }
  };

}




template <typename T, typename TTraits >
void swap(etl::basic_string_view<T, TTraits>& lhs, etl::basic_string_view<T, TTraits>& rhs)
{
  lhs.swap(rhs);
}

template <typename T>
void swap(etl::basic_string_view<T, etl::char_traits<T> >& lhs, etl::basic_string_view<T, etl::char_traits<T> >& rhs)
{
  lhs.swap(rhs);
}
# 995 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_view.h"
# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
             
             
# 52 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
#undef ETL_PUSHED_MIN_MAX
# 996 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string_view.h" 2
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string.h" 2





# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
             
             
# 56 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_push.h"
#define ETL_PUSHED_MIN_MAX 
# 43 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string.h" 2

namespace etl
{

  inline namespace literals
  {
    inline namespace string_literals
    {
      inline constexpr etl::string_view operator ""_sv(const char* str, size_t length)
      {
        return etl::string_view{ str, length };
      }
    }
  }


  typedef etl::ibasic_string<char> istring;






  template <size_t MAX_SIZE_>
  class string : public istring
  {
  public:

    typedef istring base_type;
    typedef istring interface_type;

    typedef istring::value_type value_type;
    typedef istring::size_type size_type;

    static constexpr size_t MAX_SIZE = MAX_SIZE_;




    string()
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      this->initialise();
    }





    string(const etl::string<MAX_SIZE_>& other)
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      this->initialise();
      this->assign(other);
    }





    string(const etl::istring& other)
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      this->initialise();
      this->assign(other);
    }







    string(const etl::istring& other, size_t position, size_t length = npos)
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      static_cast<void>(sizeof(position < other.size()));

      this->initialise();
      this->assign(other, position, length);
    }





    string(const value_type* text)
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      this->initialise();
      this->assign(text);
    }






    string(const value_type* text, size_t count)
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      this->initialise();
      this->assign(text, text + count);
    }






    string(size_type count, value_type c)
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      this->initialise();
      this->resize(count, c);
    }







    template <typename TIterator>
    string(TIterator first, TIterator last, typename etl::enable_if<!etl::is_integral<TIterator>::value, int>::type = 0)
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      this->initialise();
      this->assign(first, last);
    }





    string(std::initializer_list<value_type> init)
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      this->initialise();
      this->assign(init.begin(), init.end());
    }






    explicit string(const etl::string_view& view)
      : istring(reinterpret_cast<value_type*>(&buffer), MAX_SIZE)
    {
      this->initialise();
      this->assign(view.begin(), view.end());
    }






    etl::string<MAX_SIZE_> substr(size_type position = 0, size_type length_ = npos) const
    {
      etl::string<MAX_SIZE_> new_string;

      if (position != this->size())
      {
        static_cast<void>(sizeof(position < this->size()));

        length_ = etl::min(length_, this->size() - position);

        new_string.assign(buffer + position, buffer + position + length_);
      }

      return new_string;
    }




    string& operator = (const string& rhs)
    {
      if (&rhs != this)
      {
        this->assign(rhs);
      }

      return *this;
    }





    string& operator = (const istring& rhs)
    {
      if (&rhs != this)
      {
        this->assign(rhs);
      }

      return *this;
    }




    string& operator = (const value_type* text)
    {
      this->assign(text);

      return *this;
    }




    string& operator = (const etl::string_view& view)
    {
      this->assign(view);

      return *this;
    }







    void repair()

    {
      etl::istring::repair_buffer(buffer);
    }

  private:

    value_type buffer[MAX_SIZE + 1];
  };

  template <size_t MAX_SIZE_>
  constexpr typename string<MAX_SIZE_>::size_type string<MAX_SIZE_>::MAX_SIZE;





  class string_ext : public istring
  {
  public:

    typedef istring base_type;
    typedef istring interface_type;

    typedef istring::value_type value_type;
    typedef istring::size_type size_type;




    string_ext(value_type* buffer, size_type buffer_size)
      : istring(buffer, buffer_size - 1U)
    {
      this->initialise();
    }





    string_ext(const etl::string_ext& other, value_type* buffer, size_type buffer_size)
      : istring(buffer, buffer_size - 1U)
    {
      if (this->is_within_buffer(other.data()))
      {
        this->current_size = other.size();
      }
      else
      {
        this->initialise();
        this->assign(other);
      }
    }





    string_ext(const etl::istring& other, value_type* buffer, size_type buffer_size)
      : istring(buffer, buffer_size - 1U)
    {
      if (this->is_within_buffer(other.data()))
      {
        this->current_size = other.size();
      }
      else
      {
        this->initialise();
        this->assign(other);
      }
    }







    string_ext(const etl::istring& other, value_type* buffer, size_type buffer_size, size_type position, size_type length = npos)
      : istring(buffer, buffer_size - 1U)
    {
      static_cast<void>(sizeof(position < other.size()));

      if (this->is_within_buffer(other.data()))
      {
        this->current_size = other.size();
      }
      else
      {
        this->initialise();
        this->assign(other, position, length);
      }
    }





    template <typename TPointer>
    string_ext(TPointer text, value_type* buffer, size_type buffer_size,
               typename etl::enable_if<etl::is_same<const value_type*, TPointer>::value, int>::type* = nullptr)
      : istring(buffer, buffer_size - 1U)
    {
      if (this->is_within_buffer(text))
      {
        this->current_size = etl::strlen(buffer);
      }
      else
      {
        this->initialise();
        this->assign(text, text + etl::strlen(text));
      }
    }





    template <size_t Size>
    string_ext(const value_type (&literal)[Size], value_type* buffer, size_type buffer_size)
      : istring(buffer, buffer_size - 1U)
    {
      if (this->is_within_buffer(literal))
      {
        this->current_size = etl::strlen(literal);
      }
      else
      {
        this->initialise();
        this->assign(literal);
      }
    }






    string_ext(const value_type* text, size_type count, value_type* buffer, size_type buffer_size)
      : istring(buffer, buffer_size - 1U)
    {
      if (this->is_within_buffer(text))
      {
        this->current_size = count;
      }
      else
      {
        this->initialise();
        this->assign(text, text + count);
      }
    }






    string_ext(size_type count, value_type c, value_type* buffer, size_type buffer_size)
      : istring(buffer, buffer_size - 1U)
    {
      this->initialise();
      this->resize(count, c);
    }





    explicit string_ext(const etl::string_view& view, value_type* buffer, size_type buffer_size)
      : istring(buffer, buffer_size - 1U)
    {
      if (this->is_within_buffer(view.data()))
      {
        this->current_size = view.size();
      }
      else
      {
        this->initialise();
        this->assign(view.begin(), view.end());
      }
    }







    template <typename TIterator>
    string_ext(TIterator first, TIterator last, value_type* buffer, size_type buffer_size, typename etl::enable_if<!etl::is_integral<TIterator>::value, int>::type = 0)
      : istring(buffer, buffer_size - 1U)
    {
      if (this->is_within_buffer(etl::addressof(*first)))
      {
        this->current_size = etl::distance(first, last);
      }
      else
      {
        this->initialise();
        this->assign(first, last);
      }
    }





    string_ext(std::initializer_list<value_type> init, value_type* buffer, size_type buffer_size)
      : istring(buffer, buffer_size - 1U)
    {
      this->initialise();
      this->assign(init.begin(), init.end());
    }





    string_ext& operator = (const string_ext& rhs)
    {
      if (&rhs != this)
      {
        this->assign(rhs);
      }

      return *this;
    }




    string_ext& operator = (const istring& rhs)
    {
      if (&rhs != this)
      {
        this->assign(rhs);
      }

      return *this;
    }




    string_ext& operator = (const value_type* text)
    {
      this->assign(text);

      return *this;
    }




    string_ext& operator = (const etl::string_view& view)
    {
      this->assign(view);

      return *this;
    }







    void repair()

    {
    }

  private:




    string_ext(const string_ext& other) = delete;
  };





  template <>
  struct hash<etl::istring>
  {
    size_t operator()(const etl::istring& text) const
    {
      return etl::private_hash::generic_hash<size_t>(reinterpret_cast<const uint8_t*>(text.data()),
                                                     reinterpret_cast<const uint8_t*>(text.data() + text.size()));
    }
  };

  template <size_t SIZE>
  struct hash<etl::string<SIZE> >
  {
    size_t operator()(const etl::string<SIZE>& text) const
    {
      return etl::private_hash::generic_hash<size_t>(reinterpret_cast<const uint8_t*>(text.data()),
                                                     reinterpret_cast<const uint8_t*>(text.data() + text.size()));
    }
  };

  template <>
  struct hash<etl::string_ext>
  {
    size_t operator()(const etl::string_ext& text) const
    {
      return etl::private_hash::generic_hash<size_t>(reinterpret_cast<const uint8_t*>(text.data()),
                                                     reinterpret_cast<const uint8_t*>(text.data() + text.size()));
    }
  };





  template<size_t Array_Size>
  etl::string<Array_Size - 1U> make_string(const char(&text)[Array_Size])
  {
    return etl::string<Array_Size - 1U>(text, etl::strlen(text, Array_Size - 1));
  }




  template<size_t MAX_SIZE, size_t SIZE>
  etl::string<MAX_SIZE> make_string_with_capacity(const char(&text)[SIZE])
  {
    return etl::string<MAX_SIZE>(text, etl::strlen(text, SIZE));
  }
}

# 1 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h" 1
# 37 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
             
             
# 52 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/private/minmax_pop.h"
#undef ETL_PUSHED_MIN_MAX
# 607 "/home/shivani/bl602_iot_sdk/components/3rdparty/etl/include/etl/string.h" 2
# 11 "/home/shivani/bl602_iot_sdk/customer_app/suas_app_freertos_watchdog/suas_app_freertos_tasks/main.cpp" 2


constexpr uint8_t STACK_SIZE = 128;




void task_one([[gnu::unused]] void *pvParameters) {
  uint16_t i = 0;
  while (1) {

    i++;


    printf("%s: looped %d times\r\n", __func__, i);


    vTaskDelay(( ( TickType_t ) ( ( ( TickType_t ) ( 1000 ) * ( TickType_t ) ( ( TickType_t ) 1000 ) ) / ( TickType_t ) 1000 ) ));
  }


  vTaskDelete(nullptr);
}


void task_two(void *pvParameters) {

  auto number = reinterpret_cast<uintptr_t>(pvParameters);

  while (1) {

    printf("%s: received number %d\r\n", __func__, number);


    vTaskDelay(( ( TickType_t ) ( ( ( TickType_t ) ( 5000 ) * ( TickType_t ) ( ( TickType_t ) 1000 ) ) / ( TickType_t ) 1000 ) ));
  }


  vTaskDelete(nullptr);
}


void task_three_function_one(void) {

  auto number = reinterpret_cast<uintptr_t>(pvTaskGetThreadLocalStoragePointer(
                                      nullptr,
                                0));

  number++;

  vTaskSetThreadLocalStoragePointer(
                 nullptr,
                                0,

      reinterpret_cast<void *>(static_cast<uintptr_t>(number)));
}


void task_three_function_two(void) {
  auto number = reinterpret_cast<uintptr_t>(
      pvTaskGetThreadLocalStoragePointer(nullptr, 0));
  printf("%s: current number value: %d\r\n", __func__, number);
}



void task_three(void *pvParameters) {

  auto second_task = static_cast<TaskHandle_t>(pvParameters);


  uint8_t number = 0;


  vTaskSetThreadLocalStoragePointer(
                                            nullptr,
                                0,
                 reinterpret_cast<void *>(static_cast<uintptr_t>(number)));


  for (auto i = 0; i < 10; i++) {
    task_three_function_one();
    task_three_function_two();


    vTaskDelay(( ( TickType_t ) ( ( ( TickType_t ) ( 3000 ) * ( TickType_t ) ( ( TickType_t ) 1000 ) ) / ( TickType_t ) 1000 ) ));
  }


  printf("Deleting task two\r\n");
  vTaskDelete(second_task);


  printf("Deleting task three\r\n");
  vTaskDelete(nullptr);
}


extern "C" void bfl_main(void) {

  vInitializeBL602();


  xTaskCreate(
      task_one,
      etl::string_view("first task").data(),
      STACK_SIZE,
      nullptr,
      10,
      nullptr
  );

  TaskHandle_t second_task_handle;
  xTaskCreate(
      task_two,
      etl::string_view("second task").data(),
      STACK_SIZE,
      reinterpret_cast<void *>(42),

      10,
      &second_task_handle
  );

  xTaskCreate(task_three, etl::string_view("third task").data(), STACK_SIZE,
              static_cast<void *>(second_task_handle), 10, nullptr);


  vTaskStartScheduler();
}
